{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyCAC User's Manual Updated Feb 02 2020 Copyright \u00a9 2017-2018 Georgia Institute of Technology. All Rights Reserved. PyCAC, the concurrent atomistic-continuum (CAC) simulation environment, is a software suite that allows users to run CAC simulations and analyze data. Currently, the CAC simulator and analyzer are written in Fortran 2008, with different parts of the workflow glued by a Python scripting interface. A pdf version of this manual can be downloaded here . This user's manual is maintained by Shuozhi Xu , Kevin Chu , and Alex Selimov . Kevin and Alex are current Ph.D. students, while Shuozhi is a former Ph.D. student and Postdoctoral Fellow with Prof. David L. McDowell at the Georgia Institute of Technology . The PyCAC interface is open-source and the CAC simulator code is available upon request. For access, please email Prof. David L. McDowell . GUI source code PyPi (Recommended): Use Python pip to seamlessly install the PyCAC GUI. GitHub : Please navigate to the gui/ folder in the repository and follow the instructions there.","title":"Home"},{"location":"#pycac-users-manual","text":"Updated Feb 02 2020 Copyright \u00a9 2017-2018 Georgia Institute of Technology. All Rights Reserved. PyCAC, the concurrent atomistic-continuum (CAC) simulation environment, is a software suite that allows users to run CAC simulations and analyze data. Currently, the CAC simulator and analyzer are written in Fortran 2008, with different parts of the workflow glued by a Python scripting interface. A pdf version of this manual can be downloaded here . This user's manual is maintained by Shuozhi Xu , Kevin Chu , and Alex Selimov . Kevin and Alex are current Ph.D. students, while Shuozhi is a former Ph.D. student and Postdoctoral Fellow with Prof. David L. McDowell at the Georgia Institute of Technology . The PyCAC interface is open-source and the CAC simulator code is available upon request. For access, please email Prof. David L. McDowell .","title":"PyCAC User's Manual"},{"location":"#gui-source-code","text":"PyPi (Recommended): Use Python pip to seamlessly install the PyCAC GUI. GitHub : Please navigate to the gui/ folder in the repository and follow the instructions there.","title":"GUI source code"},{"location":"chapter-1/","text":"The concurrent atomistic-continuum (CAC) method is a partitioned-domain multiscale modeling technique that is applicable to nano/micro-scale thermo/mechanical problems in a wide range of monatomic and polyatomic crystalline materials. A CAC simulation model, in general, partitions the simulation cell into two domains: a coarse-grained domain and an atomistic domain. Distinct from most concurrent multiscale methods in the literature, CAC employs a unified atomistic-continuum integral formulation with elements that have discontinuities between them; also, the underlying interatomic potential is the only constitutive relation in the system. As such, CAC admits propagation of displacement discontinuities (dislocations and associated intrinsic stacking faults) through a lattice in both atomistic and coarse-grained domains, as shown in the figure below. Figure 1. A 2-D CAC simulation domain consisting of an atomistic domain (right) and a coarse-grained domain (left) ( Xu et al. ). The atomistic domain is composed of atoms (black circles), which follow the same governing equations in the atomistic simulation. The coarse-grained domain consists of discontinuous elements of varying size, each of which contains a large number of underlying atoms with the nodes (red circles) as the only degrees of freedom. Only the force/energy on integration points (green circles) and nodes are calculated. In (a), an edge dislocation (red $$\\perp$$) is located in the atomistic domain. Upon applying a shear stress on the simulation cell, the dislocation migrates into the coarse-grained domain in (b), where the Burgers vector spreads out between discontinuous elements. Figure 2. In 3-D, elements have faces on {111} planes and {110} planes in an FCC and a BCC lattice, resepectively. The positions of atoms within each element (open circles) are interpolated from the nodal positions (red filled circles). In a (big) nutshell, CAC describes certain lattice defects and their interactions using fully resolved atomistics; preserves the net Burgers vector and associated long range stress fields of curved, mixed character dislocations in a sufficiently large continuum domain in a fully 3D model; employs the same governing equations and interatomic potentials in both domains to avoid the usage of phenomenological parameters, essential remeshing operations and ad hoc procedures for passing dislocation segments between the atomistic and coarse-grained domains.","title":"Concurrent Atomistic Continuum (CAC) Method"},{"location":"chapter-1/acknowledgements-and-citations/","text":"The CAC simulator and analyser were written in Fortran by Shuozhi Xu ; the Python scripting interface was written by Alex Selimov and Kevin Chu ; the code in its present form is a culmination of developments over the last decades . The PyCAC code development was sponsored by National Science Foundation Georgia Institute of Technology, CMMI-1232878 University of Florida, CMMI-1233113 Iowa State University, CMMI-1536925 Department of Energy, Office of Basic Energy Sciences University of Florida, DE-SC0006539 Institute for Materials, Georgia Institute of Technology If you use PyCAC results in your published work, please cite these papers Shuozhi Xu, Thomas G. Payne, Hao Chen, Yongchao Liu, Liming Xiong, Youping Chen, David L. McDowell. PyCAC: The concurrent atomistic-continuum simulation environment , J. Mater. Res. 33 (2018) 857-871 Shuozhi Xu, Rui Che, Liming Xiong, Youping Chen, David L. McDowell. A quasistatic implementation of the concurrent atomistic-continuum method for FCC crystals , Int. J. Plast. 72 2015 2015 91\u2013126 Liming Xiong, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulation of dislocations , J. Mech. Phys. Solids 59 2011 2011 160-177 Youping Chen. Reformulation of microscopic balance equations for multiscale materials modeling , J. Chem. Phys. 130 (2009) 134706 as well as the website www.pycac.org , i.e., @article{xu_pycac_2018, title = {Py{CAC}: {The} concurrent atomistic-continuum simulation environment}, volume = {33}, issn = {0884-2914, 2044-5326}, doi = {10.1557/jmr.2018.8}, abstract = {We present a ...}, journal = {J. Mater. Res.}, author = {Xu, Shuozhi and Payne, Thomas G. and Chen, Hao and Liu, Yongchao and Xiong, Liming and Chen, Youping and McDowell, David L.}, month = apr, year = {2018}, pages = {857--871}} @article{xu_quasistatic_2015, title = {A quasistatic implementation of the concurrent atomistic-continuum method for {FCC} crystals}, volume = {72}, issn = {0749-6419}, doi = {10.1016/j.ijplas.2015.05.007}, abstract = {In recent years, ...}, journal = {Int. J. Plast.}, author = {Xu, Shuozhi and Che, Rui and Xiong, Liming and Chen, Youping and McDowell, David L.}, month = sep, year = {2015}, pages = {91--126}} @article{xiong_coarse-grained_2011, title = {Coarse-grained atomistic simulation of dislocations}, volume = {59}, issn = {0022-5096}, doi = {10.1016/j.jmps.2010.11.005}, abstract = {This paper presents ...}, number = {2}, journal = {J. Mech. Phys. Solids}, author = {Xiong, Liming and Tucker, Garritt and McDowell, David L. and Chen, Youping}, month = feb, year = {2011}, pages = {160--177}} @article{chen_reformulation_2009, title = {Reformulation of microscopic balance equations for multiscale materials modeling}, volume = {130}, issn = {00219606}, doi = {10.1063/1.3103887}, abstract = {In this paper ...}, number = {13}, journal = {J. Chem. Phys.}, author = {Chen, Youping}, month = apr, year = {2009}, pages = {134706}} @misc{xu_pycac-manual_2018, title = {Py{CAC} {User}'s {Manual}}, howpublished = {\\url{http://www.pycac.org/}}, author = {Xu, Shuozhi and Chu, Kevin}, month = aug, year = {2017}, note = {Accessed: \\today}}","title":"Acknowledgements and citations"},{"location":"chapter-1/compilation-and-execution/","text":"Please note that these instructions are for compilation and direct execution of the CAC simulator. To run CAC simulations using the GUI, please see the section titled: Graphical user interface MPI The PyCAC code is fully parallelized with Message Passing Interface (MPI). Some functions in MPI-3 standard are employed. It works with Open MPI version 2.1, Intel MPI version 5.1, MPICH version 3.3, and MVAPICH2 version 2.3. Fortran compiler Some intrinsic functions in Fortran 2008 is employed in the code, so compilers that fully support Fortran 2008 are preferred. For example, GNU Fortran version 7.0 and Intel Fortran version 17.0 work with the PyCAC code. To compile the code, simply run the install.sh file in the PyCAC code package, i.e., ./install.sh Note that the compilation process has not been tested on Microsoft Windows . On macOS , a message /opt/local/bin/ranlib: file: libcac.a(constant_para_module.o) has no symbols may occur. The users are suggested to compile and run the PyCAC code on Linux , which dominates the high performance computing systems . Compilation Module In compilation, the first step is to create a static library libcac.a from the 56 module files *_module.f90 in the module directory. There are five types of module files: *_comm_module.f90 There is only one *_comm_module.f90 file: precision_comm_module.f90 . It controls the precision of the integer and real numbers. *_para_module.f90 There are 25 *_para_module.f90 files. They define single value variables that may be used globally. *_array_module.f90 There are 24 *_array_module.f90 files. They define arrays that may be used globally. With a few exceptions, the *_para_module.f90 and *_array_module.f90 files come in pairs. *_function_module.f90 There are 5 *_function_module.f90 files. They define interatomic potential formulations, arithmetic/linear algebra calculations, unit conversion, etc. *_tab_module.f90 There is only one *_tab_module.f90 file: eam_tab_module.f90 . It contains algorithms that extract the EAM potential-based values from numerical tables . Note that these module files should be compiled in this order (see that the install.sh file) in creating the static library libcac.a . Otherwise, an error may occur. Subroutine Then, an executable, named CAC , is compiled using one main program ( main.f90 ) plus 175 subroutines ( *.f90 ) in the src directory and linked with the static library libcac.a . Execution In execution, the executable CAC , the input file cac.in , and the potential files are moved into the same directory. It follows that mpirun -np num_of_proc ./CAC < cac.in where positive integer num_of_proc is the number of processors to be used. As an example, see the run.sh file in the PyCAC code package.","title":"Compilation and execution"},{"location":"chapter-1/compilation-and-execution/#mpi","text":"The PyCAC code is fully parallelized with Message Passing Interface (MPI). Some functions in MPI-3 standard are employed. It works with Open MPI version 2.1, Intel MPI version 5.1, MPICH version 3.3, and MVAPICH2 version 2.3.","title":"MPI"},{"location":"chapter-1/compilation-and-execution/#fortran-compiler","text":"Some intrinsic functions in Fortran 2008 is employed in the code, so compilers that fully support Fortran 2008 are preferred. For example, GNU Fortran version 7.0 and Intel Fortran version 17.0 work with the PyCAC code. To compile the code, simply run the install.sh file in the PyCAC code package, i.e., ./install.sh Note that the compilation process has not been tested on Microsoft Windows . On macOS , a message /opt/local/bin/ranlib: file: libcac.a(constant_para_module.o) has no symbols may occur. The users are suggested to compile and run the PyCAC code on Linux , which dominates the high performance computing systems .","title":"Fortran compiler"},{"location":"chapter-1/compilation-and-execution/#compilation","text":"","title":"Compilation"},{"location":"chapter-1/compilation-and-execution/#module","text":"In compilation, the first step is to create a static library libcac.a from the 56 module files *_module.f90 in the module directory. There are five types of module files: *_comm_module.f90 There is only one *_comm_module.f90 file: precision_comm_module.f90 . It controls the precision of the integer and real numbers. *_para_module.f90 There are 25 *_para_module.f90 files. They define single value variables that may be used globally. *_array_module.f90 There are 24 *_array_module.f90 files. They define arrays that may be used globally. With a few exceptions, the *_para_module.f90 and *_array_module.f90 files come in pairs. *_function_module.f90 There are 5 *_function_module.f90 files. They define interatomic potential formulations, arithmetic/linear algebra calculations, unit conversion, etc. *_tab_module.f90 There is only one *_tab_module.f90 file: eam_tab_module.f90 . It contains algorithms that extract the EAM potential-based values from numerical tables . Note that these module files should be compiled in this order (see that the install.sh file) in creating the static library libcac.a . Otherwise, an error may occur.","title":"Module"},{"location":"chapter-1/compilation-and-execution/#subroutine","text":"Then, an executable, named CAC , is compiled using one main program ( main.f90 ) plus 175 subroutines ( *.f90 ) in the src directory and linked with the static library libcac.a .","title":"Subroutine"},{"location":"chapter-1/compilation-and-execution/#execution","text":"In execution, the executable CAC , the input file cac.in , and the potential files are moved into the same directory. It follows that mpirun -np num_of_proc ./CAC < cac.in where positive integer num_of_proc is the number of processors to be used. As an example, see the run.sh file in the PyCAC code package.","title":"Execution"},{"location":"chapter-1/publications/","text":"Book chapters Shuozhi Xu, Ji Rigelesaiyin, Liming Xiong, Youping Chen, David L. McDowell. Generalized continua concepts in coarse-graining atomistic simulations , in Generalized Models and Non-Classical Approaches in Complex Materials 2 (ed: Holm Altenbach, Jo\u00ebl Pouget, Martine Rousseau, Bernard Collet, Thomas Michelitsch), Switzerland: Springer International Publishing, 2018 Adrian Diaz, David McDowell, Youping Chen. The limitations and successes of concurrent dynamic multiscale modeling methods at the mesoscale , in Generalized Models and Non-Classical Approaches in Complex Materials 2 (ed: Holm Altenbach, Jo\u00ebl Pouget, Martine Rousseau, Bernard Collet, Thomas Michelitsch), Switzerland: Springer International Publishing, 2018 Shengfeng Yang, Youping Chen. Concurrent atomistic-continuum simulation of defects in polyatomic ionic materials , in Multiscale Materials Modeling for Nanomechanics ed: Christopher R. Weinberger, Garritt J. Tucker ed: Christopher R. Weinberger, Garritt J. Tucker , Switzerland: Springer International Publishing, 2016 Liming Xiong, Qian Deng, Youping Chen. Coarse-grained atomistic simulations of dislocations and fracture in metallic materials , in Handbook of Micromechanics and Nanomechanics (ed: Shaofan Li, Xin-Lin Gao), Singapore: Pan Stanford Publishing, 2013 Youping Chen, James D. Lee, Yajie Lei, Liming Xiong. A multiscale field theory: Nano/micro materials , in Multiscaling in Molecular and Continuum Mechanics: Interaction of Time and Size from Macro to Nano (ed: G. C. Sih), Netherlands: Springer, 2007 Dissertations and theses Xiang Chen. A concurrent atomistic-continuum study of phonon transport in crystalline materials with microstructures , Ph.D. Dissertation , University of Florida, 2016 Shuozhi Xu. The concurrent atomistic-continuum method: Advancements and applications in plasticity of face-centered cubic metals , Ph.D. Dissertation , Georgia Institute of Technology, 2016 Shengfeng Yang. A concurrent atomistic-continuum method for simulating defects in ionic materials , Ph.D. Dissertation , University of Florida, 2014 Qian Deng. Coarse-graining atomistic dynamics of fracture by finite element method: Formulation, parallelization and applications , Ph.D. Dissertation , University of Florida, 2011 Liming Xiong. A concurrent atomistic-continuum methodology and its applications , Ph.D. Dissertation , University of Florida, 2011 Peer-reviewed journal articles on CAC simulations (by acceptance date) Shuozhi Xu, Lauren Smith, Jaber R. Mianroodi, Abigail Hunter, Bob Svendsen, Irene J. Beyerlein. A comparison of different continuum approaches in modeling mixed-type dislocations in Al , Modelling Simul. Mater. Sci. Eng. 27 (2019) 074004 Shuozhi Xu David L. McDowell, Irene J. Beyerlein. Sequential obstacle interactions with dislocations in a planar array , Acta. Mater. 174 (2019) 160-172 Yang Li, Zhaochuan Fan, Weixuan Li, David L. McDowell, Youping Chen. A multiscale study of misfit dislocations in PbTe/PbSe(001) heteroepitaxy , J. Mater. Res. 34 (2019) 2306-2314 Yang Li, Weixuan Li, Xiang Chen, Adrian Diaz, David L. McDowell, Youping Chen. Phonon spectrum and phonon focusing in coarse-grained atomistic simulations , Comput. Mater. Sci. 162 (2019) 21-32 Shuozhi Xu, Marat I. Latypov, Yanqing Su. Concurrent atomistic-continuum simulations of uniaxial compression of gold nano/submicropillars , Philos. Mag. Lett. 98 (2018) 173-182 Shuozhi Xu. Modelling plastic deformation of nano/submicron-sized tungsten pillars under compression: A coarse-grained atomistic approach , Int. J. Multiscale Comput. Eng. 16 (2018) 367-376 Shuozhi Xu, Thomas G. Payne, Hao Chen, Yongchao Liu, Liming Xiong, Youping Chen, David L. McDowell. PyCAC: The concurrent atomistic-continuum simulation environment , J. Mater. Res. 33 (2018) 857-871 Hao Chen, Shuozhi Xu, Weixuan Li, Ji Rigelesaiyin, Thanh Phan, Liming Xiong. A spatial decomposition parallel algorithm for a concurrent atomistic-continuum simulator and its preliminary applications , Comput. Mater. Sci. 144 (2018) 1-10 Xiang Chen, Adrian Diaz, Liming Xiong, David L. McDowell, Youping Chen. Passing waves from atomistic to continuum , J. Comput. Phys. 354 (2018) 393-402 Xiang Chen, Weixuan Li, Adrian Diaz, Yang Li, Youping Chen, David L. McDowell. Recent progress in the concurrent atomistic-continuum method and its application in phonon transport , MRS Comm. 7 (2017) 785-797 Xiang Chen, Weixuan Li, Liming Xiong, Yang Li, Shengfeng Yang, Zexi Zheng, David L. McDowell, Youping Chen. Ballistic-diffusive phonon heat transport across grain boundaries , Acta Mater. 136 (2017) 355-365 Xiang Chen, Liming Xiong, David L. McDowell, Youping Chen. Effects of phonons on mobility of dislocations and dislocation arrays , Scr. Mater. 137 (2017) 22-26 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Validation of the concurrent atomistic-continuum method on screw dislocation/stacking fault interactions , Crystals 7 (2017) 120 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Comparing EAM potentials to model slip transfer of sequential mixed character dislocations across two symmetric tilt grain boundaries in Ni , JOM 69 (2017) 814-821 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Shear stress- and line length-dependent screw dislocation cross-slip in FCC Ni , Acta Mater. 122 2017 2017 412-419 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. An analysis of key characteristics of the Frank-Read source process in FCC metals , J. Mech. Phys. Solids 96 2016 2016 460-476 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Edge dislocations bowing out from a row of collinear obstacles in Al , Scr. Mater. 123 2016 2016 135-139 Shuozhi Xu, Liming Xiong, Qian Deng, David L. McDowell. Mesh refinement schemes for the concurrent atomistic-continuum method , Int. J. Solids Struct. 90 2016 2016 144-152 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Sequential slip transfer of mixed character dislocations across \\Sigma 3 \\Sigma 3 <span><span class=\"MathJax_Preview\">\\Sigma 3</span><script type=\"math/tex\">\\Sigma 3 coherent twin boundary in FCC metals: A concurrent atomistic-continuum study , npj Comput. Mater. 2 2016 2016 15016 Liming Xiong, Ji Rigelesaiyin, Xiang Chen, Shuozhi Xu, David L. McDowell, Youping Chen. Coarse-grained elastodynamics of fast moving dislocations , Acta Mater. 104 2016 2016 143-155 Shengfeng Yang, Ning Zhang, Youping Chen. Concurrent atomistic-continuum simulation of polycrystalline strontium titanate , Philos. Mag. 95 2015 2015 2697-2716 Shuozhi Xu, Rui Che, Liming Xiong, Youping Chen, David L. McDowell. A quasistatic implementation of the concurrent atomistic-continuum method for FCC crystals , Int. J. Plast. 72 2015 2015 91\u2013126 Shengfeng Yang, Youping Chen. Concurrent atomistic and continuum simulation of bi-crystal strontium titanate with tilt grain boundary , Proc. R. Soc. A 471 2015 2015 20140758 Liming Xiong, Shuozhi Xu, David L. McDowell, Youping Chen. Concurrent atomistic-continuum simulations of dislocation-void interactions in fcc crystals , Int. J. Plast. 65 2015 2015 33-42 Liming Xiong, Xiang Chen, Ning Zhang, David L. McDowell, Youping Chen. Prediction of phonon properties of 1D polyatomic systems using concurrent atomistic-continuum simulation , Arch. Appl. Mech. 84 2014 2014 1665-1675 Liming Xiong, David L. McDowell, Youping Chen. Sub-THz Phonon drag on dislocations by coarse-grained atomistic simulations , Int. J. Plast. 55 2014 2014 268-278 Qian Deng, Youping Chen, A coarse-grained atomistic method for 3D dynamic fracture simulation , Int. J. Multiscale Comput. Eng. 11 2013 2013 227-237 Shengfeng Yang, Liming Xiong, Qian Deng, Youping Chen. Concurrent atomistic and continuum simulation of strontium titanate , Acta Mater. 61 2013 2013 89\u2013102 Liming Xiong, David L. McDowell, Youping Chen. Nucleation and growth of dislocation loops in Cu, Al and Si by a concurrent atomistic-continuum method , Scr. Mater. 67 2012 2012 633\u2013636 Liming Xiong, Qian Deng, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulations of dislocations in Al, Ni and Cu crystals , Int. J. Plast. 38 2012 2012 86\u2013101 Liming Xiong, Youping Chen. Coarse-grained atomistic modeling and simulation of inelastic material behavior , Acta Mech. Solida Sin. 25 (2012) 244-261 Liming Xiong, Qian Deng, Garritt Tucker, David L. McDowell, Youping Chen. A concurrent scheme for passing dislocations from atomistic to continuum domains , Acta Mater. 60 2012 2012 899-913 Liming Xiong, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulation of dislocations , J. Mech. Phys. Solids 59 2011 2011 160-177 Qian Deng, Liming Xiong, Youping Chen. Coarse-graining atomistic dynamics of brittle fracture by finite element method , Int. J. Plast. 26 2010 2010 1402-1414 Peer-reviewed journal articles on the theoretical foundations of CAC (by acceptance date): Youping Chen. The origin of the distinction between microscopic formulas for stress and Cauchy stress , Europhys. Lett. 116 (2016) 34003 Youping Chen and Adrian Diaz. Local momentum and heat fluxes in transient transport processes and inhomogeneous systems , Phys. Rev. E 94 (2016) 053309 Youping Chen, Jonathan Zimmerman, Anton Krivtsov, David L. McDowell. Assessment of atomistic coarse-graining methods , Int. J. Eng. Sci. 49 (2011) 1337-1349 Youping Chen. Reformulation of microscopic balance equations for multiscale materials modeling , J. Chem. Phys. 130 (2009) 134706 Youping Chen, James Lee, Liming Xiong. A generalized continuum theory and its relation to micromorphic theory , J. Eng. Mech. 135 (2009) 149-155 Youping Chen. Local stress and heat flux in atomistic systems involving three-body forces , J. Chem. Phys. 124 (2006) 054113 Youping Chen, James Lee. Conservation laws at nano/micro scales , J. Mech. Mater. Struct. 1 (2006) 681-704 Youping Chen, James Lee, Liming Xiong. Stresses and strains at nano/micro scales , J. Mech. Mater. Struct. 1 (2006) 705-723 Youping Chen, James Lee. Atomistic formulation of a multiscale theory for nano/micro physics , Philos. Mag. 85 (2005) 4095-4126 Youpig Chen, James D. Lee, Azim Eskandarian. Micropolar theory and its applications to mesoscopic and microscopic problems , Comput. Modeling Eng. Sci. 5 (2004) 35-43 Youpig Chen, James D. Lee, Azim Eskandarian, Atomistic counterpart of micromorphic theory , Acta Mech. 161 (2003) 81-102","title":"Publications"},{"location":"chapter-1/publications/#book-chapters","text":"Shuozhi Xu, Ji Rigelesaiyin, Liming Xiong, Youping Chen, David L. McDowell. Generalized continua concepts in coarse-graining atomistic simulations , in Generalized Models and Non-Classical Approaches in Complex Materials 2 (ed: Holm Altenbach, Jo\u00ebl Pouget, Martine Rousseau, Bernard Collet, Thomas Michelitsch), Switzerland: Springer International Publishing, 2018 Adrian Diaz, David McDowell, Youping Chen. The limitations and successes of concurrent dynamic multiscale modeling methods at the mesoscale , in Generalized Models and Non-Classical Approaches in Complex Materials 2 (ed: Holm Altenbach, Jo\u00ebl Pouget, Martine Rousseau, Bernard Collet, Thomas Michelitsch), Switzerland: Springer International Publishing, 2018 Shengfeng Yang, Youping Chen. Concurrent atomistic-continuum simulation of defects in polyatomic ionic materials , in Multiscale Materials Modeling for Nanomechanics ed: Christopher R. Weinberger, Garritt J. Tucker ed: Christopher R. Weinberger, Garritt J. Tucker , Switzerland: Springer International Publishing, 2016 Liming Xiong, Qian Deng, Youping Chen. Coarse-grained atomistic simulations of dislocations and fracture in metallic materials , in Handbook of Micromechanics and Nanomechanics (ed: Shaofan Li, Xin-Lin Gao), Singapore: Pan Stanford Publishing, 2013 Youping Chen, James D. Lee, Yajie Lei, Liming Xiong. A multiscale field theory: Nano/micro materials , in Multiscaling in Molecular and Continuum Mechanics: Interaction of Time and Size from Macro to Nano (ed: G. C. Sih), Netherlands: Springer, 2007","title":"Book chapters"},{"location":"chapter-1/publications/#dissertations-and-theses","text":"Xiang Chen. A concurrent atomistic-continuum study of phonon transport in crystalline materials with microstructures , Ph.D. Dissertation , University of Florida, 2016 Shuozhi Xu. The concurrent atomistic-continuum method: Advancements and applications in plasticity of face-centered cubic metals , Ph.D. Dissertation , Georgia Institute of Technology, 2016 Shengfeng Yang. A concurrent atomistic-continuum method for simulating defects in ionic materials , Ph.D. Dissertation , University of Florida, 2014 Qian Deng. Coarse-graining atomistic dynamics of fracture by finite element method: Formulation, parallelization and applications , Ph.D. Dissertation , University of Florida, 2011 Liming Xiong. A concurrent atomistic-continuum methodology and its applications , Ph.D. Dissertation , University of Florida, 2011","title":"Dissertations and theses"},{"location":"chapter-1/publications/#peer-reviewed-journal-articles-on-cac-simulations","text":"(by acceptance date) Shuozhi Xu, Lauren Smith, Jaber R. Mianroodi, Abigail Hunter, Bob Svendsen, Irene J. Beyerlein. A comparison of different continuum approaches in modeling mixed-type dislocations in Al , Modelling Simul. Mater. Sci. Eng. 27 (2019) 074004 Shuozhi Xu David L. McDowell, Irene J. Beyerlein. Sequential obstacle interactions with dislocations in a planar array , Acta. Mater. 174 (2019) 160-172 Yang Li, Zhaochuan Fan, Weixuan Li, David L. McDowell, Youping Chen. A multiscale study of misfit dislocations in PbTe/PbSe(001) heteroepitaxy , J. Mater. Res. 34 (2019) 2306-2314 Yang Li, Weixuan Li, Xiang Chen, Adrian Diaz, David L. McDowell, Youping Chen. Phonon spectrum and phonon focusing in coarse-grained atomistic simulations , Comput. Mater. Sci. 162 (2019) 21-32 Shuozhi Xu, Marat I. Latypov, Yanqing Su. Concurrent atomistic-continuum simulations of uniaxial compression of gold nano/submicropillars , Philos. Mag. Lett. 98 (2018) 173-182 Shuozhi Xu. Modelling plastic deformation of nano/submicron-sized tungsten pillars under compression: A coarse-grained atomistic approach , Int. J. Multiscale Comput. Eng. 16 (2018) 367-376 Shuozhi Xu, Thomas G. Payne, Hao Chen, Yongchao Liu, Liming Xiong, Youping Chen, David L. McDowell. PyCAC: The concurrent atomistic-continuum simulation environment , J. Mater. Res. 33 (2018) 857-871 Hao Chen, Shuozhi Xu, Weixuan Li, Ji Rigelesaiyin, Thanh Phan, Liming Xiong. A spatial decomposition parallel algorithm for a concurrent atomistic-continuum simulator and its preliminary applications , Comput. Mater. Sci. 144 (2018) 1-10 Xiang Chen, Adrian Diaz, Liming Xiong, David L. McDowell, Youping Chen. Passing waves from atomistic to continuum , J. Comput. Phys. 354 (2018) 393-402 Xiang Chen, Weixuan Li, Adrian Diaz, Yang Li, Youping Chen, David L. McDowell. Recent progress in the concurrent atomistic-continuum method and its application in phonon transport , MRS Comm. 7 (2017) 785-797 Xiang Chen, Weixuan Li, Liming Xiong, Yang Li, Shengfeng Yang, Zexi Zheng, David L. McDowell, Youping Chen. Ballistic-diffusive phonon heat transport across grain boundaries , Acta Mater. 136 (2017) 355-365 Xiang Chen, Liming Xiong, David L. McDowell, Youping Chen. Effects of phonons on mobility of dislocations and dislocation arrays , Scr. Mater. 137 (2017) 22-26 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Validation of the concurrent atomistic-continuum method on screw dislocation/stacking fault interactions , Crystals 7 (2017) 120 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Comparing EAM potentials to model slip transfer of sequential mixed character dislocations across two symmetric tilt grain boundaries in Ni , JOM 69 (2017) 814-821 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Shear stress- and line length-dependent screw dislocation cross-slip in FCC Ni , Acta Mater. 122 2017 2017 412-419 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. An analysis of key characteristics of the Frank-Read source process in FCC metals , J. Mech. Phys. Solids 96 2016 2016 460-476 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Edge dislocations bowing out from a row of collinear obstacles in Al , Scr. Mater. 123 2016 2016 135-139 Shuozhi Xu, Liming Xiong, Qian Deng, David L. McDowell. Mesh refinement schemes for the concurrent atomistic-continuum method , Int. J. Solids Struct. 90 2016 2016 144-152 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Sequential slip transfer of mixed character dislocations across \\Sigma 3 \\Sigma 3 <span><span class=\"MathJax_Preview\">\\Sigma 3</span><script type=\"math/tex\">\\Sigma 3 coherent twin boundary in FCC metals: A concurrent atomistic-continuum study , npj Comput. Mater. 2 2016 2016 15016 Liming Xiong, Ji Rigelesaiyin, Xiang Chen, Shuozhi Xu, David L. McDowell, Youping Chen. Coarse-grained elastodynamics of fast moving dislocations , Acta Mater. 104 2016 2016 143-155 Shengfeng Yang, Ning Zhang, Youping Chen. Concurrent atomistic-continuum simulation of polycrystalline strontium titanate , Philos. Mag. 95 2015 2015 2697-2716 Shuozhi Xu, Rui Che, Liming Xiong, Youping Chen, David L. McDowell. A quasistatic implementation of the concurrent atomistic-continuum method for FCC crystals , Int. J. Plast. 72 2015 2015 91\u2013126 Shengfeng Yang, Youping Chen. Concurrent atomistic and continuum simulation of bi-crystal strontium titanate with tilt grain boundary , Proc. R. Soc. A 471 2015 2015 20140758 Liming Xiong, Shuozhi Xu, David L. McDowell, Youping Chen. Concurrent atomistic-continuum simulations of dislocation-void interactions in fcc crystals , Int. J. Plast. 65 2015 2015 33-42 Liming Xiong, Xiang Chen, Ning Zhang, David L. McDowell, Youping Chen. Prediction of phonon properties of 1D polyatomic systems using concurrent atomistic-continuum simulation , Arch. Appl. Mech. 84 2014 2014 1665-1675 Liming Xiong, David L. McDowell, Youping Chen. Sub-THz Phonon drag on dislocations by coarse-grained atomistic simulations , Int. J. Plast. 55 2014 2014 268-278 Qian Deng, Youping Chen, A coarse-grained atomistic method for 3D dynamic fracture simulation , Int. J. Multiscale Comput. Eng. 11 2013 2013 227-237 Shengfeng Yang, Liming Xiong, Qian Deng, Youping Chen. Concurrent atomistic and continuum simulation of strontium titanate , Acta Mater. 61 2013 2013 89\u2013102 Liming Xiong, David L. McDowell, Youping Chen. Nucleation and growth of dislocation loops in Cu, Al and Si by a concurrent atomistic-continuum method , Scr. Mater. 67 2012 2012 633\u2013636 Liming Xiong, Qian Deng, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulations of dislocations in Al, Ni and Cu crystals , Int. J. Plast. 38 2012 2012 86\u2013101 Liming Xiong, Youping Chen. Coarse-grained atomistic modeling and simulation of inelastic material behavior , Acta Mech. Solida Sin. 25 (2012) 244-261 Liming Xiong, Qian Deng, Garritt Tucker, David L. McDowell, Youping Chen. A concurrent scheme for passing dislocations from atomistic to continuum domains , Acta Mater. 60 2012 2012 899-913 Liming Xiong, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulation of dislocations , J. Mech. Phys. Solids 59 2011 2011 160-177 Qian Deng, Liming Xiong, Youping Chen. Coarse-graining atomistic dynamics of brittle fracture by finite element method , Int. J. Plast. 26 2010 2010 1402-1414","title":"Peer-reviewed journal articles on CAC simulations"},{"location":"chapter-1/publications/#peer-reviewed-journal-articles-on-the-theoretical-foundations-of-cac","text":"(by acceptance date): Youping Chen. The origin of the distinction between microscopic formulas for stress and Cauchy stress , Europhys. Lett. 116 (2016) 34003 Youping Chen and Adrian Diaz. Local momentum and heat fluxes in transient transport processes and inhomogeneous systems , Phys. Rev. E 94 (2016) 053309 Youping Chen, Jonathan Zimmerman, Anton Krivtsov, David L. McDowell. Assessment of atomistic coarse-graining methods , Int. J. Eng. Sci. 49 (2011) 1337-1349 Youping Chen. Reformulation of microscopic balance equations for multiscale materials modeling , J. Chem. Phys. 130 (2009) 134706 Youping Chen, James Lee, Liming Xiong. A generalized continuum theory and its relation to micromorphic theory , J. Eng. Mech. 135 (2009) 149-155 Youping Chen. Local stress and heat flux in atomistic systems involving three-body forces , J. Chem. Phys. 124 (2006) 054113 Youping Chen, James Lee. Conservation laws at nano/micro scales , J. Mech. Mater. Struct. 1 (2006) 681-704 Youping Chen, James Lee, Liming Xiong. Stresses and strains at nano/micro scales , J. Mech. Mater. Struct. 1 (2006) 705-723 Youping Chen, James Lee. Atomistic formulation of a multiscale theory for nano/micro physics , Philos. Mag. 85 (2005) 4095-4126 Youpig Chen, James D. Lee, Azim Eskandarian. Micropolar theory and its applications to mesoscopic and microscopic problems , Comput. Modeling Eng. Sci. 5 (2004) 35-43 Youpig Chen, James D. Lee, Azim Eskandarian, Atomistic counterpart of micromorphic theory , Acta Mech. 161 (2003) 81-102","title":"Peer-reviewed journal articles on the theoretical foundations of CAC"},{"location":"chapter-1/pycac-features/","text":"Features The PyCAC code can simulate monatomic pure face-centered cubic (FCC) or pure body-centered cubic (BCC) metals using the Lennard-Jones (LJ) or the embedded-atom method (EAM) potentials in a constant temperature field. In the coarse-grained domain, 3D trilinear rhombohedral elements are employed to accommodate dislocations in 9 out of 12 sets of \\{111\\}\\left<110\\right> \\{111\\}\\left<110\\right> slip systems in an FCC lattice, as well as 6 out of 12 sets of \\{110\\}\\left<111\\right> \\{110\\}\\left<111\\right> slip systems in a BCC lattice. Non-features While the CAC method is applicable to thermo/mechanical problems in almost all crystalline materials, current version of the PyCAC code has not yet been extended to simulate: dislocations in 12 sets of \\{112\\}\\left<111\\right> \\{112\\}\\left<111\\right> -type and 24 sets of \\{123\\}\\left<111\\right> \\{123\\}\\left<111\\right> -type slip systems in a BCC lattice; crystal structures other than FCC and BCC, e.g., simple cubic, diamond cubic, hexagonal close-packed; interatomic potentials other than LJ and EAM, e.g., Stillinger-Weber potential, Tersoff potential, or modified EAM (MEAM) potential; 1D or 2D materials that require 1D or 2D elements, respectively, as well as materials requiring 3D elements different from the rhombohedral ones; multicomponent, multi-constituent, multiphase, or polyatomic crystalline materials, e.g., alloys, intermetallics, composite materials, ceramic, mineral; materials in a non-constant temperature field. Moreover, the adaptive mesh refinement scheme is not implemented in the current PyCAC code.","title":"PyCAC features and non-features"},{"location":"chapter-1/pycac-features/#features","text":"The PyCAC code can simulate monatomic pure face-centered cubic (FCC) or pure body-centered cubic (BCC) metals using the Lennard-Jones (LJ) or the embedded-atom method (EAM) potentials in a constant temperature field. In the coarse-grained domain, 3D trilinear rhombohedral elements are employed to accommodate dislocations in 9 out of 12 sets of \\{111\\}\\left<110\\right> \\{111\\}\\left<110\\right> slip systems in an FCC lattice, as well as 6 out of 12 sets of \\{110\\}\\left<111\\right> \\{110\\}\\left<111\\right> slip systems in a BCC lattice.","title":"Features"},{"location":"chapter-1/pycac-features/#non-features","text":"While the CAC method is applicable to thermo/mechanical problems in almost all crystalline materials, current version of the PyCAC code has not yet been extended to simulate: dislocations in 12 sets of \\{112\\}\\left<111\\right> \\{112\\}\\left<111\\right> -type and 24 sets of \\{123\\}\\left<111\\right> \\{123\\}\\left<111\\right> -type slip systems in a BCC lattice; crystal structures other than FCC and BCC, e.g., simple cubic, diamond cubic, hexagonal close-packed; interatomic potentials other than LJ and EAM, e.g., Stillinger-Weber potential, Tersoff potential, or modified EAM (MEAM) potential; 1D or 2D materials that require 1D or 2D elements, respectively, as well as materials requiring 3D elements different from the rhombohedral ones; multicomponent, multi-constituent, multiphase, or polyatomic crystalline materials, e.g., alloys, intermetallics, composite materials, ceramic, mineral; materials in a non-constant temperature field. Moreover, the adaptive mesh refinement scheme is not implemented in the current PyCAC code.","title":"Non-features"},{"location":"chapter-2/","text":"Background This chapter, written by Prof. Youping Chen , presents the atomistic field theory and a brief history of CAC.","title":"Introduction"},{"location":"chapter-2/#background","text":"This chapter, written by Prof. Youping Chen , presents the atomistic field theory and a brief history of CAC.","title":"Background"},{"location":"chapter-2/atomistic-field-theory/","text":"The theoretical foundation of the CAC method is the atomistic field theory (AFT) [1,2], which is an extension of the Irving Kirkwood (IK)'s non-equilibrium statistical mechanical formulation of \" the hydrodynamics equations for a single component, single phase system \" [3] to a two-level structural description of crystalline materials. It employs the two-level structural description of all crystals in solid state physics, i.e., the well known equation of \"crystal structure = lattice + basis\" [4]. As a result of the bottom-up atomistic formulation, all the essential atomistic information of the material, including the crystal structure and the interaction between atoms, are built in the formulation. A schematic of micromorphic theory and AFT is given below. Macro- and micro-motions of a material particle P in (a) micromorphic theory and (b) AFT. Left in (a) and (b) is the reference state at time 0 while right is the deformation state at time {t} {t} . \\mathbf{X} \\mathbf{X} and \\mathbf{x} \\mathbf{x} are the positions of the mass center of the unit cell, {\\Xi} {\\Xi} and {xi} {xi} are internal positions, \\mathbf{Y} \\mathbf{Y} and \\mathbf{y}^\\alpha \\mathbf{y}^\\alpha are positions of atom \\alpha \\alpha with respect to \\mathbf{X} \\mathbf{X} and \\mathbf{x} \\mathbf{x} , respectively, N_a N_a is the number of atoms in a unit cell. The governing equations for conservative systems The result is a concurrent atomistic-continuum representation of balance laws for both atomistic and continuum coarse-grained domains in the following form [1,2]: \\frac{\\mathrm{d} \\rho^\\alpha}{\\mathrm{d} t} + \\rho^\\alpha (\\nabla_\\mathbf{x} \\cdot \\mathbf{v} + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\Delta \\mathbf{v}^\\alpha) = 0 \\frac{\\mathrm{d} \\rho^\\alpha}{\\mathrm{d} t} + \\rho^\\alpha (\\nabla_\\mathbf{x} \\cdot \\mathbf{v} + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\Delta \\mathbf{v}^\\alpha) = 0 \\rho^\\alpha \\frac{\\mathrm{d}}{\\mathrm{d} t} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) = \\nabla_\\mathbf{x} \\cdot \\mathbf{t}^\\alpha + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\mathbf{\\tau}^\\alpha + \\mathbf{f}_\\mathrm{ext}^\\alpha \\rho^\\alpha \\frac{\\mathrm{d}}{\\mathrm{d} t} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) = \\nabla_\\mathbf{x} \\cdot \\mathbf{t}^\\alpha + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\mathbf{\\tau}^\\alpha + \\mathbf{f}_\\mathrm{ext}^\\alpha \\rho^\\alpha \\frac{\\mathrm{d} e^\\alpha}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{q}^\\alpha + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\mathbf{j}^\\alpha + \\mathbf{t}^\\alpha : \\nabla_\\mathbf{x} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) + \\mathbf{\\tau}^\\alpha : \\nabla_{\\mathbf{y}^\\alpha} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) \\rho^\\alpha \\frac{\\mathrm{d} e^\\alpha}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{q}^\\alpha + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\mathbf{j}^\\alpha + \\mathbf{t}^\\alpha : \\nabla_\\mathbf{x} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) + \\mathbf{\\tau}^\\alpha : \\nabla_{\\mathbf{y}^\\alpha} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) where \\mathbf{x} \\mathbf{x} is the physical space coordinate; \\mathbf{y}^\\alpha (\\alpha = 1, 2, \\ldots, N_a \\mathbf{y}^\\alpha (\\alpha = 1, 2, \\ldots, N_a with N_a N_a being the total number of atoms in a unit cell) are the internal variables describing the position of atom \\alpha \\alpha relative to the mass center of the lattice cell located at \\mathbf{x} \\mathbf{x} ; \\rho^\\alpha \\rho^\\alpha , \\rho^\\alpha(\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) \\rho^\\alpha(\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) , and \\rho^\\alpha e^\\alpha \\rho^\\alpha e^\\alpha are the local densities of mass, linear momentum and total energy, respectively; \\mathbf{v} + \\Delta \\mathbf{v}^\\alpha \\mathbf{v} + \\Delta \\mathbf{v}^\\alpha is the atomic-level velocity and \\mathbf{v} \\mathbf{v} is the velocity field; \\mathbf{f}_\\mathrm{ext}^\\alpha \\mathbf{f}_\\mathrm{ext}^\\alpha is the external force field; \\mathbf{t}^\\alpha \\mathbf{t}^\\alpha and \\mathbf{q}^\\alpha \\mathbf{q}^\\alpha are the stress and heat flux due to the homogeneous deformation of lattice, respectively; \\mathbf{\\tau}^\\alpha \\mathbf{\\tau}^\\alpha and \\mathbf{j}^\\alpha \\mathbf{j}^\\alpha are the stress and heat flux due to the reorganizations of atoms within the lattice cells, respectively. For monatomic crystals, which PyCAC can simulate , \\mathbf{y}^\\alpha = \\mathbf{0} \\mathbf{y}^\\alpha = \\mathbf{0} and N_a = 1 N_a = 1 ; the governing equations reduce to \\frac{\\mathrm{d} \\rho}{\\mathrm{d} t} + \\rho \\nabla_\\mathbf{x} \\cdot \\mathbf{v} = 0 \\frac{\\mathrm{d} \\rho}{\\mathrm{d} t} + \\rho \\nabla_\\mathbf{x} \\cdot \\mathbf{v} = 0 \\rho \\frac{\\mathrm{d} \\mathbf{v}}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{t} + \\mathbf{f}_\\mathrm{ext} \\rho \\frac{\\mathrm{d} \\mathbf{v}}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{t} + \\mathbf{f}_\\mathrm{ext} \\rho \\frac{\\mathrm{d} e}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{q} + \\mathbf{t} : \\nabla_\\mathbf{x} \\mathbf{v} \\rho \\frac{\\mathrm{d} e}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{q} + \\mathbf{t} : \\nabla_\\mathbf{x} \\mathbf{v} For conservative systems, i.e., a system in the absence of an internal source that generates or dissipates energy, the AFT energy equation is equivalent to the AFT linear momentum equation. Because of its current features , only the first two governing equations are explicitly implemented into PyCAC. Employing the classical definition of kinetic temperature, which is proportional to the kinetic part of the atomistic stress, the linear momentum equations can be expressed in a form that involves the internal force density \\mathbf{f}_\\mathrm{int}^\\alpha \\mathbf{f}_\\mathrm{int}^\\alpha and temperature T T [5-7], \\rho^\\alpha \\ddot{\\mathbf{u}}^\\alpha + \\frac{\\gamma^\\alpha k_\\mathrm{B}}{\\Delta V} \\nabla_\\mathbf{x} T = \\mathbf{f}_\\mathrm{int}^\\alpha + \\mathbf{f}_\\mathrm{ext}^\\alpha, \\quad \\alpha = 1, 2, \\ldots, N_a \\rho^\\alpha \\ddot{\\mathbf{u}}^\\alpha + \\frac{\\gamma^\\alpha k_\\mathrm{B}}{\\Delta V} \\nabla_\\mathbf{x} T = \\mathbf{f}_\\mathrm{int}^\\alpha + \\mathbf{f}_\\mathrm{ext}^\\alpha, \\quad \\alpha = 1, 2, \\ldots, N_a where \\mathbf{u}^\\alpha \\mathbf{u}^\\alpha is the displacement of the \\alpha \\alpha th atom at point \\mathbf{x} \\mathbf{x} ; the superposed dots denote the material time derivative; \\Delta V \\Delta V is the volume of the finite-sized material particle (the primitive unit cell for crystalline materials) at \\mathbf{x} \\mathbf{x} ; k_\\mathrm{B} k_\\mathrm{B} is the Boltzmann constant; \\gamma^\\alpha = \\rho^\\alpha / \\sum^{N_a}_{\\alpha = 1} \\rho^\\alpha \\gamma^\\alpha = \\rho^\\alpha / \\sum^{N_a}_{\\alpha = 1} \\rho^\\alpha , and \\mathbf{f}_\\mathrm{int}^\\alpha \\mathbf{f}_\\mathrm{int}^\\alpha is the internal force density and is a nonlinear nonlocal function of relative atomic displacements. For systems with a constant temperature field or a constant temperature gradient, the temperature term has the effect of a surface traction on the boundary or a body force in the interior of the material [6]. Denoting the temperature term in the above equation as \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) and the finite element shape function as \\Phi_\\xi(\\mathbf{x}) \\Phi_\\xi(\\mathbf{x}) , the Galerkin weak form of the above equation can be written as \\int_{\\Omega(\\mathbf{x})} \\Phi_\\xi(\\mathbf{x}) (\\rho^\\alpha \\ddot{\\mathbf{u}}^\\alpha(\\mathbf{x}) + \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) - \\mathbf{f}_\\mathrm{int}^\\alpha(\\mathbf{x}) - \\mathbf{f}_\\mathrm{ext}^\\alpha(\\mathbf{x})) \\mathrm{d} \\mathbf{x} = 0 \\int_{\\Omega(\\mathbf{x})} \\Phi_\\xi(\\mathbf{x}) (\\rho^\\alpha \\ddot{\\mathbf{u}}^\\alpha(\\mathbf{x}) + \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) - \\mathbf{f}_\\mathrm{int}^\\alpha(\\mathbf{x}) - \\mathbf{f}_\\mathrm{ext}^\\alpha(\\mathbf{x})) \\mathrm{d} \\mathbf{x} = 0 where \\Omega(\\mathbf{x}) \\Omega(\\mathbf{x}) is the simulation domain; the integrals can be evaluated using numerical integration methods such as Gaussian quadrature, leading to a set of discretized governing equations with the finite element nodal displacements as the unknowns to be solved. Note that in PyCAC, the \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) term has not yet been implemented as (i) the effect on mechanical properties in a constant temperature field is small and (ii) work is underway to compare different descriptions of temperature in the coarse-grained domain. The accuracy, efficiency, and stability of the CAC simulator are then determined by the two approximations: the shape function and the numerical integration. Simulation results can be displayed in terms of finite elements, which can also be mapped back to atomic positions and be used to plot the atomic trajectories. With the only constitutive relation being the nonlocal atomic force-displacement relation, continuity between elements in the usual finite element method is not required. Consequently, nucleation and propagation of dislocations and/or cracks can be simulated via sliding and separation between finite elements. AFT and the equilibrium ensembles The local densities defined in the Irving and Kirkwood formulations are ensemble averaged point functions. The ensemble averaging was described by Irving and Kirkwood as \" repeating the observations many times \" [3]. In the early version of the AFT formulation [1], the local densities were also defined as ensemble averages and hence the governing equations were written in terms of ensemble-averaged local densities. In the later version of the AFT formulation [2], the local densities are instantaneous quantities, according to argument by Evan and Morris [8], who wrote \" \\ldots \\ldots the reason for considering instantaneous expressions is two-fold. The fluxes are based upon conservation laws and these laws are valid instantaneously for every member of the ensemble. They do not require ensemble averaging to be true. Secondly, most computer simulation involves calculating system properties from a single system trajectory. Ensemble averaging is almost never used because it is relatively expensive in computer time \". Note that the AFT local densities and governing equations were derived as an extension of the Irving and Kirkwood's formulation of the equations of hydrodynamics. Consequently, they differ from other statistical mechanical formulations that follow the Gibbs' equilibrium statistical theory of ensembles. Popular equilibrium ensembles include (i) the microcanonical ensemble, which describes a systems isolated from its surroundings and governed by Hamilton's equations of motion (NVE), (ii) the canonical ensemble, which describe a system in constant contact with a heat bath of constant temperature (NVT), and (iii) the isothermal-isobaric ensembles, which describes systems in contact with a thermostat at temperature T T and a barostat at pressure P P (NPT) [9]. These ensembles, known as equilibrium ensembles and allowing a wide variety of thermodynamic and structural properties of systems to be computed, can be realized in dynamic CAC , in which a finite temperature can be achieved via lattice dynamic-based shape functions [10]. Alternatively, in the current code, a Langevin thermostat is realized while a constant pressure/stress is maintained via a Berendsen barostat. References Youping Chen, James Lee. Atomistic formulation of a multiscale theory for nano/micro physics , Philos. Mag. 85 (2005) 4095-4126 Youping Chen. Reformulation of microscopic balance equations for multiscale materials modeling , J. Chem. Phys. 130 (2009) 134706 J.H. Irving, Jhon G. Kirkwood. The statistical mechanical theory of transport processes. IV. The equations of hydrodynamics , J. Chem. Phys. 18 (1950) 817-829 Charles Kittel. Introduction to Solid State Physics , 1956: John Wiley & Sons, Inc Qian Deng, Coarse-graining atomistic dynamics of fracture by finite element method: Formulation, parallelization and applications , Ph.D. Dissertation , University of Florida, 2011 Liming Xiong, Youping Chen. Coarse-grained simulations of single-crystal silicon . Modelling Simul. Mater. Sci. Eng. 17 (2009) 035002 Liming Xiong, Youping Chen, James D. Lee. Atomistic simulation of mechanical properties of diamond and silicon carbide by a field theory , Modelling Simul. Mater. Sci. Eng. 15 (2007) 535-551 Denis J. Evans, Gary P. Morriss. Statistical Mechanics of Nonequilibrium Liquids , 2008: Cambridge University Press Mark E. Tuckerman. Statistical Mechanics: Theory and Molecular Simulation , 2010: Oxford University Press Xiang Chen, Adrian Diaz, Liming Xiong, David L. McDowell, Youping Chen. Passing waves from atomistic to continuum , J. Comput. Phys. 354 (2018) 393-402","title":"Atomistic field theory"},{"location":"chapter-2/atomistic-field-theory/#the-governing-equations-for-conservative-systems","text":"The result is a concurrent atomistic-continuum representation of balance laws for both atomistic and continuum coarse-grained domains in the following form [1,2]: \\frac{\\mathrm{d} \\rho^\\alpha}{\\mathrm{d} t} + \\rho^\\alpha (\\nabla_\\mathbf{x} \\cdot \\mathbf{v} + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\Delta \\mathbf{v}^\\alpha) = 0 \\frac{\\mathrm{d} \\rho^\\alpha}{\\mathrm{d} t} + \\rho^\\alpha (\\nabla_\\mathbf{x} \\cdot \\mathbf{v} + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\Delta \\mathbf{v}^\\alpha) = 0 \\rho^\\alpha \\frac{\\mathrm{d}}{\\mathrm{d} t} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) = \\nabla_\\mathbf{x} \\cdot \\mathbf{t}^\\alpha + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\mathbf{\\tau}^\\alpha + \\mathbf{f}_\\mathrm{ext}^\\alpha \\rho^\\alpha \\frac{\\mathrm{d}}{\\mathrm{d} t} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) = \\nabla_\\mathbf{x} \\cdot \\mathbf{t}^\\alpha + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\mathbf{\\tau}^\\alpha + \\mathbf{f}_\\mathrm{ext}^\\alpha \\rho^\\alpha \\frac{\\mathrm{d} e^\\alpha}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{q}^\\alpha + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\mathbf{j}^\\alpha + \\mathbf{t}^\\alpha : \\nabla_\\mathbf{x} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) + \\mathbf{\\tau}^\\alpha : \\nabla_{\\mathbf{y}^\\alpha} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) \\rho^\\alpha \\frac{\\mathrm{d} e^\\alpha}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{q}^\\alpha + \\nabla_{\\mathbf{y}^\\alpha} \\cdot \\mathbf{j}^\\alpha + \\mathbf{t}^\\alpha : \\nabla_\\mathbf{x} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) + \\mathbf{\\tau}^\\alpha : \\nabla_{\\mathbf{y}^\\alpha} (\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) where \\mathbf{x} \\mathbf{x} is the physical space coordinate; \\mathbf{y}^\\alpha (\\alpha = 1, 2, \\ldots, N_a \\mathbf{y}^\\alpha (\\alpha = 1, 2, \\ldots, N_a with N_a N_a being the total number of atoms in a unit cell) are the internal variables describing the position of atom \\alpha \\alpha relative to the mass center of the lattice cell located at \\mathbf{x} \\mathbf{x} ; \\rho^\\alpha \\rho^\\alpha , \\rho^\\alpha(\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) \\rho^\\alpha(\\mathbf{v} + \\Delta \\mathbf{v}^\\alpha) , and \\rho^\\alpha e^\\alpha \\rho^\\alpha e^\\alpha are the local densities of mass, linear momentum and total energy, respectively; \\mathbf{v} + \\Delta \\mathbf{v}^\\alpha \\mathbf{v} + \\Delta \\mathbf{v}^\\alpha is the atomic-level velocity and \\mathbf{v} \\mathbf{v} is the velocity field; \\mathbf{f}_\\mathrm{ext}^\\alpha \\mathbf{f}_\\mathrm{ext}^\\alpha is the external force field; \\mathbf{t}^\\alpha \\mathbf{t}^\\alpha and \\mathbf{q}^\\alpha \\mathbf{q}^\\alpha are the stress and heat flux due to the homogeneous deformation of lattice, respectively; \\mathbf{\\tau}^\\alpha \\mathbf{\\tau}^\\alpha and \\mathbf{j}^\\alpha \\mathbf{j}^\\alpha are the stress and heat flux due to the reorganizations of atoms within the lattice cells, respectively. For monatomic crystals, which PyCAC can simulate , \\mathbf{y}^\\alpha = \\mathbf{0} \\mathbf{y}^\\alpha = \\mathbf{0} and N_a = 1 N_a = 1 ; the governing equations reduce to \\frac{\\mathrm{d} \\rho}{\\mathrm{d} t} + \\rho \\nabla_\\mathbf{x} \\cdot \\mathbf{v} = 0 \\frac{\\mathrm{d} \\rho}{\\mathrm{d} t} + \\rho \\nabla_\\mathbf{x} \\cdot \\mathbf{v} = 0 \\rho \\frac{\\mathrm{d} \\mathbf{v}}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{t} + \\mathbf{f}_\\mathrm{ext} \\rho \\frac{\\mathrm{d} \\mathbf{v}}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{t} + \\mathbf{f}_\\mathrm{ext} \\rho \\frac{\\mathrm{d} e}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{q} + \\mathbf{t} : \\nabla_\\mathbf{x} \\mathbf{v} \\rho \\frac{\\mathrm{d} e}{\\mathrm{d} t} = \\nabla_\\mathbf{x} \\cdot \\mathbf{q} + \\mathbf{t} : \\nabla_\\mathbf{x} \\mathbf{v} For conservative systems, i.e., a system in the absence of an internal source that generates or dissipates energy, the AFT energy equation is equivalent to the AFT linear momentum equation. Because of its current features , only the first two governing equations are explicitly implemented into PyCAC. Employing the classical definition of kinetic temperature, which is proportional to the kinetic part of the atomistic stress, the linear momentum equations can be expressed in a form that involves the internal force density \\mathbf{f}_\\mathrm{int}^\\alpha \\mathbf{f}_\\mathrm{int}^\\alpha and temperature T T [5-7], \\rho^\\alpha \\ddot{\\mathbf{u}}^\\alpha + \\frac{\\gamma^\\alpha k_\\mathrm{B}}{\\Delta V} \\nabla_\\mathbf{x} T = \\mathbf{f}_\\mathrm{int}^\\alpha + \\mathbf{f}_\\mathrm{ext}^\\alpha, \\quad \\alpha = 1, 2, \\ldots, N_a \\rho^\\alpha \\ddot{\\mathbf{u}}^\\alpha + \\frac{\\gamma^\\alpha k_\\mathrm{B}}{\\Delta V} \\nabla_\\mathbf{x} T = \\mathbf{f}_\\mathrm{int}^\\alpha + \\mathbf{f}_\\mathrm{ext}^\\alpha, \\quad \\alpha = 1, 2, \\ldots, N_a where \\mathbf{u}^\\alpha \\mathbf{u}^\\alpha is the displacement of the \\alpha \\alpha th atom at point \\mathbf{x} \\mathbf{x} ; the superposed dots denote the material time derivative; \\Delta V \\Delta V is the volume of the finite-sized material particle (the primitive unit cell for crystalline materials) at \\mathbf{x} \\mathbf{x} ; k_\\mathrm{B} k_\\mathrm{B} is the Boltzmann constant; \\gamma^\\alpha = \\rho^\\alpha / \\sum^{N_a}_{\\alpha = 1} \\rho^\\alpha \\gamma^\\alpha = \\rho^\\alpha / \\sum^{N_a}_{\\alpha = 1} \\rho^\\alpha , and \\mathbf{f}_\\mathrm{int}^\\alpha \\mathbf{f}_\\mathrm{int}^\\alpha is the internal force density and is a nonlinear nonlocal function of relative atomic displacements. For systems with a constant temperature field or a constant temperature gradient, the temperature term has the effect of a surface traction on the boundary or a body force in the interior of the material [6]. Denoting the temperature term in the above equation as \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) and the finite element shape function as \\Phi_\\xi(\\mathbf{x}) \\Phi_\\xi(\\mathbf{x}) , the Galerkin weak form of the above equation can be written as \\int_{\\Omega(\\mathbf{x})} \\Phi_\\xi(\\mathbf{x}) (\\rho^\\alpha \\ddot{\\mathbf{u}}^\\alpha(\\mathbf{x}) + \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) - \\mathbf{f}_\\mathrm{int}^\\alpha(\\mathbf{x}) - \\mathbf{f}_\\mathrm{ext}^\\alpha(\\mathbf{x})) \\mathrm{d} \\mathbf{x} = 0 \\int_{\\Omega(\\mathbf{x})} \\Phi_\\xi(\\mathbf{x}) (\\rho^\\alpha \\ddot{\\mathbf{u}}^\\alpha(\\mathbf{x}) + \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) - \\mathbf{f}_\\mathrm{int}^\\alpha(\\mathbf{x}) - \\mathbf{f}_\\mathrm{ext}^\\alpha(\\mathbf{x})) \\mathrm{d} \\mathbf{x} = 0 where \\Omega(\\mathbf{x}) \\Omega(\\mathbf{x}) is the simulation domain; the integrals can be evaluated using numerical integration methods such as Gaussian quadrature, leading to a set of discretized governing equations with the finite element nodal displacements as the unknowns to be solved. Note that in PyCAC, the \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) \\mathbf{f}_\\mathrm{T}^\\alpha(\\mathbf{x}) term has not yet been implemented as (i) the effect on mechanical properties in a constant temperature field is small and (ii) work is underway to compare different descriptions of temperature in the coarse-grained domain. The accuracy, efficiency, and stability of the CAC simulator are then determined by the two approximations: the shape function and the numerical integration. Simulation results can be displayed in terms of finite elements, which can also be mapped back to atomic positions and be used to plot the atomic trajectories. With the only constitutive relation being the nonlocal atomic force-displacement relation, continuity between elements in the usual finite element method is not required. Consequently, nucleation and propagation of dislocations and/or cracks can be simulated via sliding and separation between finite elements.","title":"The governing equations for conservative systems"},{"location":"chapter-2/atomistic-field-theory/#aft-and-the-equilibrium-ensembles","text":"The local densities defined in the Irving and Kirkwood formulations are ensemble averaged point functions. The ensemble averaging was described by Irving and Kirkwood as \" repeating the observations many times \" [3]. In the early version of the AFT formulation [1], the local densities were also defined as ensemble averages and hence the governing equations were written in terms of ensemble-averaged local densities. In the later version of the AFT formulation [2], the local densities are instantaneous quantities, according to argument by Evan and Morris [8], who wrote \" \\ldots \\ldots the reason for considering instantaneous expressions is two-fold. The fluxes are based upon conservation laws and these laws are valid instantaneously for every member of the ensemble. They do not require ensemble averaging to be true. Secondly, most computer simulation involves calculating system properties from a single system trajectory. Ensemble averaging is almost never used because it is relatively expensive in computer time \". Note that the AFT local densities and governing equations were derived as an extension of the Irving and Kirkwood's formulation of the equations of hydrodynamics. Consequently, they differ from other statistical mechanical formulations that follow the Gibbs' equilibrium statistical theory of ensembles. Popular equilibrium ensembles include (i) the microcanonical ensemble, which describes a systems isolated from its surroundings and governed by Hamilton's equations of motion (NVE), (ii) the canonical ensemble, which describe a system in constant contact with a heat bath of constant temperature (NVT), and (iii) the isothermal-isobaric ensembles, which describes systems in contact with a thermostat at temperature T T and a barostat at pressure P P (NPT) [9]. These ensembles, known as equilibrium ensembles and allowing a wide variety of thermodynamic and structural properties of systems to be computed, can be realized in dynamic CAC , in which a finite temperature can be achieved via lattice dynamic-based shape functions [10]. Alternatively, in the current code, a Langevin thermostat is realized while a constant pressure/stress is maintained via a Berendsen barostat.","title":"AFT and the equilibrium ensembles"},{"location":"chapter-2/atomistic-field-theory/#references","text":"Youping Chen, James Lee. Atomistic formulation of a multiscale theory for nano/micro physics , Philos. Mag. 85 (2005) 4095-4126 Youping Chen. Reformulation of microscopic balance equations for multiscale materials modeling , J. Chem. Phys. 130 (2009) 134706 J.H. Irving, Jhon G. Kirkwood. The statistical mechanical theory of transport processes. IV. The equations of hydrodynamics , J. Chem. Phys. 18 (1950) 817-829 Charles Kittel. Introduction to Solid State Physics , 1956: John Wiley & Sons, Inc Qian Deng, Coarse-graining atomistic dynamics of fracture by finite element method: Formulation, parallelization and applications , Ph.D. Dissertation , University of Florida, 2011 Liming Xiong, Youping Chen. Coarse-grained simulations of single-crystal silicon . Modelling Simul. Mater. Sci. Eng. 17 (2009) 035002 Liming Xiong, Youping Chen, James D. Lee. Atomistic simulation of mechanical properties of diamond and silicon carbide by a field theory , Modelling Simul. Mater. Sci. Eng. 15 (2007) 535-551 Denis J. Evans, Gary P. Morriss. Statistical Mechanics of Nonequilibrium Liquids , 2008: Cambridge University Press Mark E. Tuckerman. Statistical Mechanics: Theory and Molecular Simulation , 2010: Oxford University Press Xiang Chen, Adrian Diaz, Liming Xiong, David L. McDowell, Youping Chen. Passing waves from atomistic to continuum , J. Comput. Phys. 354 (2018) 393-402","title":"References"},{"location":"chapter-2/history/","text":"The CAC method is based on a concurrent atomistic-continuum formulation of balance laws [1,2] that are implemented using a finite element (FE) strategy, with the interatomic potential as the only constitutive relation. The formulation of the CAC balance equations, originally referred to as an atomic micromorphic theory or atomistic field theory (AFT) by Youping Chen and James D. Lee [1,3-8], is an extension of the Irving Kirkwood's formulation of \" the hydrodynamics equations for a single component, single phase system \" [9] to a two-level structural description of crystalline materials. The CAC formulation differs from that of classical continuum mechanics in that it employs a two-level structural description of materials. It is also distinct from the well-established theories of generalized continuum mechanics such as the Cosserat theory [10], micropolar theory [11,12], and micromorphic theory [13,14] in that the sub-level structural description is not continuous but discrete. The first version of the CAC numerical tool was developed by Liming Xiong ( Ph.D. 2011 ) and Qian Deng ( Ph.D. 2011 ). The reformulated balance equations were numerically implemented using FE method with trilinear FE shape functions and nodal integration, and the simulation tool was demonstrated to be able to capture the phenomenon of phase transition in Si [15] and the dynamic processes of fracture, including crack initiation, propagation and branching (Fig. 1) [16,17]. Figure 1. Time sequence of CAC simulations of a brittle material (2.24 \\mu\\mathrm{m} \\mu\\mathrm{m} by 1.4 \\mu\\mathrm{m} \\mu\\mathrm{m} ) showing (a) stress waves emitting from a propagating crack; (b) and (c) crack branching as a result of the interactions between waves propagating from the crack tip and those reflected from the specimen boundaries [17] The form and capabilities of the CAC method were extended substantially as a direct result of collaborative efforts between University of Florida and Georgia Tech in modeling and simulations of the dynamics of dislocations: elements that have discontinuities between them were employed, and the Gaussian quadrature was used for integration in the coarse-grained domain. Nucleation and propagation of dislocations in the coarse-grained domain [18,19], passing dislocations from the atomistic domain to the coarse-grained domain [20], the growth of dislocation loops in Cu, Al and Si (Fig. 2(a)) [21], fast moving dislocations (Fig. 2(b)) [22], and other progresses [23-26], have been successfully simulated without special numerical treatment or supplemental constitutive relations. The name \"CAC\" for the methodology was coined by David L. McDowell in 2010. Figure 2. (a) CAC simulation results of the nucleation and growth of dislocation loops in Cu, Al, Si [21]. (b) Time sequences of dislocation motions in MD and fully coarse-grained CAC simulations [22]. The CAC code was rewritten using Fortran 90 by Shengfeng Yang ( Ph.D. 2014 ) for multiscale simulation of polycrystalline ionic materials. This is the second-generation of the CAC code. It employs the Wolf method to calculate the long-range Columbic force and a special type of element (i.e., an incomplete element) to model regions with defects such as grain boundaries (GBs) in polyatomic materials. This version of the CAC code enables multiple meshing resolutions and simulation of two or more materials (e.g., Si and Ge), with multiple types of interatomic potentials, including the Buckingham and the Stillinger-Weber potentials. The CAC code was demonstrated to reproduce the equilibrium structures and energies of GBs in SrTiO _3 _3 , in good agreement with those obtained from existing experiments and density functional theory calculations. The code has been used to study the dynamic processes of crack initiation as well as the evolution of dislocation in single crystalline [27], bicrytalline [28], and polycrystalline SrTiO _3 _3 (Fig. 3) [29,30]. Figure 3. (a) A CAC model of polycrystalline SrTiO _3 _3 (2D view) in which the GBs are modeled with atomic resolution and the grains with coarse-scale finite elements; (b) Central symmetry parameter plot of the deformed model showing the nucleation and propagation of many dislocations and their interactions with the GBs; The comparison between (c) CAC and (d) MD simulation results is shown at strain 8.7% [30]. The CAC code was also rewritten by Shuozhi Xu ( Ph.D. 2016 ) using Fortran 2008. The code was optimized and the efficiency was significantly improved. The code includes the quasistatic version of CAC to carry out quasistatic simulations so as to obtain energy minimized atomic and nodal structures, in addition to dynamic simulations. Equipped with the Python scripting interface , this version of code, termed PyCAC , has been well tested for ductile fracture [31], quasistatic dislocation migration [32], screw dislocation cross-slip [33], edge dislocations bowing out from obstacles [34], dislocation multiplication from Frank-Read sources [35], dislocation/stacking fault interactions [36], and dislocation/GB interactions (Fig. 4) [37,38]. Figure 4. Snapshots of dislocation pile-up with dominant leading screw character impinging against a \\Sigma 3 \\Sigma 3 {111} coherent twin boundary (CTB) [38]. In (a), five incoming dislocations approach the CTB subject to an applied shear stress. In (b), the leading dislocation is constricted at the CTB, where two Shockley partial dislocations are recombined into a full dislocation. In (c), with certain interatomic potentials, the dislocation effectively cross-slips into the outgoing twinned grain via redissociation into two partials. In (d), with different potentials, the redissociated dislocation is absorbed by the CTB, with two partials gliding on the twin plane in opposite directions. Based on the Fortran 90 code, Xiang Chen ( Ph.D. 2016 ) extended the CAC method for space- and time-resolved simulation of the transient processes of the propagation of heat pulses in single crystals and across GBs [39] as well as the interactions between heat pulses and moving dislocations (Fig. 5) [40]. A phonon representation of the heat pulses, termed a coherent phonon pulse model [41], was created to mimic the coherent lattice excitation achieved via ultrashort laser pulses, and was incorporated into the framework of CAC to provide a coupled treatment for defect dynamics and phonon thermal transport. A first attempt was made to pass full phonon spectrum from the atomistic domain to the coarse-grained domain by introducing a wave-based interpolation scheme [42]. Figure 5. Normalized kinetic energy distribution in simulations of the propagation of dislocations and a heat pulse: (a-c) a moving dislocation before meeting a heat pulse, showing that the motion of the dislocation is accompanied by radial-shaped wavefronts of phonons ahead of the moving dislocation and V-shaped wave tails in the wake of the dislocation; (d) the dislocation meeting with a propagating heat pulse; (e-f) an array of moving dislocations meeting with the heat pulse showing partially coherent partially diffuse scattering of the phonons by the moving dislocations [40]. The groups of Profs. McDowell , Chen , and Xiong are still actively advancing the CAC method. Keep an eye on the CAC publications for the latest progress! References Youping Chen, James Lee. Atomistic formulation of a multiscale theory for nano/micro physics , Philos. Mag. 85 (2005) 4095-4126 Youping Chen. Reformulation of microscopic balance equations for multiscale materials modeling , J. Chem. Phys. 130 (2009) 134706 Youpig Chen, James D. Lee, Azim Eskandarian, Atomistic counterpart of micromorphic theory , Acta Mech. 161 (2003) 81-102 Youping Chen, Jonathan Zimmerman, Anton Krivtsov, David L. McDowell. Assessment of atomistic coarse-graining methods , Int. J. Eng. Sci. 49 (2011) 1337-1349 Youping Chen, James Lee, Liming Xiong. A generalized continuum theory and its relation to micromorphic theory , J. Eng. Mech. 135 (2009) 149-155 Liming Xiong, Youping Chen, James D. Lee. Modeling and simulation of boron-doped nanocrystalline silicon carbide thin film by a field theory , J. Nanosci. Nanotech. 9 (2009) 1034-1037 Liming Xiong, Youping Chen, James Lee. Simulation of dislocation nucleation and motion in single crystal magnesium oxide by a field theory , Comput. Mater. Sci. 42 (2008) 168-177 Liming Xiong, Youping Chen, James D. Lee. Atomistic simulation of mechanical properties of diamond and silicon carbide by a field theory , Modelling Simul. Mater. Sci. Eng. 15 (2007) 535-551 J.H. Irving, Jhon G. Kirkwood. The statistical mechanical theory of transport processes. IV. The equations of hydrodynamics , J. Chem. Phys. 18 (1950) 817-829 Eug\u00e8ne Cosserat, Fran\u00e7ois Cosserat. Th\u00e9orie des corps d\u00e9formables , Paris, (1909) 17-29 Youpig Chen, James D. Lee, Azim Eskandarian. Micropolar theory and its applications to mesoscopic and microscopic problems , Comput. Modeling Eng. Sci. 5 (2004) 35-43 A. Cemal Eringen. Theory of micropolar elasticity , in Microcontinuum Field Theories , Springer (1999) 101-248 A. Cemal Eringen. Microcontinuum Field Theories: I. Foundations and Solids , Springer (1999) A. Cemal Eringen. Mechanics of micromorphic continua , in: Mechanics of Generalized Continua. IUTAM Symposia (International Union of Theoretical and Applied Mechanics) , Springer (1968) Liming Xiong, Youping Chen. Coarse-grained simulations of single-crystal silicon . Modelling Simul. Mater. Sci. Eng. 17 (2009) 035002 Qian Deng, Youping Chen, A coarse-grained atomistic method for 3D dynamic fracture simulation , J. Multiscale Comput. Eng. 11 2013 2013 227-237 Qian Deng, Liming Xiong, Youping Chen. Coarse-graining atomistic dynamics of brittle fracture by finite element method , Int. J. Plast. 26 2010 2010 1402-1414 Liming Xiong, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulation of dislocations , J. Mech. Phys. Solids 59 2011 2011 160-177 Liming Xiong, Qian Deng, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulations of dislocations in Al, Ni and Cu crystals , Int. J. Plast. 38 2012 2012 86\u2013101 Liming Xiong, Qian Deng, Garritt Tucker, David L. McDowell, Youping Chen. A concurrent scheme for passing dislocations from atomistic to continuum domains , Acta Mater. 60 2012 2012 899-913 Liming Xiong, David L. McDowell, Youping Chen. Nucleation and growth of dislocation loops in Cu, Al and Si by a concurrent atomistic-continuum method , Scr. Mater. 67 2012 2012 633\u2013636 Liming Xiong, Ji Rigelesaiyin, Xiang Chen, Shuozhi Xu, David L. McDowell, Youping Chen. Coarse-grained elastodynamics of fast moving dislocations , Acta Mater. 104 2016 2016 143-155 Liming Xiong, Shuozhi Xu, David L. McDowell, Youping Chen. Concurrent atomistic-continuum simulations of dislocation-void interactions in fcc crystals , Int. J. Plast. 65 2015 2015 33-42 Liming Xiong, Xiang Chen, Ning Zhang, David L. McDowell, Youping Chen. Prediction of phonon properties of 1D polyatomic systems using concurrent atomistic-continuum simulation , Arch. Appl. Mech. 84 2014 2014 1665-1675 Liming Xiong, David L. McDowell, Youping Chen. Sub-THz Phonon drag on dislocations by coarse-grained atomistic simulations , Int. J. Plast. 55 2014 2014 268-278 Liming Xiong, Youping Chen. Effects of dopants on the mechanical properties of nanocrystalline silicon carbide thin film , Comput. Modeling Eng. Sci. 24 (2008) 203-214 Shengfeng Yang, Liming Xiong, Qian Deng, Youping Chen. Concurrent atomistic and continuum simulation of strontium titanate , Acta Mater. 61 2013 2013 89\u2013102 Shengfeng Yang, Youping Chen. Concurrent atomistic and continuum simulation of bi-crystal strontium titanate with tilt grain boundary , Proc. R. Soc. A 471 2015 2015 20140758 Shengfeng Yang, Youping Chen, Concurrent atomistic-continuum simulation of defects in polyatomic ionic materials , in Multiscale Materials Modeling for Nanomechanics ed: Christopher R. Weinberger, Garritt J. Tucker ed: Christopher R. Weinberger, Garritt J. Tucker , Switzerland: Springer International Publishing, 2016 Shengfeng Yang, Ning Zhang, Youping Chen. Concurrent atomistic-continuum simulation of polycrystalline strontium titanate , Philos. Mag. 95 2015 2015 2697-2716 Shuozhi Xu, Liming Xiong, Qian Deng, David L. McDowell. Mesh refinement schemes for the concurrent atomistic-continuum method , Int. J. Solids Struct. 90 2016 2016 144-152 Shuozhi Xu, Rui Che, Liming Xiong, Youping Chen, David L. McDowell. A quasistatic implementation of the concurrent atomistic-continuum method for FCC crystals , Int. J. Plast. 72 2015 2015 91\u2013126 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Shear stress- and line length-dependent screw dislocation cross-slip in FCC Ni , Acta Mater. 122 2017 2017 412-419 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Edge dislocations bowing out from a row of collinear obstacles in Al , Scr. Mater. 123 2016 2016 135-139 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. An analysis of key characteristics of the Frank-Read source process in FCC metals , J. Mech. Phys. Solids 96 2016 2016 460-476 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Validation of the concurrent atomistic-continuum method on screw dislocation/stacking fault interactions , Crystals 7 (2017) 120 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Sequential slip transfer of mixed character dislocations across \\Sigma 3 \\Sigma 3 <span><span class=\"MathJax_Preview\">\\Sigma 3</span><script type=\"math/tex\">\\Sigma 3 coherent twin boundary in FCC metals: A concurrent atomistic-continuum study , npj Comput. Mater. 2 2016 2016 15016 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Comparing EAM potentials to model slip transfer of sequential mixed character dislocations across two symmetric tilt grain boundaries in Ni , JOM 69 (2017) 814-821 Xiang Chen, Weixuan Li, Liming Xiong, Yang Li, Shengfeng Yang, Zexi Zheng, David L. McDowell, Youping Chen. Ballistic-diffusive phonon heat transport across grain boundaries , Acta Mater. 136 (2017) 355-365 Xiang Chen, Liming Xiong, David L. McDowell, Youping Chen. Effects of phonons on mobility of dislocations and dislocation arrays , Scr. Mater. 137 (2017) 22-26 Xiang Chen, Aleksandr Chernatynskiy, Liming Xiong, Youping Chen. A coherent phonon pulse model for transient phonon thermal transport , Comput. Phys. Comm. 195 (2015) 112\u2013116 Xiang Chen, Adrian Diaz, Liming Xiong, David L. McDowell, Youping Chen. Passing waves from atomistic to continuum , J. Comput. Phys. 354 (2018) 393-402","title":"A brief history of CAC(2003-2017)"},{"location":"chapter-2/history/#references","text":"Youping Chen, James Lee. Atomistic formulation of a multiscale theory for nano/micro physics , Philos. Mag. 85 (2005) 4095-4126 Youping Chen. Reformulation of microscopic balance equations for multiscale materials modeling , J. Chem. Phys. 130 (2009) 134706 Youpig Chen, James D. Lee, Azim Eskandarian, Atomistic counterpart of micromorphic theory , Acta Mech. 161 (2003) 81-102 Youping Chen, Jonathan Zimmerman, Anton Krivtsov, David L. McDowell. Assessment of atomistic coarse-graining methods , Int. J. Eng. Sci. 49 (2011) 1337-1349 Youping Chen, James Lee, Liming Xiong. A generalized continuum theory and its relation to micromorphic theory , J. Eng. Mech. 135 (2009) 149-155 Liming Xiong, Youping Chen, James D. Lee. Modeling and simulation of boron-doped nanocrystalline silicon carbide thin film by a field theory , J. Nanosci. Nanotech. 9 (2009) 1034-1037 Liming Xiong, Youping Chen, James Lee. Simulation of dislocation nucleation and motion in single crystal magnesium oxide by a field theory , Comput. Mater. Sci. 42 (2008) 168-177 Liming Xiong, Youping Chen, James D. Lee. Atomistic simulation of mechanical properties of diamond and silicon carbide by a field theory , Modelling Simul. Mater. Sci. Eng. 15 (2007) 535-551 J.H. Irving, Jhon G. Kirkwood. The statistical mechanical theory of transport processes. IV. The equations of hydrodynamics , J. Chem. Phys. 18 (1950) 817-829 Eug\u00e8ne Cosserat, Fran\u00e7ois Cosserat. Th\u00e9orie des corps d\u00e9formables , Paris, (1909) 17-29 Youpig Chen, James D. Lee, Azim Eskandarian. Micropolar theory and its applications to mesoscopic and microscopic problems , Comput. Modeling Eng. Sci. 5 (2004) 35-43 A. Cemal Eringen. Theory of micropolar elasticity , in Microcontinuum Field Theories , Springer (1999) 101-248 A. Cemal Eringen. Microcontinuum Field Theories: I. Foundations and Solids , Springer (1999) A. Cemal Eringen. Mechanics of micromorphic continua , in: Mechanics of Generalized Continua. IUTAM Symposia (International Union of Theoretical and Applied Mechanics) , Springer (1968) Liming Xiong, Youping Chen. Coarse-grained simulations of single-crystal silicon . Modelling Simul. Mater. Sci. Eng. 17 (2009) 035002 Qian Deng, Youping Chen, A coarse-grained atomistic method for 3D dynamic fracture simulation , J. Multiscale Comput. Eng. 11 2013 2013 227-237 Qian Deng, Liming Xiong, Youping Chen. Coarse-graining atomistic dynamics of brittle fracture by finite element method , Int. J. Plast. 26 2010 2010 1402-1414 Liming Xiong, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulation of dislocations , J. Mech. Phys. Solids 59 2011 2011 160-177 Liming Xiong, Qian Deng, Garritt Tucker, David L. McDowell, Youping Chen. Coarse-grained atomistic simulations of dislocations in Al, Ni and Cu crystals , Int. J. Plast. 38 2012 2012 86\u2013101 Liming Xiong, Qian Deng, Garritt Tucker, David L. McDowell, Youping Chen. A concurrent scheme for passing dislocations from atomistic to continuum domains , Acta Mater. 60 2012 2012 899-913 Liming Xiong, David L. McDowell, Youping Chen. Nucleation and growth of dislocation loops in Cu, Al and Si by a concurrent atomistic-continuum method , Scr. Mater. 67 2012 2012 633\u2013636 Liming Xiong, Ji Rigelesaiyin, Xiang Chen, Shuozhi Xu, David L. McDowell, Youping Chen. Coarse-grained elastodynamics of fast moving dislocations , Acta Mater. 104 2016 2016 143-155 Liming Xiong, Shuozhi Xu, David L. McDowell, Youping Chen. Concurrent atomistic-continuum simulations of dislocation-void interactions in fcc crystals , Int. J. Plast. 65 2015 2015 33-42 Liming Xiong, Xiang Chen, Ning Zhang, David L. McDowell, Youping Chen. Prediction of phonon properties of 1D polyatomic systems using concurrent atomistic-continuum simulation , Arch. Appl. Mech. 84 2014 2014 1665-1675 Liming Xiong, David L. McDowell, Youping Chen. Sub-THz Phonon drag on dislocations by coarse-grained atomistic simulations , Int. J. Plast. 55 2014 2014 268-278 Liming Xiong, Youping Chen. Effects of dopants on the mechanical properties of nanocrystalline silicon carbide thin film , Comput. Modeling Eng. Sci. 24 (2008) 203-214 Shengfeng Yang, Liming Xiong, Qian Deng, Youping Chen. Concurrent atomistic and continuum simulation of strontium titanate , Acta Mater. 61 2013 2013 89\u2013102 Shengfeng Yang, Youping Chen. Concurrent atomistic and continuum simulation of bi-crystal strontium titanate with tilt grain boundary , Proc. R. Soc. A 471 2015 2015 20140758 Shengfeng Yang, Youping Chen, Concurrent atomistic-continuum simulation of defects in polyatomic ionic materials , in Multiscale Materials Modeling for Nanomechanics ed: Christopher R. Weinberger, Garritt J. Tucker ed: Christopher R. Weinberger, Garritt J. Tucker , Switzerland: Springer International Publishing, 2016 Shengfeng Yang, Ning Zhang, Youping Chen. Concurrent atomistic-continuum simulation of polycrystalline strontium titanate , Philos. Mag. 95 2015 2015 2697-2716 Shuozhi Xu, Liming Xiong, Qian Deng, David L. McDowell. Mesh refinement schemes for the concurrent atomistic-continuum method , Int. J. Solids Struct. 90 2016 2016 144-152 Shuozhi Xu, Rui Che, Liming Xiong, Youping Chen, David L. McDowell. A quasistatic implementation of the concurrent atomistic-continuum method for FCC crystals , Int. J. Plast. 72 2015 2015 91\u2013126 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Shear stress- and line length-dependent screw dislocation cross-slip in FCC Ni , Acta Mater. 122 2017 2017 412-419 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Edge dislocations bowing out from a row of collinear obstacles in Al , Scr. Mater. 123 2016 2016 135-139 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. An analysis of key characteristics of the Frank-Read source process in FCC metals , J. Mech. Phys. Solids 96 2016 2016 460-476 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Validation of the concurrent atomistic-continuum method on screw dislocation/stacking fault interactions , Crystals 7 (2017) 120 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Sequential slip transfer of mixed character dislocations across \\Sigma 3 \\Sigma 3 <span><span class=\"MathJax_Preview\">\\Sigma 3</span><script type=\"math/tex\">\\Sigma 3 coherent twin boundary in FCC metals: A concurrent atomistic-continuum study , npj Comput. Mater. 2 2016 2016 15016 Shuozhi Xu, Liming Xiong, Youping Chen, David L. McDowell. Comparing EAM potentials to model slip transfer of sequential mixed character dislocations across two symmetric tilt grain boundaries in Ni , JOM 69 (2017) 814-821 Xiang Chen, Weixuan Li, Liming Xiong, Yang Li, Shengfeng Yang, Zexi Zheng, David L. McDowell, Youping Chen. Ballistic-diffusive phonon heat transport across grain boundaries , Acta Mater. 136 (2017) 355-365 Xiang Chen, Liming Xiong, David L. McDowell, Youping Chen. Effects of phonons on mobility of dislocations and dislocation arrays , Scr. Mater. 137 (2017) 22-26 Xiang Chen, Aleksandr Chernatynskiy, Liming Xiong, Youping Chen. A coherent phonon pulse model for transient phonon thermal transport , Comput. Phys. Comm. 195 (2015) 112\u2013116 Xiang Chen, Adrian Diaz, Liming Xiong, David L. McDowell, Youping Chen. Passing waves from atomistic to continuum , J. Comput. Phys. 354 (2018) 393-402","title":"References"},{"location":"chapter-3/","text":"Algorithm A framework for mixed atomistic/continuum modeling, the CAC algorithm adopts common atomistic modeling and finite element techniques. In the atomistic domain, Newton\u2019s third law is employed to promote efficiency in calculating the force, pair potential, local electron density, and stress. The short-range neighbor search employs a combined cell list and Verlet list method. In the coarse-grained domain, the Garlekin method and Gaussian quadrature are employed to solve the governing equations . There are, however, several issues in CAC simulations with coarse-graining that do not exist in standard atomistic and finite element method simulations. For more information, read chapter 3 of Shuozhi Xu's Ph.D. dissertation .","title":"Algorithm"},{"location":"chapter-3/#algorithm","text":"A framework for mixed atomistic/continuum modeling, the CAC algorithm adopts common atomistic modeling and finite element techniques. In the atomistic domain, Newton\u2019s third law is employed to promote efficiency in calculating the force, pair potential, local electron density, and stress. The short-range neighbor search employs a combined cell list and Verlet list method. In the coarse-grained domain, the Garlekin method and Gaussian quadrature are employed to solve the governing equations . There are, however, several issues in CAC simulations with coarse-graining that do not exist in standard atomistic and finite element method simulations. For more information, read chapter 3 of Shuozhi Xu's Ph.D. dissertation .","title":"Algorithm"},{"location":"chapter-3/input/","text":"To run a CAC simulation, one may create/modify cac.in , in which the commands provide all input parameters for a CAC simulation. The cac.in file, along with the potential files ( embed.tab , pair.tab , and edens.tab for the EAM potential; lj.para for the LJ potential), are read by the Fortran CAC code to run the CAC simulation . The potential files for some FCC metals are provided in the potentials directory. EAM potential The EAM formulations for potential energy E E and the force on atom k k , \\mathbf{f}_k \\mathbf{f}_k , are E = \\frac{1}{2}\\sum_i\\sum_{j \\atop j\\neq i} V_{ij}(r_{ij}) + \\sum_i F(\\bar{\\rho}_i) E = \\frac{1}{2}\\sum_i\\sum_{j \\atop j\\neq i} V_{ij}(r_{ij}) + \\sum_i F(\\bar{\\rho}_i) \\mathbf{f}_k = \\sum_{j \\atop j \\neq k}\\left[\\frac{\\partial V_{kj}(r_{kj})}{\\partial r_{kj}}+\\left(\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}+\\frac{\\partial F(\\bar{\\rho}_j)}{\\partial \\bar{\\rho}_j}\\right)\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\right]\\frac{\\mathbf{r}_{kj}}{r_{kj}} \\mathbf{f}_k = \\sum_{j \\atop j \\neq k}\\left[\\frac{\\partial V_{kj}(r_{kj})}{\\partial r_{kj}}+\\left(\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}+\\frac{\\partial F(\\bar{\\rho}_j)}{\\partial \\bar{\\rho}_j}\\right)\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\right]\\frac{\\mathbf{r}_{kj}}{r_{kj}} where \\bar{\\rho}_i = \\sum_{j \\atop j \\neq i} \\rho_{ij}(r_{ij}) \\bar{\\rho}_i = \\sum_{j \\atop j \\neq i} \\rho_{ij}(r_{ij}) Note that the force formulation above only holds for monatomic pure materials . The first line of each *.tab file is N first_val last_val where N is a positive integer that equals the number of data pair (each line starting from the second line), first_val and last_val are non-negative real numbers suggesting the first and the last datum in the first column (starting from the second line), respectively. In embed.tab , the first column is the unitless host electron energy \\bar{\\rho} \\bar{\\rho} ; the second column is the embedded energy F F , in eV. In pair.tab , the first column is the interatomic distance r r , in Angstrom; the second column is the pair potential V V , in eV. In edens.tab , the first column is the interatomic distance r r , in Angstrom; the second column is the unitless local electron density \\rho \\rho . For example, the first few lines of potentials/eam/Ag/williams/edens.tab are 3000 0.5018316703334310 5.995011000293092 0.5018316703334310 8.9800288540000004E-002 0.5036633406668621 9.0604138970000001E-002 0.5054950110002930 9.1404200869999990E-002 0.5073266813337241 9.2200486049999988E-002 In CAC simulations, an approximation is introduced to calculate the host electron density \\bar{\\rho} \\bar{\\rho} of the integration points in the coarse-grained domain. For more information, read chapter 3 of Shuozhi Xu's Ph.D. dissertation . The readers may find EAM potential files in these database: NIST University of Edinburgh Other resources Note that most of these files do not have the format that suits the CAC simulation. LJ potential The LJ formulation for potential energy is E = \\frac{1}{2}\\sum_i\\sum_{j\\neq i} 4\\epsilon \\left[ \\left( \\frac{\\sigma}{r^{ij}} \\right)^{12} - \\left( \\frac{\\sigma}{r^{ij}} \\right)^6 \\right] E = \\frac{1}{2}\\sum_i\\sum_{j\\neq i} 4\\epsilon \\left[ \\left( \\frac{\\sigma}{r^{ij}} \\right)^{12} - \\left( \\frac{\\sigma}{r^{ij}} \\right)^6 \\right] where \\epsilon \\epsilon and \\sigma \\sigma are two parameters. In the PyCAC code, the interatomic force, not the energy, is shifted such that the force goes continuously to zero at the cut-off distance r_\\mathrm{c} r_\\mathrm{c} , i.e., if r < r_\\mathrm{c} r < r_\\mathrm{c} , f = f(r) - f(r_\\mathrm{c}) f = f(r) - f(r_\\mathrm{c}) ; otherwise, f = 0 f = 0 . In lj.para , a blank line or a line with the \"#\" character in column one (a comment line) is ignored; three positive real numbers ( \\epsilon \\epsilon , \\sigma \\sigma , and r_\\mathrm{c} r_\\mathrm{c} ) and one non-negative real number ( r_0 r_0 ) are given in any sequence, where r_0 r_0 is a place holder that should always be 0.0 for the LJ potential. Note that for the EAM potential, r_0 r_0 equals the minimum interatomic distance, i.e., the smaller first_val given in pair.tab and edens.tab . For example, potentials/lj/Cu/kluge/lj.para reads # parameters for the LJ potential epsilon 0.167 sigma 2.315 rcmin 0. rcoff 5.38784 where epsilon = \\epsilon \\epsilon , sigma = \\sigma \\sigma , rcmin = r_0 r_0 , and rcoff = r_\\mathrm{c} r_\\mathrm{c} . Other files When boolean_restart = t , a cac_in.restart file needs to be provided. This file is renamed from one of the cac_out_#.restart files, where # is a positive integer. When restart_group_number > 0, or boolean_restart_refine = t and refine_style = group , one or more group_in_*.id files need to be provided, where * is a positive integer. These files are renamed from group_out_*_#.id files, which are created automatically when the total number of groups > 0. Note that if the # here does not match that in the cac_out_#.restart file, the information of the restart group may be incorrect. When modify_number > 0 and at least one of the modify_style = add_atom , one or more LAMMPS data files lmp_*.dat need to be provided, where * is the id of the current modify command in cac.in .","title":"Input"},{"location":"chapter-3/input/#eam-potential","text":"The EAM formulations for potential energy E E and the force on atom k k , \\mathbf{f}_k \\mathbf{f}_k , are E = \\frac{1}{2}\\sum_i\\sum_{j \\atop j\\neq i} V_{ij}(r_{ij}) + \\sum_i F(\\bar{\\rho}_i) E = \\frac{1}{2}\\sum_i\\sum_{j \\atop j\\neq i} V_{ij}(r_{ij}) + \\sum_i F(\\bar{\\rho}_i) \\mathbf{f}_k = \\sum_{j \\atop j \\neq k}\\left[\\frac{\\partial V_{kj}(r_{kj})}{\\partial r_{kj}}+\\left(\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}+\\frac{\\partial F(\\bar{\\rho}_j)}{\\partial \\bar{\\rho}_j}\\right)\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\right]\\frac{\\mathbf{r}_{kj}}{r_{kj}} \\mathbf{f}_k = \\sum_{j \\atop j \\neq k}\\left[\\frac{\\partial V_{kj}(r_{kj})}{\\partial r_{kj}}+\\left(\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}+\\frac{\\partial F(\\bar{\\rho}_j)}{\\partial \\bar{\\rho}_j}\\right)\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\right]\\frac{\\mathbf{r}_{kj}}{r_{kj}} where \\bar{\\rho}_i = \\sum_{j \\atop j \\neq i} \\rho_{ij}(r_{ij}) \\bar{\\rho}_i = \\sum_{j \\atop j \\neq i} \\rho_{ij}(r_{ij}) Note that the force formulation above only holds for monatomic pure materials . The first line of each *.tab file is N first_val last_val where N is a positive integer that equals the number of data pair (each line starting from the second line), first_val and last_val are non-negative real numbers suggesting the first and the last datum in the first column (starting from the second line), respectively. In embed.tab , the first column is the unitless host electron energy \\bar{\\rho} \\bar{\\rho} ; the second column is the embedded energy F F , in eV. In pair.tab , the first column is the interatomic distance r r , in Angstrom; the second column is the pair potential V V , in eV. In edens.tab , the first column is the interatomic distance r r , in Angstrom; the second column is the unitless local electron density \\rho \\rho . For example, the first few lines of potentials/eam/Ag/williams/edens.tab are 3000 0.5018316703334310 5.995011000293092 0.5018316703334310 8.9800288540000004E-002 0.5036633406668621 9.0604138970000001E-002 0.5054950110002930 9.1404200869999990E-002 0.5073266813337241 9.2200486049999988E-002 In CAC simulations, an approximation is introduced to calculate the host electron density \\bar{\\rho} \\bar{\\rho} of the integration points in the coarse-grained domain. For more information, read chapter 3 of Shuozhi Xu's Ph.D. dissertation . The readers may find EAM potential files in these database: NIST University of Edinburgh Other resources Note that most of these files do not have the format that suits the CAC simulation.","title":"EAM potential"},{"location":"chapter-3/input/#lj-potential","text":"The LJ formulation for potential energy is E = \\frac{1}{2}\\sum_i\\sum_{j\\neq i} 4\\epsilon \\left[ \\left( \\frac{\\sigma}{r^{ij}} \\right)^{12} - \\left( \\frac{\\sigma}{r^{ij}} \\right)^6 \\right] E = \\frac{1}{2}\\sum_i\\sum_{j\\neq i} 4\\epsilon \\left[ \\left( \\frac{\\sigma}{r^{ij}} \\right)^{12} - \\left( \\frac{\\sigma}{r^{ij}} \\right)^6 \\right] where \\epsilon \\epsilon and \\sigma \\sigma are two parameters. In the PyCAC code, the interatomic force, not the energy, is shifted such that the force goes continuously to zero at the cut-off distance r_\\mathrm{c} r_\\mathrm{c} , i.e., if r < r_\\mathrm{c} r < r_\\mathrm{c} , f = f(r) - f(r_\\mathrm{c}) f = f(r) - f(r_\\mathrm{c}) ; otherwise, f = 0 f = 0 . In lj.para , a blank line or a line with the \"#\" character in column one (a comment line) is ignored; three positive real numbers ( \\epsilon \\epsilon , \\sigma \\sigma , and r_\\mathrm{c} r_\\mathrm{c} ) and one non-negative real number ( r_0 r_0 ) are given in any sequence, where r_0 r_0 is a place holder that should always be 0.0 for the LJ potential. Note that for the EAM potential, r_0 r_0 equals the minimum interatomic distance, i.e., the smaller first_val given in pair.tab and edens.tab . For example, potentials/lj/Cu/kluge/lj.para reads # parameters for the LJ potential epsilon 0.167 sigma 2.315 rcmin 0. rcoff 5.38784 where epsilon = \\epsilon \\epsilon , sigma = \\sigma \\sigma , rcmin = r_0 r_0 , and rcoff = r_\\mathrm{c} r_\\mathrm{c} .","title":"LJ potential"},{"location":"chapter-3/input/#other-files","text":"When boolean_restart = t , a cac_in.restart file needs to be provided. This file is renamed from one of the cac_out_#.restart files, where # is a positive integer. When restart_group_number > 0, or boolean_restart_refine = t and refine_style = group , one or more group_in_*.id files need to be provided, where * is a positive integer. These files are renamed from group_out_*_#.id files, which are created automatically when the total number of groups > 0. Note that if the # here does not match that in the cac_out_#.restart file, the information of the restart group may be incorrect. When modify_number > 0 and at least one of the modify_style = add_atom , one or more LAMMPS data files lmp_*.dat need to be provided, where * is the id of the current modify command in cac.in .","title":"Other files"},{"location":"chapter-3/output/","text":"A series of vtk files created on-the-fly The main output of a CAC simulation are cac_cg_#.vtk and cac_atom_#.vtk files that contain elemental/nodal information and atomic information in the coarse-grained and the atomistic domains, respectively, where # , a non-negative integer, is the simulation step at which the file is created. These files, created by vtk_legacy.f90 with a frequency of output_freq , can be read by ParaView . Note that besides the nodal/atomic positions, the energy scalar, the force vector, and the stress tensor of each node/atom are also recorded in these vtk files. One-time vtk and dump files Besides the files that are created on-the-fly, in the beginning of a simulation, a model_atom.vtk file containing atomic positions in the atomistic domain, a model_cg.vtk file containing nodal positions in the coarse-grained domain, and a model_intpo.vtk file containing integration point positions and weights in the coarse-grained domain are also created, by vtk_legacy_model.f90 . A standard LAMMPS dump file dump.lammps which, in addition to the positions of the real/interpolated atoms, also contain the velocities of the real/interpolated atoms if simulation_style = dynamics or hybrid , is created by atomp_plot_lammps.f90 . When the total number of groups > 0, multiple group_cg_*.vtk and group_atom_*.vtk files, where * , a positive integer, is the group id, are created by vtk_legacy_group.f90 for the coarse-grained and the atomistic domains, respectively. These files are used to show whether the initial simulation cell and group settings are correct. Different from the cac_cg_#.vtk and cac_atom_#.vtk files, the one-time vtk files here do not contain the energy/force/stress information, but only the nodal/atomic positions. All vtk and dump files are then post-processed for visualization purposes. Other files cac.log is the log file of a CAC simulation, containing information mostly written by cac_log.f90 . stress_strain and temperature , with a frequency of log_freq , record the 3\\times 3 3\\times 3 stress/strain tensors and the temperature, respectively, at certain simulation step . A series of cac_out_#.restart files, where # is a positive integer, are created with a frequency of restart_freq . One of these files can then be renamed to cac_in.restart to restart a prior simulation when boolean_restart = t . If boolean_debug = t , a writable debug file is created by debug_init.f90 . The user can then write to it whatever he/she wants using unit number 13, i.e., write(13, format) output When the total number of groups > 0, a series of group_out_*_#.id files are created, where * is the group id starting from 1 and # is the simulation step at which the file is created. These files can then be renamed to group_in_*.id for restart group and refinement purposes.","title":"Output"},{"location":"chapter-3/output/#a-series-of-vtk-files-created-on-the-fly","text":"The main output of a CAC simulation are cac_cg_#.vtk and cac_atom_#.vtk files that contain elemental/nodal information and atomic information in the coarse-grained and the atomistic domains, respectively, where # , a non-negative integer, is the simulation step at which the file is created. These files, created by vtk_legacy.f90 with a frequency of output_freq , can be read by ParaView . Note that besides the nodal/atomic positions, the energy scalar, the force vector, and the stress tensor of each node/atom are also recorded in these vtk files.","title":"A series of vtk files created on-the-fly"},{"location":"chapter-3/output/#one-time-vtk-and-dump-files","text":"Besides the files that are created on-the-fly, in the beginning of a simulation, a model_atom.vtk file containing atomic positions in the atomistic domain, a model_cg.vtk file containing nodal positions in the coarse-grained domain, and a model_intpo.vtk file containing integration point positions and weights in the coarse-grained domain are also created, by vtk_legacy_model.f90 . A standard LAMMPS dump file dump.lammps which, in addition to the positions of the real/interpolated atoms, also contain the velocities of the real/interpolated atoms if simulation_style = dynamics or hybrid , is created by atomp_plot_lammps.f90 . When the total number of groups > 0, multiple group_cg_*.vtk and group_atom_*.vtk files, where * , a positive integer, is the group id, are created by vtk_legacy_group.f90 for the coarse-grained and the atomistic domains, respectively. These files are used to show whether the initial simulation cell and group settings are correct. Different from the cac_cg_#.vtk and cac_atom_#.vtk files, the one-time vtk files here do not contain the energy/force/stress information, but only the nodal/atomic positions. All vtk and dump files are then post-processed for visualization purposes.","title":"One-time vtk and dump files"},{"location":"chapter-3/output/#other-files","text":"cac.log is the log file of a CAC simulation, containing information mostly written by cac_log.f90 . stress_strain and temperature , with a frequency of log_freq , record the 3\\times 3 3\\times 3 stress/strain tensors and the temperature, respectively, at certain simulation step . A series of cac_out_#.restart files, where # is a positive integer, are created with a frequency of restart_freq . One of these files can then be renamed to cac_in.restart to restart a prior simulation when boolean_restart = t . If boolean_debug = t , a writable debug file is created by debug_init.f90 . The user can then write to it whatever he/she wants using unit number 13, i.e., write(13, format) output When the total number of groups > 0, a series of group_out_*_#.id files are created, where * is the group id starting from 1 and # is the simulation step at which the file is created. These files can then be renamed to group_in_*.id for restart group and refinement purposes.","title":"Other files"},{"location":"chapter-3/parallel/","text":"Among the three parallel algorithms commonly employed in atomistic simulations \u2014 atom decomposition (AD), force decomposition (FD), and spatial decomposition (SD), SD yields the best scalability and the smallest communication overhead between processors. Unlike AD and FD, the workload of each processor in SD, which is proportional to the number of interactions, is unfortunately not guaranteed to be the same. In CAC, the simulation cell has nonuniformly distributed integration points (in the coarse-grained domain) and atoms (in the atomistic domain), such that the workload is poorly balanced if one assigns each processor an equally-sized cubic domain as in full atomistics. This workload balance issue is not unique to CAC, but is also encountered by other concurrent multiscale modeling methods. The PyCAC code employs the SD algorithm in which the load balance is optimized, as shown in the figure below which is adapted from Fig. 5 of Xu et al., 2018 . Parallel CAC simulation scheme. Procedures that do not exist in the serial CAC simulation scheme are highlighted in yellow. Note that (i) in the serial scheme, the root processor does everything and (ii) the two procedures in the dashed box are conducted back and forth until the output begins.","title":"Parallelization"},{"location":"chapter-3/precision/","text":"To ensure the processor-independent precision , the working precision ( wp ) is defined in the precision_comm_module.f90 module file . The default precision is 64-bit real, the users can opt for 128-bit real by modifying wp . The default size used for an integer is KIND = 4, meaning that any integer may have a signed value ranging from -2,147,483,648 to 2,147,483,647. In PyCAC, the maximum integer is usually the number of atoms (both the real atoms in the atomistic domain and the interpolated atoms in the coarse-grained domain). In the case that each element contains 2197 atoms, this limit suggests that there cannot be more than 977,461 elements in a fully coarse-grained simulation cell. If the user wants to study larger simulation cells, he/she needs to modify the source code.","title":"Arithmetic precision"},{"location":"chapter-3/scheme/","text":"A flowchart of the CAC simulation scheme based on spatial decomposition is presented below: where there are three types of CAC simulations: dynamics, quasistatics, and hybrid, specified by the simulator . In CAC simulations, the elements/nodes/atoms information can either be created from scratch ( model_setup.f90 ) or read from the cac_in.restart file ( read_restart.f90 ), depending on the parameters in the restart command. The dynamic CAC scheme is The quasistatic CAC scheme is The hybrid CAC scheme is All these four figures are respectively adapted from Fig. 1, Fig. S1, Fig. S2, and Fig. 2 of Xu et al., 2018 . More information of the dynamic and quasistatic CAC can be found in the dynamics and minimize commands, respectively.","title":"Scheme"},{"location":"chapter-3/unit/","text":"PyCAC assumes the use of the following defined molecular units: The unit of time is 10^{-12} 10^{-12} seconds (i.e., picoseconds) The unit of length is 10^{-10} 10^{-10} meters (i.e., Angstroms) The unit of mass is 1.66053904\\times 10^{-27} 1.66053904\\times 10^{-27} kilograms (i.e., Daltons - unified atomic mass units) The unit of energy is 1.602176565\\times 10^{-19} 1.602176565\\times 10^{-19} Joules (i.e., eV) The unit of force is 1.602176565\\times 10^{-9} 1.602176565\\times 10^{-9} Newtons (i.e., eV/Angstrom) The unit of pressure is 10^9 10^9 Pascales (i.e., GPa)","title":"Units"},{"location":"chapter-4/","text":"Graphical user interface The PyCAC graphical user interface (GUI) is an application that simplifies the creation, submission, and analysis of CAC simulation projects. Written in Python 3, the PyCAC GUI provides a robust interface to facilitate parametric studies via CAC simulations without interacting with the Fortran code and to improve handling of input, output, and visualization options. The module works on local computers and serves as an interface with high performance computing clusters. In particular, the Python module consists of three main functionalities: Project creation , Existing project upload , and Result download/conversion . If you are interested in the using the PyCAC suite for your research, please first email Prof. David L. McDowell for access to the separate CAC simulator package, then follow the installation steps . The GUI is currently in its alpha release stage. For bug reports or questions relating directly to the GUI, please contact Alex Selimov or Kevin Chu","title":"Graphical user interface"},{"location":"chapter-4/#graphical-user-interface","text":"The PyCAC graphical user interface (GUI) is an application that simplifies the creation, submission, and analysis of CAC simulation projects. Written in Python 3, the PyCAC GUI provides a robust interface to facilitate parametric studies via CAC simulations without interacting with the Fortran code and to improve handling of input, output, and visualization options. The module works on local computers and serves as an interface with high performance computing clusters. In particular, the Python module consists of three main functionalities: Project creation , Existing project upload , and Result download/conversion . If you are interested in the using the PyCAC suite for your research, please first email Prof. David L. McDowell for access to the separate CAC simulator package, then follow the installation steps . The GUI is currently in its alpha release stage. For bug reports or questions relating directly to the GUI, please contact Alex Selimov or Kevin Chu","title":"Graphical user interface"},{"location":"chapter-4/create/","text":"PyCAC project creation Once you have installed PyCAC , the application can be run from the install directory: $ python -m pycac -j From the launch window, select Create Input File to access the CAC job creator. A CAC input script is generated, and a local project folder containing the necessary files to run a CAC job is created. Click Next once the appropriate fields are filled, and correct any errors indicated. One can elect to set up parametric study of select commands, and choose to only build the folder on the local machine for direct runs , or submit the job to a performance computing cluster, e.g., those on NSF XSEDE . Security concerns The open-source and highly-vetted Python implementation of the SSH2 protocol, paramiko is used to handle secure connections with the cluster.","title":"Project creation"},{"location":"chapter-4/create/#pycac-project-creation","text":"Once you have installed PyCAC , the application can be run from the install directory: $ python -m pycac -j From the launch window, select Create Input File to access the CAC job creator. A CAC input script is generated, and a local project folder containing the necessary files to run a CAC job is created. Click Next once the appropriate fields are filled, and correct any errors indicated. One can elect to set up parametric study of select commands, and choose to only build the folder on the local machine for direct runs , or submit the job to a performance computing cluster, e.g., those on NSF XSEDE .","title":"PyCAC project creation"},{"location":"chapter-4/create/#security-concerns","text":"The open-source and highly-vetted Python implementation of the SSH2 protocol, paramiko is used to handle secure connections with the cluster.","title":"Security concerns"},{"location":"chapter-4/download/","text":"Results download Start the main GUI application $ python -m pycac -j Select Download Project Results and proceed to the next panel. Choose the desired download location for project results. Choose one or more Project Name(s) to download. Note that only jobs submitted through PyCAC will appear in the dropdown options; however one can specify a known cluster directory by selecting Other VTK to dump conversion To save space on the cluster, the CAC simulator only produces VTK files. One can elect to convert these VTK to LAMMPS-style dump files that can be visualized by atomistic model viewers and/or read by LAMMPS directly to carry out equivalent fully-resolved atomistic simulations. By default, the convertor will use the VTK file boundaries, but custom boundaries can be defined. Please see the fortran convertor if built-in conversion fails.","title":"Download results"},{"location":"chapter-4/download/#results-download","text":"Start the main GUI application $ python -m pycac -j Select Download Project Results and proceed to the next panel. Choose the desired download location for project results. Choose one or more Project Name(s) to download. Note that only jobs submitted through PyCAC will appear in the dropdown options; however one can specify a known cluster directory by selecting Other","title":"Results download"},{"location":"chapter-4/download/#vtk-to-dump-conversion","text":"To save space on the cluster, the CAC simulator only produces VTK files. One can elect to convert these VTK to LAMMPS-style dump files that can be visualized by atomistic model viewers and/or read by LAMMPS directly to carry out equivalent fully-resolved atomistic simulations. By default, the convertor will use the VTK file boundaries, but custom boundaries can be defined. Please see the fortran convertor if built-in conversion fails.","title":"VTK to dump conversion"},{"location":"chapter-4/installation/","text":"Installing PyCAC Python version requirement The PyCAC Graphical user interface (GUI) is written and tested on Python 3.6.5 , but is compatible with newer versions when available. To check the installed version on your system, from the command line: $ python --version Download and install PyCAC may be installed directly from PyPi using pip: $ pip install pycac If you downloaded a PyCAC release from the GitHub , replacing V.v.v with the version number indicated in the filenames: $ pip install pycac-V.v.v-none-any.whl OR $ pip install pycac-V.v.v.tar.gz Configure Once installed, PyCAC needs to be configured to communicate with the compute cluster. This will also install the CAC simulator to the cluster: $ python -m pycac --configure Please ensure that the correct workload manager is selected in this step. PyCAC may now be used to create new CAC jobs.","title":"Installation"},{"location":"chapter-4/installation/#installing-pycac","text":"","title":"Installing PyCAC"},{"location":"chapter-4/installation/#python-version-requirement","text":"The PyCAC Graphical user interface (GUI) is written and tested on Python 3.6.5 , but is compatible with newer versions when available. To check the installed version on your system, from the command line: $ python --version","title":"Python version requirement"},{"location":"chapter-4/installation/#download-and-install","text":"PyCAC may be installed directly from PyPi using pip: $ pip install pycac If you downloaded a PyCAC release from the GitHub , replacing V.v.v with the version number indicated in the filenames: $ pip install pycac-V.v.v-none-any.whl OR $ pip install pycac-V.v.v.tar.gz","title":"Download and install"},{"location":"chapter-4/installation/#configure","text":"Once installed, PyCAC needs to be configured to communicate with the compute cluster. This will also install the CAC simulator to the cluster: $ python -m pycac --configure Please ensure that the correct workload manager is selected in this step. PyCAC may now be used to create new CAC jobs.","title":"Configure"},{"location":"chapter-4/parameterization/","text":"Parameteric study PyCAC facilitates parametric study of select variables in CAC simulations. From the job submission window, click + to add a new parameterization, and select the desired command and available values from the dropdown menus. Fill in desired parameters for Increase and Number of Steps . Single-value parameters As an example, if we choose to parameterize the command grain_dir overlap , with Increase = 5.0 and Number of Steps = 10\" . Initially the command in the input file reads: grain_dir 2 0.0 10 additional simulation folders will be created, increasing the base value of overlap to 5.0 from 0.0 . The lines in the corresponding input scripts would change as follows: grain_dir 2 0.5 grain_dir 2 1.0 ... grain_dir 2 5.0 Vector-value parameters If the command to be parameterized is vector-valued, for example in grain orientations defined in grain_mat , then Increase should similarly be a vector [di, dj, dk] . The text field will indicate if this special format is required. Multiple parameterizations Multiple parameterizations in one project can be declared. If the number of steps are N and M for the first and second parameterizations, respectively, (N+1)x(M+1) total simulations will be generated.","title":"Parametric study"},{"location":"chapter-4/parameterization/#parameteric-study","text":"PyCAC facilitates parametric study of select variables in CAC simulations. From the job submission window, click + to add a new parameterization, and select the desired command and available values from the dropdown menus. Fill in desired parameters for Increase and Number of Steps .","title":"Parameteric study"},{"location":"chapter-4/parameterization/#single-value-parameters","text":"As an example, if we choose to parameterize the command grain_dir overlap , with Increase = 5.0 and Number of Steps = 10\" . Initially the command in the input file reads: grain_dir 2 0.0 10 additional simulation folders will be created, increasing the base value of overlap to 5.0 from 0.0 . The lines in the corresponding input scripts would change as follows: grain_dir 2 0.5 grain_dir 2 1.0 ... grain_dir 2 5.0","title":"Single-value parameters"},{"location":"chapter-4/parameterization/#vector-value-parameters","text":"If the command to be parameterized is vector-valued, for example in grain orientations defined in grain_mat , then Increase should similarly be a vector [di, dj, dk] . The text field will indicate if this special format is required.","title":"Vector-value parameters"},{"location":"chapter-4/parameterization/#multiple-parameterizations","text":"Multiple parameterizations in one project can be declared. If the number of steps are N and M for the first and second parameterizations, respectively, (N+1)x(M+1) total simulations will be generated.","title":"Multiple parameterizations"},{"location":"chapter-4/upload/","text":"Existing project upload Start the main GUI application $ python -m pycac -j Select Submit Job and find the project folder to upload. This should follow the format folder created using the job creation tool , consisting of a project folder, and self-contained sub-folders of individual runs as follows: projectname/ Run1/ input.in potential files (*.tab or *.lj) restart files(optional) Run2/ .... The existing values will be validated, and one can adjust the values if desired. Job submission and parameterization proceeds as in the job creation mode Note that any parameterizations defined here will create simulation subdirectories in addition to the ones existing in the project folder.","title":"Existing project upload"},{"location":"chapter-4/upload/#existing-project-upload","text":"Start the main GUI application $ python -m pycac -j Select Submit Job and find the project folder to upload. This should follow the format folder created using the job creation tool , consisting of a project folder, and self-contained sub-folders of individual runs as follows: projectname/ Run1/ input.in potential files (*.tab or *.lj) restart files(optional) Run2/ .... The existing values will be validated, and one can adjust the values if desired. Job submission and parameterization proceeds as in the job creation mode Note that any parameterizations defined here will create simulation subdirectories in addition to the ones existing in the project folder.","title":"Existing project upload"},{"location":"chapter-5/","text":"Command syntax This chapter describes how the commands that are used to define a CAC simulation are formatted in a CAC input script cac.in . In a CAC simulation, default settings for some commands are first established by defaults.f90 , then the entire cac.in is read to override some of the default settings: (i) a blank line or a line with the \"#\" character in column one (a comment line) is discarded, and (ii) each command should contain no more than 200 characters. Subsequently, input_checker.f90 is run to check whether all commands that do not have default settings are provided in cac.in . In preparing cac.in , it is important to follow the syntax and to distinguish between an interger and a real number, e.g., a real number must be written as 2. or 2.0 , instead of 2 . The sequence of the commands in cac.in does not matter, except for the modify , group , fix , and cal commands, in which case extra commands that (i) appear later and (ii) exceed the numbers in modify_number , new_group_number , fix_number , and cal_number , respectively, will be ignored. For example, if cal_number = 2 , the last cal command below will be ignored: cal first_group energy cal another_group force cal last_group stress During the CAC simulation, the user may get a self-explanatory error message, followed by termination of the program by: call mpi_abort(mpi_comm_world, 1, ierr) if something is potentially wrong or a warning message. When boolean_restart = t , the elements/nodes/atoms are read from the cac_in.restart file, in which case all commands in the Simulation Cell category below become irrelevant; otherwise, the simulation cell is built from scratch. Below is a list of all 34 CAC commands, grouped by category. Simulation Cell boundary , box_dir , grain_dir , grain_mat , grain_move , grain_num , modify_num , modify , subdomain , unit_num , unit_type , zigzag Materials lattice , mass , potential Settings cal , constrain , dump , dynamics , element , group_num , group , limit , minimize , neighbor , simulator , temperature Actions deform , fix , refine , restart , run Miscellanies convert , debug","title":"Command Syntax"},{"location":"chapter-5/#command-syntax","text":"This chapter describes how the commands that are used to define a CAC simulation are formatted in a CAC input script cac.in . In a CAC simulation, default settings for some commands are first established by defaults.f90 , then the entire cac.in is read to override some of the default settings: (i) a blank line or a line with the \"#\" character in column one (a comment line) is discarded, and (ii) each command should contain no more than 200 characters. Subsequently, input_checker.f90 is run to check whether all commands that do not have default settings are provided in cac.in . In preparing cac.in , it is important to follow the syntax and to distinguish between an interger and a real number, e.g., a real number must be written as 2. or 2.0 , instead of 2 . The sequence of the commands in cac.in does not matter, except for the modify , group , fix , and cal commands, in which case extra commands that (i) appear later and (ii) exceed the numbers in modify_number , new_group_number , fix_number , and cal_number , respectively, will be ignored. For example, if cal_number = 2 , the last cal command below will be ignored: cal first_group energy cal another_group force cal last_group stress During the CAC simulation, the user may get a self-explanatory error message, followed by termination of the program by: call mpi_abort(mpi_comm_world, 1, ierr) if something is potentially wrong or a warning message. When boolean_restart = t , the elements/nodes/atoms are read from the cac_in.restart file, in which case all commands in the Simulation Cell category below become irrelevant; otherwise, the simulation cell is built from scratch. Below is a list of all 34 CAC commands, grouped by category. Simulation Cell boundary , box_dir , grain_dir , grain_mat , grain_move , grain_num , modify_num , modify , subdomain , unit_num , unit_type , zigzag Materials lattice , mass , potential Settings cal , constrain , dump , dynamics , element , group_num , group , limit , minimize , neighbor , simulator , temperature Actions deform , fix , refine , restart , run Miscellanies convert , debug","title":"Command syntax"},{"location":"chapter-5/boundary/","text":"Syntax boundary x y z x , y , z = p or s p is periodic s is non-periodic and shrink-wrapped Examples boundary p s s Description This command sets the boundary conditions of the simulation cell along the x , y , and z directions. Along each axis, the same condition is applied to both the lower and upper faces of the cell. p sets periodic boundary conditions (PBCs). The nodes/atoms interact across the boundary and can exit one end of the cell and re-enter the other end. For more information of the PBCs in the coarse-grained domain, read chapter 3 of Shuozhi Xu's Ph.D. dissertation . s sets non-periodic boundary conditions, where nodes/atoms do not interact across the boundary and do not move from one side of the cell to the other. The positions of both faces are set so as to encompass the nodes/atoms in that dimension, no matter how far they move. Under neither boundary condition will any nodes/atoms be lost during a CAC simulation. Related commands When p is set along a certain direction, the corresponding zigzag is set to f . In other words, a boundary has to be flat to apply the PBCs. This command becomes irrelevant when boolean_restart = t , in which case the boundary conditions are read from the cac_in.restart file. Default boundary p p p","title":"boundary"},{"location":"chapter-5/boundary/#syntax","text":"boundary x y z x , y , z = p or s p is periodic s is non-periodic and shrink-wrapped","title":"Syntax"},{"location":"chapter-5/boundary/#examples","text":"boundary p s s","title":"Examples"},{"location":"chapter-5/boundary/#description","text":"This command sets the boundary conditions of the simulation cell along the x , y , and z directions. Along each axis, the same condition is applied to both the lower and upper faces of the cell. p sets periodic boundary conditions (PBCs). The nodes/atoms interact across the boundary and can exit one end of the cell and re-enter the other end. For more information of the PBCs in the coarse-grained domain, read chapter 3 of Shuozhi Xu's Ph.D. dissertation . s sets non-periodic boundary conditions, where nodes/atoms do not interact across the boundary and do not move from one side of the cell to the other. The positions of both faces are set so as to encompass the nodes/atoms in that dimension, no matter how far they move. Under neither boundary condition will any nodes/atoms be lost during a CAC simulation.","title":"Description"},{"location":"chapter-5/boundary/#related-commands","text":"When p is set along a certain direction, the corresponding zigzag is set to f . In other words, a boundary has to be flat to apply the PBCs. This command becomes irrelevant when boolean_restart = t , in which case the boundary conditions are read from the cac_in.restart file.","title":"Related commands"},{"location":"chapter-5/boundary/#default","text":"boundary p p p","title":"Default"},{"location":"chapter-5/box_dir/","text":"Syntax box_dir x i j k y i j k z i j k i , j , k = real number Examples box_dir x 1. 0. 0. y 0. 1. 0. z 0. 0. 1. box_dir x 1. 0. 0. y 0. 0.94281 -0.33333 z 0. 0. 1. box_dir x 1. 0. 0. y 0. 0.49237 0.87039 z 0. 0. 1. Description This command sets the orientation of the subdomain interfaces, including the grain boundary (GB) plane and the atomistic/coarse-grained domain interface, with respect to the simulation cell when there is more than one grain, i.e., grain_num > 1. When grain_num = 1, this command does not take effect. Assume that direction = 2 , i.e., the grains are stacked along the y direction, the first example results in a GB plane normal to the y axis; the second example results in a GB plane inclined with respect to the y axis, as shown in the figure below. The [ ijk ] vector here is similar to those in the group and modify commands. In the literature, this command was used to create the \\Sigma 3\\{111\\} \\Sigma 3\\{111\\} coherent twin boundary in Fig. 1 of Xu et al. 2016 and Fig. 1(a) of Xu et al. 2017 and the \\Sigma 11\\{113\\} \\Sigma 11\\{113\\} symmetric tilt grain boundary in Fig. 1(b) of Xu et al. 2017 . Related commands As opposed to the grain_mat command whose orientations are for the lattice, the orientations in this command are with respect to the simulation cell. One may use the convert command to convert the crystallographic orientation to the simulation cell-based orientation. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the subdomain information. Related files model_init.f90 , among many Default box_dir x 1. 0. 0. y 0. 1. 0. z 0. 0. 1.","title":"box_dir"},{"location":"chapter-5/box_dir/#syntax","text":"box_dir x i j k y i j k z i j k i , j , k = real number","title":"Syntax"},{"location":"chapter-5/box_dir/#examples","text":"box_dir x 1. 0. 0. y 0. 1. 0. z 0. 0. 1. box_dir x 1. 0. 0. y 0. 0.94281 -0.33333 z 0. 0. 1. box_dir x 1. 0. 0. y 0. 0.49237 0.87039 z 0. 0. 1.","title":"Examples"},{"location":"chapter-5/box_dir/#description","text":"This command sets the orientation of the subdomain interfaces, including the grain boundary (GB) plane and the atomistic/coarse-grained domain interface, with respect to the simulation cell when there is more than one grain, i.e., grain_num > 1. When grain_num = 1, this command does not take effect. Assume that direction = 2 , i.e., the grains are stacked along the y direction, the first example results in a GB plane normal to the y axis; the second example results in a GB plane inclined with respect to the y axis, as shown in the figure below. The [ ijk ] vector here is similar to those in the group and modify commands. In the literature, this command was used to create the \\Sigma 3\\{111\\} \\Sigma 3\\{111\\} coherent twin boundary in Fig. 1 of Xu et al. 2016 and Fig. 1(a) of Xu et al. 2017 and the \\Sigma 11\\{113\\} \\Sigma 11\\{113\\} symmetric tilt grain boundary in Fig. 1(b) of Xu et al. 2017 .","title":"Description"},{"location":"chapter-5/box_dir/#related-commands","text":"As opposed to the grain_mat command whose orientations are for the lattice, the orientations in this command are with respect to the simulation cell. One may use the convert command to convert the crystallographic orientation to the simulation cell-based orientation. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the subdomain information.","title":"Related commands"},{"location":"chapter-5/box_dir/#related-files","text":"model_init.f90 , among many","title":"Related files"},{"location":"chapter-5/box_dir/#default","text":"box_dir x 1. 0. 0. y 0. 1. 0. z 0. 0. 1.","title":"Default"},{"location":"chapter-5/cal/","text":"Syntax cal group_name cal_variable group_name = a string (length <= 30) cal_variable = energy or force or stress Examples cal green_cone force cal small_sphere stress Description This commands calculates certain quantities associated with new groups and/or restart groups. The group_name must match that of one of these groups. energy is the total potential energy in a group divided by the total number of nodes and atoms in the group. It is a scalar. force and stress are the total force and stress in a group, respectively. force is a 3\\times 1 3\\times 1 vector while stress is a 3\\times 3 3\\times 3 tensor. Results of this command are written to group_cal_# with a frequency of reduce_freq , where # is the ID of calculation. For stress , a 3\\times 3 3\\times 3 strain tensor of the simulation box is appended right after the stress tensor. Related commands There cannot be fewer cal commands than cal_number , which should not be larger than new_group_number + restart_group_number . When there are more cal commands in cac.in than cal_number , those appearing later will be ignored. Related files calculation.f90 and group_cal.f90 Default None.","title":"cal"},{"location":"chapter-5/cal/#syntax","text":"cal group_name cal_variable group_name = a string (length <= 30) cal_variable = energy or force or stress","title":"Syntax"},{"location":"chapter-5/cal/#examples","text":"cal green_cone force cal small_sphere stress","title":"Examples"},{"location":"chapter-5/cal/#description","text":"This commands calculates certain quantities associated with new groups and/or restart groups. The group_name must match that of one of these groups. energy is the total potential energy in a group divided by the total number of nodes and atoms in the group. It is a scalar. force and stress are the total force and stress in a group, respectively. force is a 3\\times 1 3\\times 1 vector while stress is a 3\\times 3 3\\times 3 tensor. Results of this command are written to group_cal_# with a frequency of reduce_freq , where # is the ID of calculation. For stress , a 3\\times 3 3\\times 3 strain tensor of the simulation box is appended right after the stress tensor.","title":"Description"},{"location":"chapter-5/cal/#related-commands","text":"There cannot be fewer cal commands than cal_number , which should not be larger than new_group_number + restart_group_number . When there are more cal commands in cac.in than cal_number , those appearing later will be ignored.","title":"Related commands"},{"location":"chapter-5/cal/#related-files","text":"calculation.f90 and group_cal.f90","title":"Related files"},{"location":"chapter-5/cal/#default","text":"None.","title":"Default"},{"location":"chapter-5/constrain/","text":"Syntax constrain boolean i j k boolean = t or f t is true f is faulse i , j , k = real number Examples constrain f 1. 1. 0. constrain t 0. 0. 1. Description The command decides whether and how a force constraint is added to the system. When boolean is t , the equivalent nodal/atomic force vector is projected onto the [ ijk ] direction such that they can only move along that direction, either in dynamic or quasistatic CAC simulations. The only exception is that the external force applied by the fix command and the random force \\Theta(t) \\Theta(t) in Langevin dynamics can be along any direction. Note that the direction is with respect to the simulation cell. For example, the second example projects the force vector onto the z axis of the simulation cell. Related commands None. Related files update_force.f90 Default constrain f 0. 0. 1.","title":"constrain"},{"location":"chapter-5/constrain/#syntax","text":"constrain boolean i j k boolean = t or f t is true f is faulse i , j , k = real number","title":"Syntax"},{"location":"chapter-5/constrain/#examples","text":"constrain f 1. 1. 0. constrain t 0. 0. 1.","title":"Examples"},{"location":"chapter-5/constrain/#description","text":"The command decides whether and how a force constraint is added to the system. When boolean is t , the equivalent nodal/atomic force vector is projected onto the [ ijk ] direction such that they can only move along that direction, either in dynamic or quasistatic CAC simulations. The only exception is that the external force applied by the fix command and the random force \\Theta(t) \\Theta(t) in Langevin dynamics can be along any direction. Note that the direction is with respect to the simulation cell. For example, the second example projects the force vector onto the z axis of the simulation cell.","title":"Description"},{"location":"chapter-5/constrain/#related-commands","text":"None.","title":"Related commands"},{"location":"chapter-5/constrain/#related-files","text":"update_force.f90","title":"Related files"},{"location":"chapter-5/constrain/#default","text":"constrain f 0. 0. 1.","title":"Default"},{"location":"chapter-5/convert/","text":"Syntax convert i j k i , j , k = real number Examples convert -1. 1. 2. convert 1. -1. 0. Description This command converts the crystallographic orientation [ i``j``k ] of each grain to the orientation with respect to the simulation cell [ i'``j'``k' ]. Results of this conversion will be shown on the screen as Converted box direction of grain # is i' j' k' where the positive integer # is the grain ID. For example, if the lattice orientation of the second grain along the x axis is [211], this command will convert the [211] crystallographic orientation into [100] and output Converted box direction of grain 2 is 1.0000 0.0000 0.0000 Related commands This command is useful when the user has a set of crystallographic orientations in mind and wants to find the orientation with respect to the simulation cell, e.g., to be used in the box_dir command. Related files convert_direction.f90 Default convert 0. 0. 0.","title":"convert"},{"location":"chapter-5/convert/#syntax","text":"convert i j k i , j , k = real number","title":"Syntax"},{"location":"chapter-5/convert/#examples","text":"convert -1. 1. 2. convert 1. -1. 0.","title":"Examples"},{"location":"chapter-5/convert/#description","text":"This command converts the crystallographic orientation [ i``j``k ] of each grain to the orientation with respect to the simulation cell [ i'``j'``k' ]. Results of this conversion will be shown on the screen as Converted box direction of grain # is i' j' k' where the positive integer # is the grain ID. For example, if the lattice orientation of the second grain along the x axis is [211], this command will convert the [211] crystallographic orientation into [100] and output Converted box direction of grain 2 is 1.0000 0.0000 0.0000","title":"Description"},{"location":"chapter-5/convert/#related-commands","text":"This command is useful when the user has a set of crystallographic orientations in mind and wants to find the orientation with respect to the simulation cell, e.g., to be used in the box_dir command.","title":"Related commands"},{"location":"chapter-5/convert/#related-files","text":"convert_direction.f90","title":"Related files"},{"location":"chapter-5/convert/#default","text":"convert 0. 0. 0.","title":"Default"},{"location":"chapter-5/debug/","text":"Syntax debug boolean_debug boolean_mpi boolean_debug , boolean_mpi = t or f t is true f is faulse Examples debug t f debug t t Description This command generates a writable file named debug for debugging purpose. The file is created only when boolean_debug = t ; the unit number is 13. The user can then write whatever he/she wants to the debug file using unit number 13, i.e., write(13, format) output When boolean_mpi = t , all processors have access to the debug file, otherwise only the root does. Related commands None. Related files debug_init.f90 Default debug f f","title":"debug"},{"location":"chapter-5/debug/#syntax","text":"debug boolean_debug boolean_mpi boolean_debug , boolean_mpi = t or f t is true f is faulse","title":"Syntax"},{"location":"chapter-5/debug/#examples","text":"debug t f debug t t","title":"Examples"},{"location":"chapter-5/debug/#description","text":"This command generates a writable file named debug for debugging purpose. The file is created only when boolean_debug = t ; the unit number is 13. The user can then write whatever he/she wants to the debug file using unit number 13, i.e., write(13, format) output When boolean_mpi = t , all processors have access to the debug file, otherwise only the root does.","title":"Description"},{"location":"chapter-5/debug/#related-commands","text":"None.","title":"Related commands"},{"location":"chapter-5/debug/#related-files","text":"debug_init.f90","title":"Related files"},{"location":"chapter-5/debug/#default","text":"debug f f","title":"Default"},{"location":"chapter-5/deform/","text":"Syntax deform boolean_def def_number {ij boolean_cg boolean_at def_rate stress_l stress_u flip_frequency} time time_start time_always_flip time_end boolean_def , boolean_cg , boolean_at = t or f t is true f is false def_number = non-negative integer (<= 9) ij = xx or yy or zz or xy or yz or yz or zy or xz or zx def_rate = real number stress_l , stress_u = positive real number flip_frequency = positive integer time_start , time_always_flip , time_end = non-negative integer Examples deform t 1 {zx t t 0.05 0.6 0.7 10} time 500 1000 2500 deform t 2 {xx t f 0.01 1. 1.2 20} {yz f t 0.02 0.8 0.9 30} time 400 600 1900 Description This command sets up the strain-controlled or stress-controlled homogeneous deformation of the simulation cell. Note that the curly brackets { and } in the syntax/examples are to separate different deformation modes, the number of which is def_number ; all brackets should not be included in preparing cac.in . The deformation is applied only if boolean_def = t . The coarse-grained and atomistic domains are deformed only if boolean_cg and boolean_at are t , respectively. def_number sets the number of superimposed deformation modes. ij decides each deformation mode, i.e., how the strain is applied. Following the standard indexes \\epsilon_{ij} \\epsilon_{ij} in continuum mechanics, i and j are the face on which and the direction along which the strain is applied. When i and j are the same, a uniaxial strain is applied; otherwise, a shear strain is applied. def_rate is the strain applied at each step, in units of time_step . stress_l and stress_u are the lower and upper bounds of the stress tensor component (designated by ij ) of the simulation cell, respectively, in GPa. In CAC simulations, all stress components are usually small at the beginning. Subject to the strain, most stress tensor components increase in magnitude until one of them is higher than the corresponding stress_u , at which point the strain rate tensor changes sign, i.e., the deformation is reversed but each ij remains unchanged. Subject to the newly reversed strain, most stress tensor components decrease until one of them is lower than the corresponding stress_l , in which case the strain rate tensor changes sign again, i.e., the deformation is applied as the initial setting. Whether the stress component is out of bounds is monitored not at every step, but at every flip_frequency step. The deformation begins when the simulation step equals time_start and stops when it exceeds time_end . When (i) the simulation step is larger than time_always_flip and (ii) the simulation step does not exceed time_end and (iii) the strain rate tensor did not change sign previously, the strain rate tensor changes sign at every step, regardless of the stress bounds defined by stress_l and stress_u . This is used, e.g., to keep a quasi-constant strain while the nodes and atoms adjust their positions in dynamic or quasistatic equilibrium. To disable this option, the user may set time_always_flip to be larger than time_end . Related commands Groups defined by the group command may be homogeneously deformed along with the simulation cell, depending on the value of boolean_def set in the fix command. Related files deform_init.f90 and deform_box.f90 Default deform f 1 xx f f 0. 0. 0. 1 time 0 0 0","title":"deform"},{"location":"chapter-5/deform/#syntax","text":"deform boolean_def def_number {ij boolean_cg boolean_at def_rate stress_l stress_u flip_frequency} time time_start time_always_flip time_end boolean_def , boolean_cg , boolean_at = t or f t is true f is false def_number = non-negative integer (<= 9) ij = xx or yy or zz or xy or yz or yz or zy or xz or zx def_rate = real number stress_l , stress_u = positive real number flip_frequency = positive integer time_start , time_always_flip , time_end = non-negative integer","title":"Syntax"},{"location":"chapter-5/deform/#examples","text":"deform t 1 {zx t t 0.05 0.6 0.7 10} time 500 1000 2500 deform t 2 {xx t f 0.01 1. 1.2 20} {yz f t 0.02 0.8 0.9 30} time 400 600 1900","title":"Examples"},{"location":"chapter-5/deform/#description","text":"This command sets up the strain-controlled or stress-controlled homogeneous deformation of the simulation cell. Note that the curly brackets { and } in the syntax/examples are to separate different deformation modes, the number of which is def_number ; all brackets should not be included in preparing cac.in . The deformation is applied only if boolean_def = t . The coarse-grained and atomistic domains are deformed only if boolean_cg and boolean_at are t , respectively. def_number sets the number of superimposed deformation modes. ij decides each deformation mode, i.e., how the strain is applied. Following the standard indexes \\epsilon_{ij} \\epsilon_{ij} in continuum mechanics, i and j are the face on which and the direction along which the strain is applied. When i and j are the same, a uniaxial strain is applied; otherwise, a shear strain is applied. def_rate is the strain applied at each step, in units of time_step . stress_l and stress_u are the lower and upper bounds of the stress tensor component (designated by ij ) of the simulation cell, respectively, in GPa. In CAC simulations, all stress components are usually small at the beginning. Subject to the strain, most stress tensor components increase in magnitude until one of them is higher than the corresponding stress_u , at which point the strain rate tensor changes sign, i.e., the deformation is reversed but each ij remains unchanged. Subject to the newly reversed strain, most stress tensor components decrease until one of them is lower than the corresponding stress_l , in which case the strain rate tensor changes sign again, i.e., the deformation is applied as the initial setting. Whether the stress component is out of bounds is monitored not at every step, but at every flip_frequency step. The deformation begins when the simulation step equals time_start and stops when it exceeds time_end . When (i) the simulation step is larger than time_always_flip and (ii) the simulation step does not exceed time_end and (iii) the strain rate tensor did not change sign previously, the strain rate tensor changes sign at every step, regardless of the stress bounds defined by stress_l and stress_u . This is used, e.g., to keep a quasi-constant strain while the nodes and atoms adjust their positions in dynamic or quasistatic equilibrium. To disable this option, the user may set time_always_flip to be larger than time_end .","title":"Description"},{"location":"chapter-5/deform/#related-commands","text":"Groups defined by the group command may be homogeneously deformed along with the simulation cell, depending on the value of boolean_def set in the fix command.","title":"Related commands"},{"location":"chapter-5/deform/#related-files","text":"deform_init.f90 and deform_box.f90","title":"Related files"},{"location":"chapter-5/deform/#default","text":"deform f 1 xx f f 0. 0. 0. 1 time 0 0 0","title":"Default"},{"location":"chapter-5/dump/","text":"Syntax dump output_freq reduce_freq restart_freq log_freq output_freq , reduce_freq , restart_freq , log_freq = positive integer Examples dump 500 300 1000 10 Description This command sets the frequency with which the output is performed. For example, when a certain frequency is 100, the corresponding output is conducted when the total step is divisible by 100. output_freq sets the frequency with which the dump.# files (readable by OVITO ) and the *.vtk files (readable by ParaView ) are written to the disk system. The user may then post-process these files for visualization purpose and for further analysis. reduce_freq sets the frequency with which certain quantities are written to group_cal_# (when cal_number > 0) and cac.log by root , which MPI_Reduce s relevant information from other processors. restart_freq sets the frequency with which the cac_out_#.restart files are written to the disk system. These files can be read to restart simulations. If the total number of groups > 0, a series of group_out_*_#.id files are also created. These files can be read to provide restart groups . log_freq sets the frequency with which one line is written to the cac.log file and the screen to monitor the simulation progress. Related commands None. Related files dump_init.f90 and dump.f90 Default dump 1000 1000 5000 50","title":"dump"},{"location":"chapter-5/dump/#syntax","text":"dump output_freq reduce_freq restart_freq log_freq output_freq , reduce_freq , restart_freq , log_freq = positive integer","title":"Syntax"},{"location":"chapter-5/dump/#examples","text":"dump 500 300 1000 10","title":"Examples"},{"location":"chapter-5/dump/#description","text":"This command sets the frequency with which the output is performed. For example, when a certain frequency is 100, the corresponding output is conducted when the total step is divisible by 100. output_freq sets the frequency with which the dump.# files (readable by OVITO ) and the *.vtk files (readable by ParaView ) are written to the disk system. The user may then post-process these files for visualization purpose and for further analysis. reduce_freq sets the frequency with which certain quantities are written to group_cal_# (when cal_number > 0) and cac.log by root , which MPI_Reduce s relevant information from other processors. restart_freq sets the frequency with which the cac_out_#.restart files are written to the disk system. These files can be read to restart simulations. If the total number of groups > 0, a series of group_out_*_#.id files are also created. These files can be read to provide restart groups . log_freq sets the frequency with which one line is written to the cac.log file and the screen to monitor the simulation progress.","title":"Description"},{"location":"chapter-5/dump/#related-commands","text":"None.","title":"Related commands"},{"location":"chapter-5/dump/#related-files","text":"dump_init.f90 and dump.f90","title":"Related files"},{"location":"chapter-5/dump/#default","text":"dump 1000 1000 5000 50","title":"Default"},{"location":"chapter-5/dynamics/","text":"Syntax dynamics dyn_style energy_min_freq damping_coefficient dyn_style = ld or qd or vv ld is Langevin dynamics qd is quenched dynamics vv is Velocity Verlet energy_min_freq = positive integer damping_coefficient = positive real number Examples dynamics ld 300 1. dynamics qd 500 5. Description This command sets the style of the dynamic run in CAC simulations. When dyn_style = ld , the Langevin dynamics is performed, i.e., m \\ddot{\\mathbf{R}} = \\mathbf{F} - \\gamma m\\dot{\\mathbf{R}} + \\Theta(t) m \\ddot{\\mathbf{R}} = \\mathbf{F} - \\gamma m\\dot{\\mathbf{R}} + \\Theta(t) where m m is the normalized lumped mass or the atomic mass, \\mathbf{R} \\mathbf{R} is the nodal/atomic position, \\mathbf{F} \\mathbf{F} is the equivalent nodal/atomic force, \\gamma \\gamma is the damping_coefficient in ps ^{-1} ^{-1} , and t t is the time in ps. The Velocity Verlet form is employed to solve the equations of motion, as given in Eqs. 1-3 in Xu et al., 2016 . The velocity \\dot{\\mathbf{R}} \\dot{\\mathbf{R}} is updated in langevin_vel.f90 . The ld style is used to keep a constant temperature in CAC simulations by adding to the force \\mathbf{F} \\mathbf{F} a time-dependent Gaussian random variable \\Theta(t) \\Theta(t) with zero mean and variance of \\sqrt{2m\\gamma k_\\mathrm{B} T/\\Delta t} \\sqrt{2m\\gamma k_\\mathrm{B} T/\\Delta t} , where m m is the atomic mass, k_\\mathrm{B} k_\\mathrm{B} is the Boltzmann constant ( 8.6173324\\times 10^{-5} \\mathrm{eV/K} 8.6173324\\times 10^{-5} \\mathrm{eV/K} ), T T is the temperature in K, and \\Delta t \\Delta t is the time_step in ps. The random variable is calculated and added to the force in langevin_force.f90 . Note that when T = 0 T = 0 , the equation above reduces to m \\ddot{\\mathbf{R}} = \\mathbf{F} - \\gamma m\\dot{\\mathbf{R}} m \\ddot{\\mathbf{R}} = \\mathbf{F} - \\gamma m\\dot{\\mathbf{R}} which is the equation of motion in damped molecular dynamics. When dyn_style = qd , the quenched dynamics is performed, in which if the force and velocity point in opposite directions, the velocity is zeroed, i.e., \\mathrm{if}\\ \\dot{\\mathbf{R}} \\cdot \\mathbf{F} < 0, \\dot{\\mathbf{R}} = 0 \\mathrm{if}\\ \\dot{\\mathbf{R}} \\cdot \\mathbf{F} < 0, \\dot{\\mathbf{R}} = 0 otherwise, the velocity is projected along the direction of the force, such that only the component of velocity parallel to the force vector is used, i.e., \\mathrm{if}\\ \\dot{\\mathbf{R}} \\cdot \\mathbf{F} \\geq 0, \\dot{\\mathbf{R}} = \\frac{(\\dot{\\mathbf{R}} \\cdot \\mathbf{F})\\mathbf{F}}{|\\mathbf{F}|^2} \\mathrm{if}\\ \\dot{\\mathbf{R}} \\cdot \\mathbf{F} \\geq 0, \\dot{\\mathbf{R}} = \\frac{(\\dot{\\mathbf{R}} \\cdot \\mathbf{F})\\mathbf{F}}{|\\mathbf{F}|^2} Note that with the qd style, which was first used in Xu et al., 2016 , the temperature is considered 0 K or very nearly so. When dyn_style = vv , a dynamic simulation following m \\ddot{\\mathbf{R}} = \\mathbf{F} m \\ddot{\\mathbf{R}} = \\mathbf{F} is performed using the Velocity Verlet scheme. Note that the vv style cannot be used to keep a constant temperature and the qd style cannot be used to keep a finite temperature . When boolean = t , if the vv style is chosen and if, for a finite temperature , the qd style is chosen, the user will get a warning message. The energy_min_freq is the frequency with which the energy minimization is performed during a dynamic run. This is relevant only if simulator_style = hybrid . Related commands run and simulator . Related files dynamics_init.f90 , dynamics.f90 , langevin_dynamics.f90 , quenched_dynamics.f90 , hybrid.f90 , among many Default dynamics vv 500 1.","title":"dynamics"},{"location":"chapter-5/dynamics/#syntax","text":"dynamics dyn_style energy_min_freq damping_coefficient dyn_style = ld or qd or vv ld is Langevin dynamics qd is quenched dynamics vv is Velocity Verlet energy_min_freq = positive integer damping_coefficient = positive real number","title":"Syntax"},{"location":"chapter-5/dynamics/#examples","text":"dynamics ld 300 1. dynamics qd 500 5.","title":"Examples"},{"location":"chapter-5/dynamics/#description","text":"This command sets the style of the dynamic run in CAC simulations. When dyn_style = ld , the Langevin dynamics is performed, i.e., m \\ddot{\\mathbf{R}} = \\mathbf{F} - \\gamma m\\dot{\\mathbf{R}} + \\Theta(t) m \\ddot{\\mathbf{R}} = \\mathbf{F} - \\gamma m\\dot{\\mathbf{R}} + \\Theta(t) where m m is the normalized lumped mass or the atomic mass, \\mathbf{R} \\mathbf{R} is the nodal/atomic position, \\mathbf{F} \\mathbf{F} is the equivalent nodal/atomic force, \\gamma \\gamma is the damping_coefficient in ps ^{-1} ^{-1} , and t t is the time in ps. The Velocity Verlet form is employed to solve the equations of motion, as given in Eqs. 1-3 in Xu et al., 2016 . The velocity \\dot{\\mathbf{R}} \\dot{\\mathbf{R}} is updated in langevin_vel.f90 . The ld style is used to keep a constant temperature in CAC simulations by adding to the force \\mathbf{F} \\mathbf{F} a time-dependent Gaussian random variable \\Theta(t) \\Theta(t) with zero mean and variance of \\sqrt{2m\\gamma k_\\mathrm{B} T/\\Delta t} \\sqrt{2m\\gamma k_\\mathrm{B} T/\\Delta t} , where m m is the atomic mass, k_\\mathrm{B} k_\\mathrm{B} is the Boltzmann constant ( 8.6173324\\times 10^{-5} \\mathrm{eV/K} 8.6173324\\times 10^{-5} \\mathrm{eV/K} ), T T is the temperature in K, and \\Delta t \\Delta t is the time_step in ps. The random variable is calculated and added to the force in langevin_force.f90 . Note that when T = 0 T = 0 , the equation above reduces to m \\ddot{\\mathbf{R}} = \\mathbf{F} - \\gamma m\\dot{\\mathbf{R}} m \\ddot{\\mathbf{R}} = \\mathbf{F} - \\gamma m\\dot{\\mathbf{R}} which is the equation of motion in damped molecular dynamics. When dyn_style = qd , the quenched dynamics is performed, in which if the force and velocity point in opposite directions, the velocity is zeroed, i.e., \\mathrm{if}\\ \\dot{\\mathbf{R}} \\cdot \\mathbf{F} < 0, \\dot{\\mathbf{R}} = 0 \\mathrm{if}\\ \\dot{\\mathbf{R}} \\cdot \\mathbf{F} < 0, \\dot{\\mathbf{R}} = 0 otherwise, the velocity is projected along the direction of the force, such that only the component of velocity parallel to the force vector is used, i.e., \\mathrm{if}\\ \\dot{\\mathbf{R}} \\cdot \\mathbf{F} \\geq 0, \\dot{\\mathbf{R}} = \\frac{(\\dot{\\mathbf{R}} \\cdot \\mathbf{F})\\mathbf{F}}{|\\mathbf{F}|^2} \\mathrm{if}\\ \\dot{\\mathbf{R}} \\cdot \\mathbf{F} \\geq 0, \\dot{\\mathbf{R}} = \\frac{(\\dot{\\mathbf{R}} \\cdot \\mathbf{F})\\mathbf{F}}{|\\mathbf{F}|^2} Note that with the qd style, which was first used in Xu et al., 2016 , the temperature is considered 0 K or very nearly so. When dyn_style = vv , a dynamic simulation following m \\ddot{\\mathbf{R}} = \\mathbf{F} m \\ddot{\\mathbf{R}} = \\mathbf{F} is performed using the Velocity Verlet scheme. Note that the vv style cannot be used to keep a constant temperature and the qd style cannot be used to keep a finite temperature . When boolean = t , if the vv style is chosen and if, for a finite temperature , the qd style is chosen, the user will get a warning message. The energy_min_freq is the frequency with which the energy minimization is performed during a dynamic run. This is relevant only if simulator_style = hybrid .","title":"Description"},{"location":"chapter-5/dynamics/#related-commands","text":"run and simulator .","title":"Related commands"},{"location":"chapter-5/dynamics/#related-files","text":"dynamics_init.f90 , dynamics.f90 , langevin_dynamics.f90 , quenched_dynamics.f90 , hybrid.f90 , among many","title":"Related files"},{"location":"chapter-5/dynamics/#default","text":"dynamics vv 500 1.","title":"Default"},{"location":"chapter-5/element/","text":"Syntax element mass_matrix intpo_depth mass_matrix = lumped or consistent intpo_depth = 1 or 2 Examples element lumped 2 element consistent 1 Description This command sets the element type used in the finite element calculation in the coarse-grained domain. For mass_matrix , the lumped type approximates the mass of each element and distributes it to the nodes; the consistent type distributes the exact mass over the entire element. intpo_depth decides whether the first nearest neighbor (1NN) or the second nearest neighbor (2NN) elements are employed in the coarse-grained domain; their differences are illustrated in Fig. B26 of Xu et al., 2015 . Related commands The atomic mass is provided in the mass command. Related files mass_matrix.f90 , integration_point.f90 , and update_equiv.f90 Default element lumped 2","title":"element"},{"location":"chapter-5/element/#syntax","text":"element mass_matrix intpo_depth mass_matrix = lumped or consistent intpo_depth = 1 or 2","title":"Syntax"},{"location":"chapter-5/element/#examples","text":"element lumped 2 element consistent 1","title":"Examples"},{"location":"chapter-5/element/#description","text":"This command sets the element type used in the finite element calculation in the coarse-grained domain. For mass_matrix , the lumped type approximates the mass of each element and distributes it to the nodes; the consistent type distributes the exact mass over the entire element. intpo_depth decides whether the first nearest neighbor (1NN) or the second nearest neighbor (2NN) elements are employed in the coarse-grained domain; their differences are illustrated in Fig. B26 of Xu et al., 2015 .","title":"Description"},{"location":"chapter-5/element/#related-commands","text":"The atomic mass is provided in the mass command.","title":"Related commands"},{"location":"chapter-5/element/#related-files","text":"mass_matrix.f90 , integration_point.f90 , and update_equiv.f90","title":"Related files"},{"location":"chapter-5/element/#default","text":"element lumped 2","title":"Default"},{"location":"chapter-5/fix/","text":"Syntax fix group_name boolean_release boolean_def assign_style assign_x assign_y assign_z disp_lim time time_start time_end boolean_grad grad_ref_axis grad_assign_axis grad_ref_l grad_ref_u group_name = a string (length <= 30) boolean_release , boolean_def , boolean_grad = t or f t is true f is false assign_style = disp or force assign_x , assign_y , assign_z = real number or null disp_lim = non-negative real number time_start , time_end = non-negative integer grad_ref_axis , grad_assign_axis = 1 or 2 or 3 grad_ref_l , grad_ref_u = real number or inf Examples fix big_sphere t t disp 0. null 0. 5. time 0 2500 f fix blue_cone t t disp 5. 0. 0. 10. time 0 2500 t 2 1 50. 60. fix top_box t t force 0. 1. 0. 3. time 0 2500 t 3 2 100. 10. Description This command applies displacements and/or forces to new groups and restart groups, the numbers of which are provided in the group_num command. The number of fix commands is fix_number . The new groups are created by first providing the elements/nodes/atoms information in the group command, while the same information for the restart groups, which are introduced when restart_group_number > 0, is read from group_in_*.id , where * is a positive integer starting from new_group_number + 1. When the groups are at the simulation cell boundaries, this command is useful in applying displacement, traction, or mixed boundary conditions. group_name must match one of the new groups or restart groups . All in this command take effect only when time_start < simulation step < time_end , unless stated otherwise. when simulation step > time_end , the group is no longer assigned a displacement/force if boolean_release = t ; the group is assigned a displacement/force vector [ assign_x , assign_y , assign_z ] whose non- null components are zeroed. When boolean_def = t , the group is deformed along with the simulation box . The deformation-induced displacement is added on top of the assigned displacement/force. assign_style = disp or force , meaning that a displacement or force vector [ assign_x , assign_y , assign_z ], in Angstrom/ time_step or eV/Angstrom, is applied to all nodes/atoms in the group at each simulation step , after their interatomic potential -based displacement/force is discarded. If any component of the displacement/force vector is null , no displacement/force is assigned to this component. In the first example, big_sphere is fixed along the x x and z z directions but not along the y y direction. disp_lim is the upper bound of the magnitude of the total group displacement, in units of lattice_constant . If the total displacement magnitude (in Angstrom instead of in Angstrom/ time_step ) is larger than disp_lim , the displacement vector is zeroed, regardless of whether time_end is reached or what value boolean_release is. disp_lim is irrelevant when assign_style = force . However, it needs to be provided regardless. When boolean_grad = f , the same displacement/force vector [ assign_x , assign_y , assign_z ] is assigned to all nodes/atoms of the group; the following options, including grad_ref_axis , grad_assign_axis , grad_ref_l , and grad_ref_u , become irrelevant and do not need to provided. When boolean_grad = t , the displacement/force is assigned to the group gradiently, i.e., different elements/nodes/atoms in the group may have a different [ assign_x , assign_y , assign_z ] vector. The grad_assign_axis component of the displacement/force vector is linearly applied to the group based on the positions of elements/nodes/atoms along the grad_ref_axis direction. grad_ref_l and grad_ref_u are the bounds of the graded displacement/force, in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the grad_ref_axis direction, with inf referring to the lower ( grad_ref_l ) and upper ( grad_ref_u ) simulation cell boundaries. If grad_ref_l < grad_ref_u , the elements/nodes/atoms located at or below grad_ref_l are assigned a zero displacement/force vector, i.e., fixed; those located at or above grad_ref_u are assigned [ assign_x , assign_y , assign_z ]. If grad_ref_l > grad_ref_u , the elements/nodes/atoms located at or above grad_ref_l are assigned a zero displacement/force vector, i.e., fixed; those located at or below grad_ref_u are assigned [ assign_x , assign_y , assign_z ]. In any case, the elements/nodes/atoms located between grad_ref_l and grad_ref_u are assigned a vector whose grad_assign_axis component is linearly graded while the other two components remain the same with respect to [ assign_x , assign_y , assign_z ]. In the second example, the elements/nodes/atoms which are located below 50.0\\cdot\\vec{l'}_0[2] 50.0\\cdot\\vec{l'}_0[2] along the y axis (because grad_ref_axis = 2 ) are assigned a zero displacement vector; those located above 60.0\\cdot\\vec{l'}_0[2] 60.0\\cdot\\vec{l'}_0[2] along the y axis are assigned [ assign_x , assign_y , assign_z ]; those in between are assigned a linearly graded displacement vector whose x component (because grad_assign_axis = 1 ) is varied between zero and assign_x while its y and z components are assign_y and assign_z , respectively. In the third example, the elements/nodes/atoms which are located below 10.0\\cdot\\vec{l'}_0[3] 10.0\\cdot\\vec{l'}_0[3] along the z axis (because grad_ref_axis = 3 ) are assigned [ assign_x , assign_y , assign_z ]; those located above 100.0\\cdot\\vec{l'}_0[3] 100.0\\cdot\\vec{l'}_0[3] along the z axis are assigned a zero force vector; those in between are assigned a linearly graded force vector whose y component (because grad_assign_axis = 2 ) is varied between zero and assign_y while its x and z components are assign_x and assign_z , respectively. Note that for each group concerned in this command, the displacement and force vectors are added to relevant nodes/atoms after their interatomic potential-based displacement/force vectored are zeroed. In particular, the force, stress, and energy are zeroed if assign_style = disp ; the force, stress, and energy are replaced with those induced by this command if assign_style = force . In both cases, the velocity vectors are also zeroed in dynamic and hybrid CAC . In this sense, if the same atoms/nodes are included in multiple groups that are also concerned in this command, those appearing in the later fix commands will provail. For example, if a node is assigned a displacement vector in the first fix command, a force vector in the second fix command, and another force vector in the third fix command, the force vector in the last fix command will be imposed. As another example, if an atom is assigned a force vector in the fourth fix command, and a displacement vector in the fifth fix command, the force/stress/energy vector of that atom will be zeroed. To avoid unintended effects, users are advised to carefully check if the same nodes/atoms are involved in different fix commands. Related commands There cannot be fewer fix commands than fix_number , which should not be larger than new_group_number + restart_group_number . When there are more fix commands in cac.in than fix_number , those appearing later will be ignored. Note that all groups do not necessarily have corresponding fix command. The purpose of having a group that does not have a correpsonding fix command is to calculate certain mechanical properties, e.g., energy, force, and stress, of the nodes/atoms it contains. Related files fix.f90 , fix_displacement.f90 , and fix_force.f90 Default None.","title":"fix"},{"location":"chapter-5/fix/#syntax","text":"fix group_name boolean_release boolean_def assign_style assign_x assign_y assign_z disp_lim time time_start time_end boolean_grad grad_ref_axis grad_assign_axis grad_ref_l grad_ref_u group_name = a string (length <= 30) boolean_release , boolean_def , boolean_grad = t or f t is true f is false assign_style = disp or force assign_x , assign_y , assign_z = real number or null disp_lim = non-negative real number time_start , time_end = non-negative integer grad_ref_axis , grad_assign_axis = 1 or 2 or 3 grad_ref_l , grad_ref_u = real number or inf","title":"Syntax"},{"location":"chapter-5/fix/#examples","text":"fix big_sphere t t disp 0. null 0. 5. time 0 2500 f fix blue_cone t t disp 5. 0. 0. 10. time 0 2500 t 2 1 50. 60. fix top_box t t force 0. 1. 0. 3. time 0 2500 t 3 2 100. 10.","title":"Examples"},{"location":"chapter-5/fix/#description","text":"This command applies displacements and/or forces to new groups and restart groups, the numbers of which are provided in the group_num command. The number of fix commands is fix_number . The new groups are created by first providing the elements/nodes/atoms information in the group command, while the same information for the restart groups, which are introduced when restart_group_number > 0, is read from group_in_*.id , where * is a positive integer starting from new_group_number + 1. When the groups are at the simulation cell boundaries, this command is useful in applying displacement, traction, or mixed boundary conditions. group_name must match one of the new groups or restart groups . All in this command take effect only when time_start < simulation step < time_end , unless stated otherwise. when simulation step > time_end , the group is no longer assigned a displacement/force if boolean_release = t ; the group is assigned a displacement/force vector [ assign_x , assign_y , assign_z ] whose non- null components are zeroed. When boolean_def = t , the group is deformed along with the simulation box . The deformation-induced displacement is added on top of the assigned displacement/force. assign_style = disp or force , meaning that a displacement or force vector [ assign_x , assign_y , assign_z ], in Angstrom/ time_step or eV/Angstrom, is applied to all nodes/atoms in the group at each simulation step , after their interatomic potential -based displacement/force is discarded. If any component of the displacement/force vector is null , no displacement/force is assigned to this component. In the first example, big_sphere is fixed along the x x and z z directions but not along the y y direction. disp_lim is the upper bound of the magnitude of the total group displacement, in units of lattice_constant . If the total displacement magnitude (in Angstrom instead of in Angstrom/ time_step ) is larger than disp_lim , the displacement vector is zeroed, regardless of whether time_end is reached or what value boolean_release is. disp_lim is irrelevant when assign_style = force . However, it needs to be provided regardless. When boolean_grad = f , the same displacement/force vector [ assign_x , assign_y , assign_z ] is assigned to all nodes/atoms of the group; the following options, including grad_ref_axis , grad_assign_axis , grad_ref_l , and grad_ref_u , become irrelevant and do not need to provided. When boolean_grad = t , the displacement/force is assigned to the group gradiently, i.e., different elements/nodes/atoms in the group may have a different [ assign_x , assign_y , assign_z ] vector. The grad_assign_axis component of the displacement/force vector is linearly applied to the group based on the positions of elements/nodes/atoms along the grad_ref_axis direction. grad_ref_l and grad_ref_u are the bounds of the graded displacement/force, in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the grad_ref_axis direction, with inf referring to the lower ( grad_ref_l ) and upper ( grad_ref_u ) simulation cell boundaries. If grad_ref_l < grad_ref_u , the elements/nodes/atoms located at or below grad_ref_l are assigned a zero displacement/force vector, i.e., fixed; those located at or above grad_ref_u are assigned [ assign_x , assign_y , assign_z ]. If grad_ref_l > grad_ref_u , the elements/nodes/atoms located at or above grad_ref_l are assigned a zero displacement/force vector, i.e., fixed; those located at or below grad_ref_u are assigned [ assign_x , assign_y , assign_z ]. In any case, the elements/nodes/atoms located between grad_ref_l and grad_ref_u are assigned a vector whose grad_assign_axis component is linearly graded while the other two components remain the same with respect to [ assign_x , assign_y , assign_z ]. In the second example, the elements/nodes/atoms which are located below 50.0\\cdot\\vec{l'}_0[2] 50.0\\cdot\\vec{l'}_0[2] along the y axis (because grad_ref_axis = 2 ) are assigned a zero displacement vector; those located above 60.0\\cdot\\vec{l'}_0[2] 60.0\\cdot\\vec{l'}_0[2] along the y axis are assigned [ assign_x , assign_y , assign_z ]; those in between are assigned a linearly graded displacement vector whose x component (because grad_assign_axis = 1 ) is varied between zero and assign_x while its y and z components are assign_y and assign_z , respectively. In the third example, the elements/nodes/atoms which are located below 10.0\\cdot\\vec{l'}_0[3] 10.0\\cdot\\vec{l'}_0[3] along the z axis (because grad_ref_axis = 3 ) are assigned [ assign_x , assign_y , assign_z ]; those located above 100.0\\cdot\\vec{l'}_0[3] 100.0\\cdot\\vec{l'}_0[3] along the z axis are assigned a zero force vector; those in between are assigned a linearly graded force vector whose y component (because grad_assign_axis = 2 ) is varied between zero and assign_y while its x and z components are assign_x and assign_z , respectively. Note that for each group concerned in this command, the displacement and force vectors are added to relevant nodes/atoms after their interatomic potential-based displacement/force vectored are zeroed. In particular, the force, stress, and energy are zeroed if assign_style = disp ; the force, stress, and energy are replaced with those induced by this command if assign_style = force . In both cases, the velocity vectors are also zeroed in dynamic and hybrid CAC . In this sense, if the same atoms/nodes are included in multiple groups that are also concerned in this command, those appearing in the later fix commands will provail. For example, if a node is assigned a displacement vector in the first fix command, a force vector in the second fix command, and another force vector in the third fix command, the force vector in the last fix command will be imposed. As another example, if an atom is assigned a force vector in the fourth fix command, and a displacement vector in the fifth fix command, the force/stress/energy vector of that atom will be zeroed. To avoid unintended effects, users are advised to carefully check if the same nodes/atoms are involved in different fix commands.","title":"Description"},{"location":"chapter-5/fix/#related-commands","text":"There cannot be fewer fix commands than fix_number , which should not be larger than new_group_number + restart_group_number . When there are more fix commands in cac.in than fix_number , those appearing later will be ignored. Note that all groups do not necessarily have corresponding fix command. The purpose of having a group that does not have a correpsonding fix command is to calculate certain mechanical properties, e.g., energy, force, and stress, of the nodes/atoms it contains.","title":"Related commands"},{"location":"chapter-5/fix/#related-files","text":"fix.f90 , fix_displacement.f90 , and fix_force.f90","title":"Related files"},{"location":"chapter-5/fix/#default","text":"None.","title":"Default"},{"location":"chapter-5/grain_dir/","text":"Syntax grain_dir direction overlap direction = 1 or 2 or 3 overlap = real number Examples grain_dir 1 0.1 grain_dir 2 0.2 Description This command sets the grain stack direction and the overlap between adjacent grains along that direction, as shown in the figure below: direction can be 1 , 2 , or 3 , corresponding to the x , y , or z directions, respectively. overlap , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the direction , sets the overlap distance between adjacent grains along the direction , as shown in the figure above. It is used to adjust the relative position along a certain direction between adjacent grains to find the energy minimized grain boundary structure. If overlap is a large positive real number, some atoms from adjacent grains may be too close to each other. In this case, one may use the cutoff style in the modify command to delete some atoms that are within a certain distance from others. Note that the direction is also the subdomain stack direction if subdomain_number > 1 even when there is only one grain, i.e., grain_number = 1. Since there is no overlap between adjacent subdomains within the same grain, overlap becomes irrelevant when grain_number = 1. Related commands This command is relevant when grain_number > 1 or subdomain_number > 1. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the grain information. Related files box_init.f90 and model_init.f90 Default grain_dir 3 0.","title":"grain_dir"},{"location":"chapter-5/grain_dir/#syntax","text":"grain_dir direction overlap direction = 1 or 2 or 3 overlap = real number","title":"Syntax"},{"location":"chapter-5/grain_dir/#examples","text":"grain_dir 1 0.1 grain_dir 2 0.2","title":"Examples"},{"location":"chapter-5/grain_dir/#description","text":"This command sets the grain stack direction and the overlap between adjacent grains along that direction, as shown in the figure below: direction can be 1 , 2 , or 3 , corresponding to the x , y , or z directions, respectively. overlap , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the direction , sets the overlap distance between adjacent grains along the direction , as shown in the figure above. It is used to adjust the relative position along a certain direction between adjacent grains to find the energy minimized grain boundary structure. If overlap is a large positive real number, some atoms from adjacent grains may be too close to each other. In this case, one may use the cutoff style in the modify command to delete some atoms that are within a certain distance from others. Note that the direction is also the subdomain stack direction if subdomain_number > 1 even when there is only one grain, i.e., grain_number = 1. Since there is no overlap between adjacent subdomains within the same grain, overlap becomes irrelevant when grain_number = 1.","title":"Description"},{"location":"chapter-5/grain_dir/#related-commands","text":"This command is relevant when grain_number > 1 or subdomain_number > 1. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the grain information.","title":"Related commands"},{"location":"chapter-5/grain_dir/#related-files","text":"box_init.f90 and model_init.f90","title":"Related files"},{"location":"chapter-5/grain_dir/#default","text":"grain_dir 3 0.","title":"Default"},{"location":"chapter-5/grain_mat/","text":"Syntax grain_mat {grain_id x i j k y i j k z i j k} i , j , k = real number Examples grain_mat {1 x -1. 1. -2. y 1. 1. 0. z 1. -1. -1.} grain_mat {1 x 1. 1. 0. y -1. 1. 2. z 1. -1. 1.} {2 x 1. 1. 0. y -1. 1. -2. z -1. 1. 1.} Description This command sets the crystallographic orientations in each grain, along the x , y , and z directions, respectively. Note that the curly brackets { and } in the syntax/examples are to separate different grains, the number of which is grain_number ; all brackets should not be included in preparing cac.in . Any two sets of vector must be normal to each other, i.e., \\mathbf{x} \\cdot \\mathbf{y} = 0 \\mathbf{x} \\cdot \\mathbf{y} = 0 \\mathbf{y} \\cdot \\mathbf{z} = 0 \\mathbf{y} \\cdot \\mathbf{z} = 0 \\mathbf{x} \\cdot \\mathbf{z} = 0 \\mathbf{x} \\cdot \\mathbf{z} = 0 The right hand rule must also be obeyed, i.e., \\mathbf{x} \\times \\mathbf{y} \\parallel \\mathbf{z} \\mathbf{x} \\times \\mathbf{y} \\parallel \\mathbf{z} \\mathbf{y} \\times \\mathbf{z} \\parallel \\mathbf{x} \\mathbf{y} \\times \\mathbf{z} \\parallel \\mathbf{x} \\mathbf{z} \\times \\mathbf{x} \\parallel \\mathbf{y} \\mathbf{z} \\times \\mathbf{x} \\parallel \\mathbf{y} The user will get an error message followed by the termination of the program if any of these requirements is not satisfied. The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded. Related commands The number of grain is specified in the grain_num command. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the crystallographic orientations information. Related files grain.f90 Default grain_mat 1 x 1. 0. 0. y 0. 1. 0. z 0. 0. 1.","title":"grain_mat"},{"location":"chapter-5/grain_mat/#syntax","text":"grain_mat {grain_id x i j k y i j k z i j k} i , j , k = real number","title":"Syntax"},{"location":"chapter-5/grain_mat/#examples","text":"grain_mat {1 x -1. 1. -2. y 1. 1. 0. z 1. -1. -1.} grain_mat {1 x 1. 1. 0. y -1. 1. 2. z 1. -1. 1.} {2 x 1. 1. 0. y -1. 1. -2. z -1. 1. 1.}","title":"Examples"},{"location":"chapter-5/grain_mat/#description","text":"This command sets the crystallographic orientations in each grain, along the x , y , and z directions, respectively. Note that the curly brackets { and } in the syntax/examples are to separate different grains, the number of which is grain_number ; all brackets should not be included in preparing cac.in . Any two sets of vector must be normal to each other, i.e., \\mathbf{x} \\cdot \\mathbf{y} = 0 \\mathbf{x} \\cdot \\mathbf{y} = 0 \\mathbf{y} \\cdot \\mathbf{z} = 0 \\mathbf{y} \\cdot \\mathbf{z} = 0 \\mathbf{x} \\cdot \\mathbf{z} = 0 \\mathbf{x} \\cdot \\mathbf{z} = 0 The right hand rule must also be obeyed, i.e., \\mathbf{x} \\times \\mathbf{y} \\parallel \\mathbf{z} \\mathbf{x} \\times \\mathbf{y} \\parallel \\mathbf{z} \\mathbf{y} \\times \\mathbf{z} \\parallel \\mathbf{x} \\mathbf{y} \\times \\mathbf{z} \\parallel \\mathbf{x} \\mathbf{z} \\times \\mathbf{x} \\parallel \\mathbf{y} \\mathbf{z} \\times \\mathbf{x} \\parallel \\mathbf{y} The user will get an error message followed by the termination of the program if any of these requirements is not satisfied. The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded.","title":"Description"},{"location":"chapter-5/grain_mat/#related-commands","text":"The number of grain is specified in the grain_num command. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the crystallographic orientations information.","title":"Related commands"},{"location":"chapter-5/grain_mat/#related-files","text":"grain.f90","title":"Related files"},{"location":"chapter-5/grain_mat/#default","text":"grain_mat 1 x 1. 0. 0. y 0. 1. 0. z 0. 0. 1.","title":"Default"},{"location":"chapter-5/grain_move/","text":"Syntax grain_move {grain_id move_x move_y move_z} grain_id = positive integer move_x , move_y , move_z = real number Examples grain_move {1 0. 0. 0.} {2 0.5 -0.301 0.001} Description This command sets the displacements of the origin of each grain along the x , y , and z axis, respectively. When move_x , move_y , and move_z are all 0.0, the next grain's lower boundary is the current grain's upper boundary along the grain stack direction . Note that the curly brackets { and } in the syntax/examples are to separate different grains, the number of which is grain_number ; all brackets should not be included in preparing cac.in . The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded. Related commands When the displacement vector is along the grain stack direction , result by this command may be equivalent to setting the overlap between adjacent grains. Note that the same overlap is applied between all adjacent grains, while this command sets the displacement vector for each grain independently. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the grain information. Related files box_init.f90 Default grain_move 1 0. 0. 0.","title":"grain_move"},{"location":"chapter-5/grain_move/#syntax","text":"grain_move {grain_id move_x move_y move_z} grain_id = positive integer move_x , move_y , move_z = real number","title":"Syntax"},{"location":"chapter-5/grain_move/#examples","text":"grain_move {1 0. 0. 0.} {2 0.5 -0.301 0.001}","title":"Examples"},{"location":"chapter-5/grain_move/#description","text":"This command sets the displacements of the origin of each grain along the x , y , and z axis, respectively. When move_x , move_y , and move_z are all 0.0, the next grain's lower boundary is the current grain's upper boundary along the grain stack direction . Note that the curly brackets { and } in the syntax/examples are to separate different grains, the number of which is grain_number ; all brackets should not be included in preparing cac.in . The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded.","title":"Description"},{"location":"chapter-5/grain_move/#related-commands","text":"When the displacement vector is along the grain stack direction , result by this command may be equivalent to setting the overlap between adjacent grains. Note that the same overlap is applied between all adjacent grains, while this command sets the displacement vector for each grain independently. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the grain information.","title":"Related commands"},{"location":"chapter-5/grain_move/#related-files","text":"box_init.f90","title":"Related files"},{"location":"chapter-5/grain_move/#default","text":"grain_move 1 0. 0. 0.","title":"Default"},{"location":"chapter-5/grain_num/","text":"Syntax grain_num grain_number grain_number = positive integer Examples grain_num 2 Description This command sets the number of grains in the simulation cell. When grain_number > 1, grains are stacked along the grain stack direction . Each grain has its own crystallographic orientations , origin displacements , and number of subdomains . Related commands In commands grain_mat , grain_move , subdomain , unit_num , and unit_type , all information related to grain_id that is larger than grain_number in this command will be discarded. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the grain information. Related files box_init.f90 and grain.f90 Default grain_num 1","title":"grain_num"},{"location":"chapter-5/grain_num/#syntax","text":"grain_num grain_number grain_number = positive integer","title":"Syntax"},{"location":"chapter-5/grain_num/#examples","text":"grain_num 2","title":"Examples"},{"location":"chapter-5/grain_num/#description","text":"This command sets the number of grains in the simulation cell. When grain_number > 1, grains are stacked along the grain stack direction . Each grain has its own crystallographic orientations , origin displacements , and number of subdomains .","title":"Description"},{"location":"chapter-5/grain_num/#related-commands","text":"In commands grain_mat , grain_move , subdomain , unit_num , and unit_type , all information related to grain_id that is larger than grain_number in this command will be discarded. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the grain information.","title":"Related commands"},{"location":"chapter-5/grain_num/#related-files","text":"box_init.f90 and grain.f90","title":"Related files"},{"location":"chapter-5/grain_num/#default","text":"grain_num 1","title":"Default"},{"location":"chapter-5/group/","text":"Syntax group group_name style_cg style_at group_shape x lower_b upper_b i j k y lower_b upper_b i j k z lower_b upper_b i j k boolean_in group_axis group_centroid_x group_centroid_y group_centroid_z group_radius_large group_radius_small group_name = a string (length <= 30) style_cg = element or node or null style_at = atom or null group_shape = block or cylinder or cone or tube or sphere lower_b , upper_b = real number or inf i , j , k = real number boolean_in = t or f t is true f is false group_axis = 1 or 2 or 3 group_centroid_x , group_centroid_y , group_centroid_z = real number group_radius_large , group_radius_small = positive real number Examples group top_box null atom block x inf inf 1. 0. 0. y inf inf 0. 1. 0. z 14.4 inf 0. 0. 1. t 3 20. 5. 0. 10. 10. group cylin node null cylinder x inf inf 1. 0. 0. y inf inf 0. 1. 0. z 14.4 inf 0. 0. 1. f 3 20. 5. 0. 10. 10. group red_cone element atom cone x inf inf 1. 0. 0. y inf inf 0. 1. 0. z 14.4 inf 0. 0. 1. t 3 20. 5. 0. 10. 5. group big_sphere element null sphere x inf inf 1. 0. 0. y inf inf 0. 1. 0. z 14.4 inf 0. 0. 1. t 3 20. 5. 0. 10. 10. Description This command sets new groups, the number of which is provided in the group_num command. The elements/nodes/atoms in a group, either a new group or a restar group, can be moved at each simulation step , deformed with the simulation cell (when boolean_def in both fix and deform commands = t ), or not moved/deformed. The syntax is similar to the first of that of the modify command. Different new groups cannot have the same group_name . Also, since the restart groups are automatically named group_* , where * is a positive integer starting from new_group_number + 1, the group_name in this command cannot have any of those names. style_cg decides whether the group contains elements ( element ), nodes ( node ), or nothing ( null ) in the coarse-grained domain; the differences between element and node are discussed here . style_at decides whether the group contains atoms ( atom ) or nothing ( null ) in the atomistic domain. There are currently five group_shape : block , cylinder , cone , tube , and sphere . lower_b and upper_b are the lower and upper boundaries of the group_shape , respectively, in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the corresponding direction. When lower_b or upper_b = inf , the corresponding lower or upper simulation cell boundaries are taken as the group_shape boundaries, respectively. Note that when group_shape = cylinder or cone or tube , lower_b and upper_b are the lower and upper plane boundaries normal to the central axis group_axis direction, respectively. i , j , and k decide the group_shape ( \\neq \\neq sphere ) boundary plane orientations with respect to the simulation cell, similar to those in the box_dir command. Note that these five options ( lower_b , upper_b , i , j , and k ) are irrelevant when group_shape = sphere , and when group_shape = cylinder or cone or tube if the corresponding direction is not group_axis . Also, group_axis is irrelevant when group_shape = block or sphere . However, they need to be provided regardless. When boolean_in = t , elements/nodes/atoms inside the group_shape belong to the group; otherwise, those outside do. group_centroid_x , group_centroid_y , and group_centroid_z , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 and with respect to the lower boundaries of the simulation cell along the corresponding direction, are the coordinates of the center of the base plane of a cylinder or cone or tube , or the center of a sphere . When group_shape = cylinder or cone or tube , the group_centroid_* that corresponds to the group_axis direction becomes irrelevant. For example, when group_axis = 2 , group_centroid_y can take any real number without affecting the results. group_radius_large is the base radius of a cylinder , the large base radius of a cone , the outer base radius of a tube , or the radius of a sphere . group_radius_small , the small base radius of a cone or the inner base radius of a tube , is irrelevant for other group_shape . Both group_radius_large and group_radius_small are in units of the maximum lattice periodicity length l'_\\mathrm{max} l'_\\mathrm{max} . Note that these six options ( group_axis , group_centroid_* , and group_radius_* ) are not relevant when group_shape = block . Yet, they need to be provided regardless. Related commands There cannot be fewer group commands than new_group_number . When there are too many group commands, those appearing later will be ignored. The group_name in the cal and fix commands must match that in the current command. This command becomes irrelevant when new_group_number = 0. Related files group.f90 , fix_displacement.f90 , fix_force.f90 , and group_cal.f90 Default None","title":"group"},{"location":"chapter-5/group/#syntax","text":"group group_name style_cg style_at group_shape x lower_b upper_b i j k y lower_b upper_b i j k z lower_b upper_b i j k boolean_in group_axis group_centroid_x group_centroid_y group_centroid_z group_radius_large group_radius_small group_name = a string (length <= 30) style_cg = element or node or null style_at = atom or null group_shape = block or cylinder or cone or tube or sphere lower_b , upper_b = real number or inf i , j , k = real number boolean_in = t or f t is true f is false group_axis = 1 or 2 or 3 group_centroid_x , group_centroid_y , group_centroid_z = real number group_radius_large , group_radius_small = positive real number","title":"Syntax"},{"location":"chapter-5/group/#examples","text":"group top_box null atom block x inf inf 1. 0. 0. y inf inf 0. 1. 0. z 14.4 inf 0. 0. 1. t 3 20. 5. 0. 10. 10. group cylin node null cylinder x inf inf 1. 0. 0. y inf inf 0. 1. 0. z 14.4 inf 0. 0. 1. f 3 20. 5. 0. 10. 10. group red_cone element atom cone x inf inf 1. 0. 0. y inf inf 0. 1. 0. z 14.4 inf 0. 0. 1. t 3 20. 5. 0. 10. 5. group big_sphere element null sphere x inf inf 1. 0. 0. y inf inf 0. 1. 0. z 14.4 inf 0. 0. 1. t 3 20. 5. 0. 10. 10.","title":"Examples"},{"location":"chapter-5/group/#description","text":"This command sets new groups, the number of which is provided in the group_num command. The elements/nodes/atoms in a group, either a new group or a restar group, can be moved at each simulation step , deformed with the simulation cell (when boolean_def in both fix and deform commands = t ), or not moved/deformed. The syntax is similar to the first of that of the modify command. Different new groups cannot have the same group_name . Also, since the restart groups are automatically named group_* , where * is a positive integer starting from new_group_number + 1, the group_name in this command cannot have any of those names. style_cg decides whether the group contains elements ( element ), nodes ( node ), or nothing ( null ) in the coarse-grained domain; the differences between element and node are discussed here . style_at decides whether the group contains atoms ( atom ) or nothing ( null ) in the atomistic domain. There are currently five group_shape : block , cylinder , cone , tube , and sphere . lower_b and upper_b are the lower and upper boundaries of the group_shape , respectively, in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the corresponding direction. When lower_b or upper_b = inf , the corresponding lower or upper simulation cell boundaries are taken as the group_shape boundaries, respectively. Note that when group_shape = cylinder or cone or tube , lower_b and upper_b are the lower and upper plane boundaries normal to the central axis group_axis direction, respectively. i , j , and k decide the group_shape ( \\neq \\neq sphere ) boundary plane orientations with respect to the simulation cell, similar to those in the box_dir command. Note that these five options ( lower_b , upper_b , i , j , and k ) are irrelevant when group_shape = sphere , and when group_shape = cylinder or cone or tube if the corresponding direction is not group_axis . Also, group_axis is irrelevant when group_shape = block or sphere . However, they need to be provided regardless. When boolean_in = t , elements/nodes/atoms inside the group_shape belong to the group; otherwise, those outside do. group_centroid_x , group_centroid_y , and group_centroid_z , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 and with respect to the lower boundaries of the simulation cell along the corresponding direction, are the coordinates of the center of the base plane of a cylinder or cone or tube , or the center of a sphere . When group_shape = cylinder or cone or tube , the group_centroid_* that corresponds to the group_axis direction becomes irrelevant. For example, when group_axis = 2 , group_centroid_y can take any real number without affecting the results. group_radius_large is the base radius of a cylinder , the large base radius of a cone , the outer base radius of a tube , or the radius of a sphere . group_radius_small , the small base radius of a cone or the inner base radius of a tube , is irrelevant for other group_shape . Both group_radius_large and group_radius_small are in units of the maximum lattice periodicity length l'_\\mathrm{max} l'_\\mathrm{max} . Note that these six options ( group_axis , group_centroid_* , and group_radius_* ) are not relevant when group_shape = block . Yet, they need to be provided regardless.","title":"Description"},{"location":"chapter-5/group/#related-commands","text":"There cannot be fewer group commands than new_group_number . When there are too many group commands, those appearing later will be ignored. The group_name in the cal and fix commands must match that in the current command. This command becomes irrelevant when new_group_number = 0.","title":"Related commands"},{"location":"chapter-5/group/#related-files","text":"group.f90 , fix_displacement.f90 , fix_force.f90 , and group_cal.f90","title":"Related files"},{"location":"chapter-5/group/#default","text":"None","title":"Default"},{"location":"chapter-5/group_num/","text":"Syntax group_num new_group_number restart_group_number fix_number cal_number new_group_number , restart_group_number , fix_number , cal_number = non-negative integer (<= 40) Examples group_num 3 0 3 0 group_num 2 1 1 2 Description This command sets the numbers of new groups , restart groups, fix , and calculations . In CAC, a group is a collection of elements/nodes/atoms. There are two purposes of having groups: (i) to apply a displacement/force to certain elements/nodes/atoms, (ii) to calculate some mechanical quantities, e.g., energy, force, and stress, of certain elements/nodes/atoms. The new groups are defined in the group command. The elements/nodes/atoms contained in the restart groups, named group_* , are read from the group_in_*.id files, where * is a positive integer starting from new_group_number + 1, yet their displacement/force information is set in the fix command. The total number of groups, i.e., new_group_number + restart_group_number , cannot be larger than 40. Files group_in_*.id contain information of the restart groups. On the one hand, there cannot be fewer group_in_*.id files than restart_group_number ; on the other hand, any group_in_*.id file with * > new_group_number + restart_group_number will be ignored. When boolean_restart = f , restart_group_number becomes 0, regardless of its value set in this command. fix_number should not be larger than new_group_number + restart_group_number ; neither should cal_number . Also, fix_number + cal_number should not be smaller than new_group_number + restart_group_number . Related commands The new groups are defined in the group command. The displacement/force and calculation information of each group is set in the fix and cal commands, respectively. Related files group.f90 , fix_displacement.f90 , fix_force.f90 , group_cal.f90 Default group_num 0 0 0 0","title":"group_num"},{"location":"chapter-5/group_num/#syntax","text":"group_num new_group_number restart_group_number fix_number cal_number new_group_number , restart_group_number , fix_number , cal_number = non-negative integer (<= 40)","title":"Syntax"},{"location":"chapter-5/group_num/#examples","text":"group_num 3 0 3 0 group_num 2 1 1 2","title":"Examples"},{"location":"chapter-5/group_num/#description","text":"This command sets the numbers of new groups , restart groups, fix , and calculations . In CAC, a group is a collection of elements/nodes/atoms. There are two purposes of having groups: (i) to apply a displacement/force to certain elements/nodes/atoms, (ii) to calculate some mechanical quantities, e.g., energy, force, and stress, of certain elements/nodes/atoms. The new groups are defined in the group command. The elements/nodes/atoms contained in the restart groups, named group_* , are read from the group_in_*.id files, where * is a positive integer starting from new_group_number + 1, yet their displacement/force information is set in the fix command. The total number of groups, i.e., new_group_number + restart_group_number , cannot be larger than 40. Files group_in_*.id contain information of the restart groups. On the one hand, there cannot be fewer group_in_*.id files than restart_group_number ; on the other hand, any group_in_*.id file with * > new_group_number + restart_group_number will be ignored. When boolean_restart = f , restart_group_number becomes 0, regardless of its value set in this command. fix_number should not be larger than new_group_number + restart_group_number ; neither should cal_number . Also, fix_number + cal_number should not be smaller than new_group_number + restart_group_number .","title":"Description"},{"location":"chapter-5/group_num/#related-commands","text":"The new groups are defined in the group command. The displacement/force and calculation information of each group is set in the fix and cal commands, respectively.","title":"Related commands"},{"location":"chapter-5/group_num/#related-files","text":"group.f90 , fix_displacement.f90 , fix_force.f90 , group_cal.f90","title":"Related files"},{"location":"chapter-5/group_num/#default","text":"group_num 0 0 0 0","title":"Default"},{"location":"chapter-5/lattice/","text":"Syntax lattice chemical_element lattice_structure lattice_constant chemical_element = a string (length <= 30) lattice_structure = fcc or bcc lattice_constant = positive real number Examples lattice Cu fcc 3.615 lattice Al fcc 4.05 lattice Fe bcc 2.8553 Description This command sets the lattice. lattice_constant is in Angstrom. Note that (i) the current PyCAC code can only simulate pure metals with single chemical element, (ii) lattice_structure must be either fcc or bcc , yielding rhombohedral elements with {111} and {110} surfaces, respectively. Related commands The atomic mass is provided in the mass command. lattice_structure becomes irrelevant when boolean_restart = t , in which case there is no need for the lattice information. Related files box_init.f90 and lattice.f90 Default None.","title":"lattice"},{"location":"chapter-5/lattice/#syntax","text":"lattice chemical_element lattice_structure lattice_constant chemical_element = a string (length <= 30) lattice_structure = fcc or bcc lattice_constant = positive real number","title":"Syntax"},{"location":"chapter-5/lattice/#examples","text":"lattice Cu fcc 3.615 lattice Al fcc 4.05 lattice Fe bcc 2.8553","title":"Examples"},{"location":"chapter-5/lattice/#description","text":"This command sets the lattice. lattice_constant is in Angstrom. Note that (i) the current PyCAC code can only simulate pure metals with single chemical element, (ii) lattice_structure must be either fcc or bcc , yielding rhombohedral elements with {111} and {110} surfaces, respectively.","title":"Description"},{"location":"chapter-5/lattice/#related-commands","text":"The atomic mass is provided in the mass command. lattice_structure becomes irrelevant when boolean_restart = t , in which case there is no need for the lattice information.","title":"Related commands"},{"location":"chapter-5/lattice/#related-files","text":"box_init.f90 and lattice.f90","title":"Related files"},{"location":"chapter-5/lattice/#default","text":"None.","title":"Default"},{"location":"chapter-5/limit/","text":"Syntax limit atom_per_cell_number atomic_neighbor_number atom_per_cell_number , atomic_neighbor_number = positive integer Examples limit 100 100 limit 120 140 Description This command sets the initial number of atoms per cell ( atom_per_cell_number ) and the number of neighboring atoms per atom/integration point ( atomic_neighbor_number ). The numbers are used to allocate initial arrays for atoms in cells and neighbors of atoms/integration points. If, during a simulation, arrays larger than those initially allocated become necessary, the two numbers set in this command will increase by 20 to enlarge the arrays, until even larger arrays are needed, in which case these two numbers increase by 20 again, and so on. Related commands The initial values of these two numbers depend on the cutoff distance r_\\mathrm{c} r_\\mathrm{c} and bin_size of the interatomic potential . Related files neighbor_init.f90 , update_neighbor.f90 , cell_neighbor_list.f90 , update_cell_neighbor.f90 , and update_cell.f90 Default limit 100 100","title":"limit"},{"location":"chapter-5/limit/#syntax","text":"limit atom_per_cell_number atomic_neighbor_number atom_per_cell_number , atomic_neighbor_number = positive integer","title":"Syntax"},{"location":"chapter-5/limit/#examples","text":"limit 100 100 limit 120 140","title":"Examples"},{"location":"chapter-5/limit/#description","text":"This command sets the initial number of atoms per cell ( atom_per_cell_number ) and the number of neighboring atoms per atom/integration point ( atomic_neighbor_number ). The numbers are used to allocate initial arrays for atoms in cells and neighbors of atoms/integration points. If, during a simulation, arrays larger than those initially allocated become necessary, the two numbers set in this command will increase by 20 to enlarge the arrays, until even larger arrays are needed, in which case these two numbers increase by 20 again, and so on.","title":"Description"},{"location":"chapter-5/limit/#related-commands","text":"The initial values of these two numbers depend on the cutoff distance r_\\mathrm{c} r_\\mathrm{c} and bin_size of the interatomic potential .","title":"Related commands"},{"location":"chapter-5/limit/#related-files","text":"neighbor_init.f90 , update_neighbor.f90 , cell_neighbor_list.f90 , update_cell_neighbor.f90 , and update_cell.f90","title":"Related files"},{"location":"chapter-5/limit/#default","text":"limit 100 100","title":"Default"},{"location":"chapter-5/mass/","text":"Syntax mass atomic_mass atomic_mass = positive real number Examples mass 63.546 mass 26.9815 mass 55.845 Description This command sets the atomic mass in g/mol. The three examples are for Cu, Al, and Fe, respectively, corresponding to those in the lattice command. Note the current PyCAC code can only simulate pure metals . Related commands The mass matrix type in the finite element calculation in the coarse-grained domain is specified in the element command. Related files crystal.f90 and mass_matrix.f90 Default None.","title":"mass"},{"location":"chapter-5/mass/#syntax","text":"mass atomic_mass atomic_mass = positive real number","title":"Syntax"},{"location":"chapter-5/mass/#examples","text":"mass 63.546 mass 26.9815 mass 55.845","title":"Examples"},{"location":"chapter-5/mass/#description","text":"This command sets the atomic mass in g/mol. The three examples are for Cu, Al, and Fe, respectively, corresponding to those in the lattice command. Note the current PyCAC code can only simulate pure metals .","title":"Description"},{"location":"chapter-5/mass/#related-commands","text":"The mass matrix type in the finite element calculation in the coarse-grained domain is specified in the element command.","title":"Related commands"},{"location":"chapter-5/mass/#related-files","text":"crystal.f90 and mass_matrix.f90","title":"Related files"},{"location":"chapter-5/mass/#default","text":"None.","title":"Default"},{"location":"chapter-5/minimize/","text":"Syntax minimize mini_style max_iteration tolerance mini_style = cg or sd or fire or qm max_iteration = positive integer tolerance = positive real number Examples minimize cg 1000 1d-5 minimize fire 100 1d-6 Description This command sets the style and two parameters for the energy minimization in quasistatic and hybrid CAC . There are four mini_style : congjugate gradient ( cg ), steepest descent ( sd ), fast inertial relaxation engine ( fire ), and quick min ( qm ). Both cg and sd use the negative gradient of internal energy as the initial direction; from the second step, however, the sd style uses the current negative gradient while the cg style uses the negative gradient conjugated to the current potential surface. Once the direction is set, the inner iterations begin in which a line search is conducted to determine the length by which the nodes/atoms need to move along the designated direction to find the minimized energy. For more information of the energy minimization with these two styles, read chapter 3 of Shuozhi Xu's Ph.D. dissertation . The fire style is based on Bitzek et al., 2006 while the qm style is based on quenched dynamics which is used also in dynamic CAC . The difference is that only one quenched dynamics iteration is carried out at each simulation step in dynamic CAC while many quenched dynamics iterations are performed at each simulation step during the energy minimization until the internal energy converges at that step. For the fire and qm styles, the inner iteration is irrelevant. The energy minimization is considered to converge when either the number of outer iterations reaches max_iteraction or the energy variation between successive outer iterations divided by the energy of the current iteration is less than tolerance . Related commands This command is relevant only when simulation_style = statics or hybrid . Related files quasi_statics.f90 , mini_init.f90 , update_mini.f90 , mini_energy.f90 , hybrid.f90 , conjugate_gradient.f90 , steepest_descent.f90 , quick_mini.f90 , and fire.f90 Default minimize cg 1000 1d-6","title":"minimize"},{"location":"chapter-5/minimize/#syntax","text":"minimize mini_style max_iteration tolerance mini_style = cg or sd or fire or qm max_iteration = positive integer tolerance = positive real number","title":"Syntax"},{"location":"chapter-5/minimize/#examples","text":"minimize cg 1000 1d-5 minimize fire 100 1d-6","title":"Examples"},{"location":"chapter-5/minimize/#description","text":"This command sets the style and two parameters for the energy minimization in quasistatic and hybrid CAC . There are four mini_style : congjugate gradient ( cg ), steepest descent ( sd ), fast inertial relaxation engine ( fire ), and quick min ( qm ). Both cg and sd use the negative gradient of internal energy as the initial direction; from the second step, however, the sd style uses the current negative gradient while the cg style uses the negative gradient conjugated to the current potential surface. Once the direction is set, the inner iterations begin in which a line search is conducted to determine the length by which the nodes/atoms need to move along the designated direction to find the minimized energy. For more information of the energy minimization with these two styles, read chapter 3 of Shuozhi Xu's Ph.D. dissertation . The fire style is based on Bitzek et al., 2006 while the qm style is based on quenched dynamics which is used also in dynamic CAC . The difference is that only one quenched dynamics iteration is carried out at each simulation step in dynamic CAC while many quenched dynamics iterations are performed at each simulation step during the energy minimization until the internal energy converges at that step. For the fire and qm styles, the inner iteration is irrelevant. The energy minimization is considered to converge when either the number of outer iterations reaches max_iteraction or the energy variation between successive outer iterations divided by the energy of the current iteration is less than tolerance .","title":"Description"},{"location":"chapter-5/minimize/#related-commands","text":"This command is relevant only when simulation_style = statics or hybrid .","title":"Related commands"},{"location":"chapter-5/minimize/#related-files","text":"quasi_statics.f90 , mini_init.f90 , update_mini.f90 , mini_energy.f90 , hybrid.f90 , conjugate_gradient.f90 , steepest_descent.f90 , quick_mini.f90 , and fire.f90","title":"Related files"},{"location":"chapter-5/minimize/#default","text":"minimize cg 1000 1d-6","title":"Default"},{"location":"chapter-5/modify/","text":"Syntax modify modify_name modify_style modify_shape x lower_b upper_b i j k y lower_b upper_b i j k z lower_b upper_b i j k boolean_in boolean_delete_filled modify_axis modify_centroid_x modify_centroid_y modify_centroid_z modify_radius_large modify_radius_small modify modify_name modify_style line_axis plane_axis modify_centroid_x modify_centroid_y modify_centroid_z dis_angle poisson_ratio modify modify_name modify_style depth tolerance modify modify_name modify_style disp_x disp_y disp_z modify_name = a string (length <= 30) modify_style = delete or cg2at or dislocation or cutoff or add_atom modify_shape = block or cylinder or cone or tube or sphere lower_b , upper_b = real number or inf i , j , k = real number boolean_in , boolean_delete_filled = t or f t is true f is false modify_axis , line_axis , plane_axis = 1 or 2 or 3 modify_centroid_x , modify_centroid_y , modify_centroid_z , dis_angle , poisson_ratio , add_x , add_y , add_z = real number modify_radius_large , modify_radius_small , depth , tolerance = positive real number Examples modify del_sth delete cylinder x 0. 1. 0.94281 0. -0.33333 y inf inf 0. 1. 0. z inf inf 0. 0. 1. t t 3 50. 50. 1. 2. 5. modify refine_sth cg2at block x inf inf 1. 0. 0. y 1. 12. 0. 0.94281 -0.33333 z inf inf 0. 0. 1. t f 1 20. 4. 5. 17. 13. modify create_dis dislocation 1 3 1. 20. 3.2 60. 0.36 modify use_cutoff cutoff 0.1 0.01 modify add_some_atoms add_atom 1. 3. 2. Description This command sets the modifications made to the elements/nodes/atoms that are built from scratch, i.e., when boolean_restart = f . The first syntax is similar to that of the group command. There are currently five modify_style : delete , cg2at , dislocation , cutoff , and add_atom . When modify_style = delete or cg2at , the first syntax is used; when modify_style = dislocation , the second syntax is used; when modify_style = cutoff , the third syntax is used; otherwise, the fourth syntax is used. First syntax ( modify_style = delete or cg2at ) The first syntax removes some elements/atoms ( delete ) or refines some elements into atomic scale ( cg2at ), based on the simulation cell built from scratch. There are five modify_shape : block , cylinder , cone , tube , and sphere . lower_b and upper_b are the lower and upper boundaries of the modify_shape , respectively, in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the corresponding direction. When lower_b or upper_b = inf , the corresponding lower or upper simulation cell boundaries are taken as the modify_shape boundaries, respectively. Note that when modify_shape = cylinder or cone or tube , lower_b and upper_b are the lower and upper plane boundaries normal to the central axis modify_axis direction, respectively. i , j , and k decide the modify_shape ( \\neq \\neq sphere ) boundary plane orientations with respect to the simulation cell, similar to those in the box_dir command. Note that these five options ( lower_b , upper_b , i , j , and k ) are irrelevant when modify_shape = sphere , and when modify_shape = cylinder or cone or tube if the corresponding direction is not modify_axis . Also, modify_axis is irrelevant when modify_shape = block or sphere . However, they need to be provided regardless. When boolean_in = t , elements with any of their parts (in the coarse-grained domain) and atoms (in the atomistic domain) inside the modify_shape are deleted ( delete ) or refined to atomic scale ( cg2at ); otherwise, those outside are. In the coarse-grained domain, an element might have some part of it inside and the remaining part outside modify_shape ; for this element, with delete , the region that is left behind due to the deletion may not have the shape specified by modify_shape . In this case, if boolean_delete_filled = t , atoms (that are linearly interpolated from the original element) will be filled in to maintain the modify_shape . E.g., if boolean_in = t , the interpolated atoms of the deleted elements that are outside modify_shape are filled in; otherwise, those inside are, as shown in the figure below. Note that boolean_delete_filled is irrelevant when modify_style = cg2at . Also note that while delete applies to both atomistic and coarse-grained domains, cg2at applied to the coarse-grained domain only. Different from the group command in which the user should pay attention to the difference between element and node , a modification follows one simple rule in the coarse-grained domain: an element and all its nodes are selected if any interpolated atom of this element is inside (if boolean_in = t ) or outside (if boolean_in = f ) modify_shape . modify_centroid_x , modify_centroid_y , and modify_centroid_z , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 and with respect to the lower boundaries of the simulation cell along the corresponding direction, are the coordinates of the center of the base plane of a cylinder or cone or tube , or the center of a sphere . When modify_shape = cylinder or cone or tube , the modify_centroid_* that corresponds to the modify_axis becomes irrelevant. For example, when modify_axis = 3 , modify_centroid_z can take any real number without affecting the results. modify_radius_large is the base radius of a cylinder , the large base radius of a cone , the outer base radius of a tube , or the radius of a sphere . modify_radius_small , the small base radius of a cone or the inner base radius of a tube , is irrelevant for other modify_shape . Both modify_radius_large and modify_radius_small are in units of the maximum lattice periodicity length l'_\\mathrm{max} l'_\\mathrm{max} . Note that these six options ( modify_axis , modify_centroid_* , and modify_radius_* ) are not relevant when modify_shape = block . Yet, they need to be provided regardless. Second syntax ( modify_style = dislocation ) The second syntax builds a full dislocation into the simulation cell, with nodes/atoms displaced following the isotropic displacement field. In FCC and BCC lattices , a full dislocation has a Burgers vector magnitude of (\\sqrt{2}/2)a_0 (\\sqrt{2}/2)a_0 and (\\sqrt{3}/2)a_0 (\\sqrt{3}/2)a_0 , respectively, where a_0 a_0 is the lattice_constant . Multiple modify commands with modify_style = dislocation can be employed to introduce multiple dislocations. line_axis and plane_axis are the dislocation line axis and the plane normal axis, respectively. They cannot be the same. modify_centroid_x , modify_centroid_y , and modify_centroid_z , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 and with respect to the lower boundaries of the simulation cell along the corresponding direction, are the coordinates of the origin with respect to which the displacement field is built. For example, if one wants to build a dislocation passing through the centroid of the simulation cell, these three quantities should be at the centroid. Note that in the coarse-grained and atomistic domains, the slip plane, which contains the dislocation along line_axis and has a normal direction plane_axis , should be located between two adjacent elements and two atomic layers, respectively. dis_angle and poisson_ratio are the dislcoation character angle (in degrees) and the isotropic Poisson's ratio of the material, respectively. Third syntax ( modify_style = cutoff ) The third syntax deletes one atom from a pair of atoms (either real atoms in the atomistic domain or interpolated atoms in the coarse-grained domain) when they are too close, at the grain boundary. The situation that some atoms are too close to each other is usually a result of the overlap or grain origin displacements . Among all modify commands, there should be no more than one with modify_style = cutoff . depth and tolerance , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the grain stack direction , specify the size of the target region and the cutoff distance, respectively, as shown in the figure below. In most cases, tolerance should not be larger than or equal to the first nearest neighbor distance in a perfect lattice. At each grain boundary, a check is first conducted, within the region set by depth along the grain stack direction , on both the real atoms in the atomistic domain or the interpolated atoms in the coarse-grained doain. In the figure above, (i) all atoms in the red shaded region (grain I) will be run against those in the left green shaded region (grain II), (ii) all atoms in the right green shaded region (grain II) will be run against those in the blue shaded region (grain III). Within a pair, if both are real atoms, the one associated with a smaller grain_id is deleted; if one is a real atom and the other is an interpolated atom, the real atom is deleted; if both are interpolated atoms, the user will get an error message because it is impossible to delete a single interpolated atom from an element, which would violate the hyperelastic body assumption of an element. Fourth syntax ( modify_style = add_atom ) The fourth syntax adds additional atoms to the simulation cell built from scratch. It cannot add additional elements. The information of the atoms to be added is read from LAMMPS data files lmp_*.dat , where * is the id of the current modify command in cac.in . For example, if the commands look like this: modify del_sth delete cylinder x 0. 1. 0.94281 0. -0.33333 y inf inf 0. 1. 0. z inf inf 0. 0. 1. t t 3 50. 50. 1. 2. 5. modify add_first add_atom 1. 3. 2. modify create_dis dislocation 1 3 1. 20. 3.2 60. 0.36 modify add_second add_atom -1. 4. 2. then two files, naming, lmp_2.dat and lmp_4.dat should be provided. disp_x , disp_y , and disp_z , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 and with respect to the lower boundaries of the simulation cell along the corresponding direction, are the displacement of the added atoms with respect to their original positions in lmp_*.dat . If disp_x , disp_y , and disp_z are all zero, the atoms are added as is. This modify_style can be useful in constructing models containing grain boundaries (GBs). For example, the GB region (which may not have energy minimized GB structures) of a bicrystal model may be deleted first, before the energy minimized GB structures presented in LAMMPS data files are added to the model. This can be realized by first using a modify command with modify_style = delete , followed by another modify command with modify_style = add_atom . Related commands There cannot be fewer modify commands than modify_number . When there are too many modify commands in cac.in , those appearing later will be ignored. This command becomes irrelevant when boolean_restart = t or modify_number = 0, in which case there is no need for the modification information. Related files model_modify.f90 , model_modify_interpo.f90 , model_add_atom.f90 , model_cutoff.f90 , model_cutoff_bd.f90 , model_dislocation.f90 , model_cg2at.f90 , model_delete.f90 , and model_rearrange.f90 . Default None. Acknowledgements Rigelesaiyin Ji and Jaber R. Mianroodi are acknowledged for helpful discussions in implementing the second syntax.","title":"modify"},{"location":"chapter-5/modify/#syntax","text":"modify modify_name modify_style modify_shape x lower_b upper_b i j k y lower_b upper_b i j k z lower_b upper_b i j k boolean_in boolean_delete_filled modify_axis modify_centroid_x modify_centroid_y modify_centroid_z modify_radius_large modify_radius_small modify modify_name modify_style line_axis plane_axis modify_centroid_x modify_centroid_y modify_centroid_z dis_angle poisson_ratio modify modify_name modify_style depth tolerance modify modify_name modify_style disp_x disp_y disp_z modify_name = a string (length <= 30) modify_style = delete or cg2at or dislocation or cutoff or add_atom modify_shape = block or cylinder or cone or tube or sphere lower_b , upper_b = real number or inf i , j , k = real number boolean_in , boolean_delete_filled = t or f t is true f is false modify_axis , line_axis , plane_axis = 1 or 2 or 3 modify_centroid_x , modify_centroid_y , modify_centroid_z , dis_angle , poisson_ratio , add_x , add_y , add_z = real number modify_radius_large , modify_radius_small , depth , tolerance = positive real number","title":"Syntax"},{"location":"chapter-5/modify/#examples","text":"modify del_sth delete cylinder x 0. 1. 0.94281 0. -0.33333 y inf inf 0. 1. 0. z inf inf 0. 0. 1. t t 3 50. 50. 1. 2. 5. modify refine_sth cg2at block x inf inf 1. 0. 0. y 1. 12. 0. 0.94281 -0.33333 z inf inf 0. 0. 1. t f 1 20. 4. 5. 17. 13. modify create_dis dislocation 1 3 1. 20. 3.2 60. 0.36 modify use_cutoff cutoff 0.1 0.01 modify add_some_atoms add_atom 1. 3. 2.","title":"Examples"},{"location":"chapter-5/modify/#description","text":"This command sets the modifications made to the elements/nodes/atoms that are built from scratch, i.e., when boolean_restart = f . The first syntax is similar to that of the group command. There are currently five modify_style : delete , cg2at , dislocation , cutoff , and add_atom . When modify_style = delete or cg2at , the first syntax is used; when modify_style = dislocation , the second syntax is used; when modify_style = cutoff , the third syntax is used; otherwise, the fourth syntax is used.","title":"Description"},{"location":"chapter-5/modify/#first-syntax-modify_style-delete-or-cg2at","text":"The first syntax removes some elements/atoms ( delete ) or refines some elements into atomic scale ( cg2at ), based on the simulation cell built from scratch. There are five modify_shape : block , cylinder , cone , tube , and sphere . lower_b and upper_b are the lower and upper boundaries of the modify_shape , respectively, in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the corresponding direction. When lower_b or upper_b = inf , the corresponding lower or upper simulation cell boundaries are taken as the modify_shape boundaries, respectively. Note that when modify_shape = cylinder or cone or tube , lower_b and upper_b are the lower and upper plane boundaries normal to the central axis modify_axis direction, respectively. i , j , and k decide the modify_shape ( \\neq \\neq sphere ) boundary plane orientations with respect to the simulation cell, similar to those in the box_dir command. Note that these five options ( lower_b , upper_b , i , j , and k ) are irrelevant when modify_shape = sphere , and when modify_shape = cylinder or cone or tube if the corresponding direction is not modify_axis . Also, modify_axis is irrelevant when modify_shape = block or sphere . However, they need to be provided regardless. When boolean_in = t , elements with any of their parts (in the coarse-grained domain) and atoms (in the atomistic domain) inside the modify_shape are deleted ( delete ) or refined to atomic scale ( cg2at ); otherwise, those outside are. In the coarse-grained domain, an element might have some part of it inside and the remaining part outside modify_shape ; for this element, with delete , the region that is left behind due to the deletion may not have the shape specified by modify_shape . In this case, if boolean_delete_filled = t , atoms (that are linearly interpolated from the original element) will be filled in to maintain the modify_shape . E.g., if boolean_in = t , the interpolated atoms of the deleted elements that are outside modify_shape are filled in; otherwise, those inside are, as shown in the figure below. Note that boolean_delete_filled is irrelevant when modify_style = cg2at . Also note that while delete applies to both atomistic and coarse-grained domains, cg2at applied to the coarse-grained domain only. Different from the group command in which the user should pay attention to the difference between element and node , a modification follows one simple rule in the coarse-grained domain: an element and all its nodes are selected if any interpolated atom of this element is inside (if boolean_in = t ) or outside (if boolean_in = f ) modify_shape . modify_centroid_x , modify_centroid_y , and modify_centroid_z , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 and with respect to the lower boundaries of the simulation cell along the corresponding direction, are the coordinates of the center of the base plane of a cylinder or cone or tube , or the center of a sphere . When modify_shape = cylinder or cone or tube , the modify_centroid_* that corresponds to the modify_axis becomes irrelevant. For example, when modify_axis = 3 , modify_centroid_z can take any real number without affecting the results. modify_radius_large is the base radius of a cylinder , the large base radius of a cone , the outer base radius of a tube , or the radius of a sphere . modify_radius_small , the small base radius of a cone or the inner base radius of a tube , is irrelevant for other modify_shape . Both modify_radius_large and modify_radius_small are in units of the maximum lattice periodicity length l'_\\mathrm{max} l'_\\mathrm{max} . Note that these six options ( modify_axis , modify_centroid_* , and modify_radius_* ) are not relevant when modify_shape = block . Yet, they need to be provided regardless.","title":"First syntax (modify_style = delete or cg2at)"},{"location":"chapter-5/modify/#second-syntax-modify_style-dislocation","text":"The second syntax builds a full dislocation into the simulation cell, with nodes/atoms displaced following the isotropic displacement field. In FCC and BCC lattices , a full dislocation has a Burgers vector magnitude of (\\sqrt{2}/2)a_0 (\\sqrt{2}/2)a_0 and (\\sqrt{3}/2)a_0 (\\sqrt{3}/2)a_0 , respectively, where a_0 a_0 is the lattice_constant . Multiple modify commands with modify_style = dislocation can be employed to introduce multiple dislocations. line_axis and plane_axis are the dislocation line axis and the plane normal axis, respectively. They cannot be the same. modify_centroid_x , modify_centroid_y , and modify_centroid_z , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 and with respect to the lower boundaries of the simulation cell along the corresponding direction, are the coordinates of the origin with respect to which the displacement field is built. For example, if one wants to build a dislocation passing through the centroid of the simulation cell, these three quantities should be at the centroid. Note that in the coarse-grained and atomistic domains, the slip plane, which contains the dislocation along line_axis and has a normal direction plane_axis , should be located between two adjacent elements and two atomic layers, respectively. dis_angle and poisson_ratio are the dislcoation character angle (in degrees) and the isotropic Poisson's ratio of the material, respectively.","title":"Second syntax (modify_style = dislocation)"},{"location":"chapter-5/modify/#third-syntax-modify_style-cutoff","text":"The third syntax deletes one atom from a pair of atoms (either real atoms in the atomistic domain or interpolated atoms in the coarse-grained domain) when they are too close, at the grain boundary. The situation that some atoms are too close to each other is usually a result of the overlap or grain origin displacements . Among all modify commands, there should be no more than one with modify_style = cutoff . depth and tolerance , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 along the grain stack direction , specify the size of the target region and the cutoff distance, respectively, as shown in the figure below. In most cases, tolerance should not be larger than or equal to the first nearest neighbor distance in a perfect lattice. At each grain boundary, a check is first conducted, within the region set by depth along the grain stack direction , on both the real atoms in the atomistic domain or the interpolated atoms in the coarse-grained doain. In the figure above, (i) all atoms in the red shaded region (grain I) will be run against those in the left green shaded region (grain II), (ii) all atoms in the right green shaded region (grain II) will be run against those in the blue shaded region (grain III). Within a pair, if both are real atoms, the one associated with a smaller grain_id is deleted; if one is a real atom and the other is an interpolated atom, the real atom is deleted; if both are interpolated atoms, the user will get an error message because it is impossible to delete a single interpolated atom from an element, which would violate the hyperelastic body assumption of an element.","title":"Third syntax (modify_style = cutoff)"},{"location":"chapter-5/modify/#fourth-syntax-modify_style-add95atom","text":"The fourth syntax adds additional atoms to the simulation cell built from scratch. It cannot add additional elements. The information of the atoms to be added is read from LAMMPS data files lmp_*.dat , where * is the id of the current modify command in cac.in . For example, if the commands look like this: modify del_sth delete cylinder x 0. 1. 0.94281 0. -0.33333 y inf inf 0. 1. 0. z inf inf 0. 0. 1. t t 3 50. 50. 1. 2. 5. modify add_first add_atom 1. 3. 2. modify create_dis dislocation 1 3 1. 20. 3.2 60. 0.36 modify add_second add_atom -1. 4. 2. then two files, naming, lmp_2.dat and lmp_4.dat should be provided. disp_x , disp_y , and disp_z , in units of the component of the lattice periodicity length vector \\vec{l'}_0 \\vec{l'}_0 and with respect to the lower boundaries of the simulation cell along the corresponding direction, are the displacement of the added atoms with respect to their original positions in lmp_*.dat . If disp_x , disp_y , and disp_z are all zero, the atoms are added as is. This modify_style can be useful in constructing models containing grain boundaries (GBs). For example, the GB region (which may not have energy minimized GB structures) of a bicrystal model may be deleted first, before the energy minimized GB structures presented in LAMMPS data files are added to the model. This can be realized by first using a modify command with modify_style = delete , followed by another modify command with modify_style = add_atom .","title":"Fourth syntax (modify_style = add_atom)"},{"location":"chapter-5/modify/#related-commands","text":"There cannot be fewer modify commands than modify_number . When there are too many modify commands in cac.in , those appearing later will be ignored. This command becomes irrelevant when boolean_restart = t or modify_number = 0, in which case there is no need for the modification information.","title":"Related commands"},{"location":"chapter-5/modify/#related-files","text":"model_modify.f90 , model_modify_interpo.f90 , model_add_atom.f90 , model_cutoff.f90 , model_cutoff_bd.f90 , model_dislocation.f90 , model_cg2at.f90 , model_delete.f90 , and model_rearrange.f90 .","title":"Related files"},{"location":"chapter-5/modify/#default","text":"None.","title":"Default"},{"location":"chapter-5/modify/#acknowledgements","text":"Rigelesaiyin Ji and Jaber R. Mianroodi are acknowledged for helpful discussions in implementing the second syntax.","title":"Acknowledgements"},{"location":"chapter-5/modify_num/","text":"Syntax modify_num modify_number modify_number = non-negative integer (<= 19) Examples modify_num 2 Description This command sets the number of modifications that are made to the elements/nodes/atoms that are built from scratch, i.e., when boolean_restart = f . Related commands The modification style is set by the modify command. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the modification information. Related files model_modify.f90 Default modify_num 0","title":"modify_num"},{"location":"chapter-5/modify_num/#syntax","text":"modify_num modify_number modify_number = non-negative integer (<= 19)","title":"Syntax"},{"location":"chapter-5/modify_num/#examples","text":"modify_num 2","title":"Examples"},{"location":"chapter-5/modify_num/#description","text":"This command sets the number of modifications that are made to the elements/nodes/atoms that are built from scratch, i.e., when boolean_restart = f .","title":"Description"},{"location":"chapter-5/modify_num/#related-commands","text":"The modification style is set by the modify command. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the modification information.","title":"Related commands"},{"location":"chapter-5/modify_num/#related-files","text":"model_modify.f90","title":"Related files"},{"location":"chapter-5/modify_num/#default","text":"modify_num 0","title":"Default"},{"location":"chapter-5/neighbor/","text":"Syntax neighbor bin_size neighbor_freq bin_size = non-negative real number neighbor_freq = positive integer Examples neighbor 1. 100 neighbor 2. 200 Description This command sets parameters for updating the neighbor list. In CAC simulatoins, each atom in the atomistic domain and each integration point in the coarse-grained domain maintain neighbor lists. Note that the non-integration point interpolated atoms in the coarse-grained domain do not maintain neighbor lists because their force/energy etc. are not calculated. bin_size , in Angstrom, sets the length of the bin, which adds to the cutoff distance r_\\mathrm{c} r_\\mathrm{c} of the interatomic potential . All atoms within r_\\mathrm{c} r_\\mathrm{c} + bin_size from an atom/integration point are the neighbors of this atom. Note that each edge length of the processor domain cannot be smaller than 2 \\cdot 2 \\cdot ( r_\\mathrm{c} r_\\mathrm{c} + bin_size ). neighbor_freq is the frequency with which a check of whether the neighbor list should be updated is conducted. The neighbor lists of all atoms/integration points are updated if, with respect to the nodal/atomic positions recorded at the last check, any node or atom has a displacement larger than half the bin_size . Related commands The initial number of neighboring atoms per atom/integration point is set in the limit command. Related files neighbor_init.f90 and update_neighbor.f90 Default neighbor 1. 200","title":"neighbor"},{"location":"chapter-5/neighbor/#syntax","text":"neighbor bin_size neighbor_freq bin_size = non-negative real number neighbor_freq = positive integer","title":"Syntax"},{"location":"chapter-5/neighbor/#examples","text":"neighbor 1. 100 neighbor 2. 200","title":"Examples"},{"location":"chapter-5/neighbor/#description","text":"This command sets parameters for updating the neighbor list. In CAC simulatoins, each atom in the atomistic domain and each integration point in the coarse-grained domain maintain neighbor lists. Note that the non-integration point interpolated atoms in the coarse-grained domain do not maintain neighbor lists because their force/energy etc. are not calculated. bin_size , in Angstrom, sets the length of the bin, which adds to the cutoff distance r_\\mathrm{c} r_\\mathrm{c} of the interatomic potential . All atoms within r_\\mathrm{c} r_\\mathrm{c} + bin_size from an atom/integration point are the neighbors of this atom. Note that each edge length of the processor domain cannot be smaller than 2 \\cdot 2 \\cdot ( r_\\mathrm{c} r_\\mathrm{c} + bin_size ). neighbor_freq is the frequency with which a check of whether the neighbor list should be updated is conducted. The neighbor lists of all atoms/integration points are updated if, with respect to the nodal/atomic positions recorded at the last check, any node or atom has a displacement larger than half the bin_size .","title":"Description"},{"location":"chapter-5/neighbor/#related-commands","text":"The initial number of neighboring atoms per atom/integration point is set in the limit command.","title":"Related commands"},{"location":"chapter-5/neighbor/#related-files","text":"neighbor_init.f90 and update_neighbor.f90","title":"Related files"},{"location":"chapter-5/neighbor/#default","text":"neighbor 1. 200","title":"Default"},{"location":"chapter-5/potential/","text":"Syntax potential potential_type potential_type = lj or eam lj is the Lennard-Johns potential eam is the embedded-atom method potential Examples potential lj potential eam Description This command sets the interatomic potentials. Currently, a CAC simulation accepts two potential_style : Lennard-Johns ( lj ) and embedded-atom method ( eam ) potentials. One file for the lj potential and four files for the eam potential , respectively, should be provided as input. Related commands None. Related files potential.f90 , eam_tab.f90 , deriv_tab.f90 , and lj_para.f90 . Default None.","title":"potential"},{"location":"chapter-5/potential/#syntax","text":"potential potential_type potential_type = lj or eam lj is the Lennard-Johns potential eam is the embedded-atom method potential","title":"Syntax"},{"location":"chapter-5/potential/#examples","text":"potential lj potential eam","title":"Examples"},{"location":"chapter-5/potential/#description","text":"This command sets the interatomic potentials. Currently, a CAC simulation accepts two potential_style : Lennard-Johns ( lj ) and embedded-atom method ( eam ) potentials. One file for the lj potential and four files for the eam potential , respectively, should be provided as input.","title":"Description"},{"location":"chapter-5/potential/#related-commands","text":"None.","title":"Related commands"},{"location":"chapter-5/potential/#related-files","text":"potential.f90 , eam_tab.f90 , deriv_tab.f90 , and lj_para.f90 .","title":"Related files"},{"location":"chapter-5/potential/#default","text":"None.","title":"Default"},{"location":"chapter-5/refine/","text":"Syntax refine refine_style refine_group_number unitype refine_style = all or group refine_group_number , unitype = positive integer Examples refine all 1 6 refine group 1 12 refine group 2 6 Description This command sets refinement styles when boolean_restart_refine = t . There are two refine_style : all or group , which refines all or some elements into atomic scale , respectively. When refine_style = all , all elements in the coarse-grained domain are refined into atomic scale. This is used when, e.g., the user wants to perform an equivalent full atomistic simulation using the PyCAC code. Currently, this option is correctly trigered only when all elements have the same size, i.e., the same unitype had been used in all coarse-grained subdomains based on which the cac_in.restart file was created. In the first example, the cac_in.restart file refers to a simulation cell with elements each of which has (6+1)^3 = 343 (6+1)^3 = 343 atoms. When refine_style = group , selected elements in the group_in_*.id files (where * is a positive integer starting from 1) in the coarse-grained domain are refined into atomic scale. The number of groups to be refined is refine_group_number . As a result, the number of group_in_*.id files should be larger than or equal to refine_group_number . Note that refine_group_number is irrevelant when refine_style = all , and unitype is irrevelant when refine_style = group . Related commands This command becomes irrelevant when boolean_restart_refine = f , in which case there is no need for the refinement information. Related files refine_init.f90 Default None.","title":"refine"},{"location":"chapter-5/refine/#syntax","text":"refine refine_style refine_group_number unitype refine_style = all or group refine_group_number , unitype = positive integer","title":"Syntax"},{"location":"chapter-5/refine/#examples","text":"refine all 1 6 refine group 1 12 refine group 2 6","title":"Examples"},{"location":"chapter-5/refine/#description","text":"This command sets refinement styles when boolean_restart_refine = t . There are two refine_style : all or group , which refines all or some elements into atomic scale , respectively. When refine_style = all , all elements in the coarse-grained domain are refined into atomic scale. This is used when, e.g., the user wants to perform an equivalent full atomistic simulation using the PyCAC code. Currently, this option is correctly trigered only when all elements have the same size, i.e., the same unitype had been used in all coarse-grained subdomains based on which the cac_in.restart file was created. In the first example, the cac_in.restart file refers to a simulation cell with elements each of which has (6+1)^3 = 343 (6+1)^3 = 343 atoms. When refine_style = group , selected elements in the group_in_*.id files (where * is a positive integer starting from 1) in the coarse-grained domain are refined into atomic scale. The number of groups to be refined is refine_group_number . As a result, the number of group_in_*.id files should be larger than or equal to refine_group_number . Note that refine_group_number is irrevelant when refine_style = all , and unitype is irrevelant when refine_style = group .","title":"Description"},{"location":"chapter-5/refine/#related-commands","text":"This command becomes irrelevant when boolean_restart_refine = f , in which case there is no need for the refinement information.","title":"Related commands"},{"location":"chapter-5/refine/#related-files","text":"refine_init.f90","title":"Related files"},{"location":"chapter-5/refine/#default","text":"None.","title":"Default"},{"location":"chapter-5/restart/","text":"Syntax restart boolean_restart boolean_restart_refine boolean_restart , boolean_restart_refine = t or f t is true f is false Examples restart f f restart t f restart t t Description This command sets the restart styles. When boolean_restart = t , the code reads the elements/nodes/atoms information from the cac_in.restart file; otherwise, the simulation cell is built from scratch and boolean_restart_refine becomes f regardless of it value set in this command. When boolean_restart_refine = t , all or some elements in the coarse-grained domain are refined to atomic scale by linear interpolation from the nodal positions. Which elements to be refined depends on the refine_style . Related commands When boolean_restart_refine = f , the refine command becomes irrelevant, in which case there is no need for the refinement information. Related files read_restart.f90 and write_restart.f90 Default restart f f","title":"restart"},{"location":"chapter-5/restart/#syntax","text":"restart boolean_restart boolean_restart_refine boolean_restart , boolean_restart_refine = t or f t is true f is false","title":"Syntax"},{"location":"chapter-5/restart/#examples","text":"restart f f restart t f restart t t","title":"Examples"},{"location":"chapter-5/restart/#description","text":"This command sets the restart styles. When boolean_restart = t , the code reads the elements/nodes/atoms information from the cac_in.restart file; otherwise, the simulation cell is built from scratch and boolean_restart_refine becomes f regardless of it value set in this command. When boolean_restart_refine = t , all or some elements in the coarse-grained domain are refined to atomic scale by linear interpolation from the nodal positions. Which elements to be refined depends on the refine_style .","title":"Description"},{"location":"chapter-5/restart/#related-commands","text":"When boolean_restart_refine = f , the refine command becomes irrelevant, in which case there is no need for the refinement information.","title":"Related commands"},{"location":"chapter-5/restart/#related-files","text":"read_restart.f90 and write_restart.f90","title":"Related files"},{"location":"chapter-5/restart/#default","text":"restart f f","title":"Default"},{"location":"chapter-5/run/","text":"Syntax run total_step time_step total_step = non-negative integer time_step = positive real number Examples run 10000 0.002 Description This command sets the total step and time step of a CAC simulation. total_step is the total simulation step of dynamic/hybrid CAC simulations or the total loading increment of quasistatic CAC simulations. time_step , in ps, is the time step in dynamic CAC simulations, dynamic part in hybrid CAC simulations, and some quasistatic simulations when mini_style = fire or qm . It is also used in the fix command when assign_style = disp . Related commands time_step becomes irrelevant when simulation_style = statics with mini_style = cg or sd . When boolean_restart = t , the total_step is added to the time stamp read from the cac_in.restart file, instead of overriding it. Related files dynamics_init.f90 , dynamics.f90 , and hybrid.f90 . Default run 0 0.002","title":"run"},{"location":"chapter-5/run/#syntax","text":"run total_step time_step total_step = non-negative integer time_step = positive real number","title":"Syntax"},{"location":"chapter-5/run/#examples","text":"run 10000 0.002","title":"Examples"},{"location":"chapter-5/run/#description","text":"This command sets the total step and time step of a CAC simulation. total_step is the total simulation step of dynamic/hybrid CAC simulations or the total loading increment of quasistatic CAC simulations. time_step , in ps, is the time step in dynamic CAC simulations, dynamic part in hybrid CAC simulations, and some quasistatic simulations when mini_style = fire or qm . It is also used in the fix command when assign_style = disp .","title":"Description"},{"location":"chapter-5/run/#related-commands","text":"time_step becomes irrelevant when simulation_style = statics with mini_style = cg or sd . When boolean_restart = t , the total_step is added to the time stamp read from the cac_in.restart file, instead of overriding it.","title":"Related commands"},{"location":"chapter-5/run/#related-files","text":"dynamics_init.f90 , dynamics.f90 , and hybrid.f90 .","title":"Related files"},{"location":"chapter-5/run/#default","text":"run 0 0.002","title":"Default"},{"location":"chapter-5/simulator/","text":"Syntax simulator simulation_style simulation_style = dynamics or statics or hybrid Examples simulator dynamics simulator hybrid Description This command sets the simulation_style in CAC simulations: dynamics (dynamic CAC), statics (quasistatic CAC), or hybrid (dynamic CAC with periodic energy minimization). The former two simulation_style have different schemes . Related commands More style information for a CAC simulation is set in the dynamics and minimize commands. Related files dynamics.f90 , quasi_statics.f90 , and hybrid.f90 Default simulator dynamics","title":"simulator"},{"location":"chapter-5/simulator/#syntax","text":"simulator simulation_style simulation_style = dynamics or statics or hybrid","title":"Syntax"},{"location":"chapter-5/simulator/#examples","text":"simulator dynamics simulator hybrid","title":"Examples"},{"location":"chapter-5/simulator/#description","text":"This command sets the simulation_style in CAC simulations: dynamics (dynamic CAC), statics (quasistatic CAC), or hybrid (dynamic CAC with periodic energy minimization). The former two simulation_style have different schemes .","title":"Description"},{"location":"chapter-5/simulator/#related-commands","text":"More style information for a CAC simulation is set in the dynamics and minimize commands.","title":"Related commands"},{"location":"chapter-5/simulator/#related-files","text":"dynamics.f90 , quasi_statics.f90 , and hybrid.f90","title":"Related files"},{"location":"chapter-5/simulator/#default","text":"simulator dynamics","title":"Default"},{"location":"chapter-5/subdomain/","text":"Syntax subdomain {grain_id subdomain_number} grain_id , subdomain_number = positve integer Examples subdomain {1 1} subdomain {1 2} {2 3} subdomain {1 1 2 1 3 1} Description This command sets the number of subdomains in each grain. Note that the curly brackets { and } in the syntax/examples are to separate different grains, the number of which is grain_number ; all brackets should not be included in preparing cac.in . In CAC, a unit is either the primitive unit cell of the lattice (for the atomistic domain) or a finite element (for the coarse-grained domain). Finite elements of different sizes are different types of unit. In a CAC simulation cell, each spatial region consisting of the same type of unit is a subdomain, as illustrated in the figure below: Note that in this figure, which is Fig. 4 of Xu et al., 2018 , the atoms in subdomain i/grain I and subdomain i/grain III are employed to fill in the otherwise jagged interstices, because either boolean_y = f or y = p . The size of each subdomain and the unit type in each subdomain in each grain is specified in the unit_num and unit_type commands, respectively. The grains and subdomains are stacked along a prescribed direction . The three examples above correspond to the three examples in the unit_num and unit_type commands: In the first example, there is one grain designated by the first 1 , which has one subdomain designated by the second 1 . In the second example, there are two grains: the first grain has two subdomains designated by the first 2 , the second grain has three subdomains designated by 3 . In the third example, there are three grains, each of which has one subdomain, designated by the second 1 , the third 1 , and the fourth 1 , respectively. The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded. Related commands In the unit_num and unit_type commands, the maximum subdomain_id in each grain must equal the corresponding subdomain_number . This command becomes irrelevant when boolean_restart = t , in which case there is no need for the subdomain information. Related files box_init.f90 Default subdomain 1 1","title":"subdomain"},{"location":"chapter-5/subdomain/#syntax","text":"subdomain {grain_id subdomain_number} grain_id , subdomain_number = positve integer","title":"Syntax"},{"location":"chapter-5/subdomain/#examples","text":"subdomain {1 1} subdomain {1 2} {2 3} subdomain {1 1 2 1 3 1}","title":"Examples"},{"location":"chapter-5/subdomain/#description","text":"This command sets the number of subdomains in each grain. Note that the curly brackets { and } in the syntax/examples are to separate different grains, the number of which is grain_number ; all brackets should not be included in preparing cac.in . In CAC, a unit is either the primitive unit cell of the lattice (for the atomistic domain) or a finite element (for the coarse-grained domain). Finite elements of different sizes are different types of unit. In a CAC simulation cell, each spatial region consisting of the same type of unit is a subdomain, as illustrated in the figure below: Note that in this figure, which is Fig. 4 of Xu et al., 2018 , the atoms in subdomain i/grain I and subdomain i/grain III are employed to fill in the otherwise jagged interstices, because either boolean_y = f or y = p . The size of each subdomain and the unit type in each subdomain in each grain is specified in the unit_num and unit_type commands, respectively. The grains and subdomains are stacked along a prescribed direction . The three examples above correspond to the three examples in the unit_num and unit_type commands: In the first example, there is one grain designated by the first 1 , which has one subdomain designated by the second 1 . In the second example, there are two grains: the first grain has two subdomains designated by the first 2 , the second grain has three subdomains designated by 3 . In the third example, there are three grains, each of which has one subdomain, designated by the second 1 , the third 1 , and the fourth 1 , respectively. The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded.","title":"Description"},{"location":"chapter-5/subdomain/#related-commands","text":"In the unit_num and unit_type commands, the maximum subdomain_id in each grain must equal the corresponding subdomain_number . This command becomes irrelevant when boolean_restart = t , in which case there is no need for the subdomain information.","title":"Related commands"},{"location":"chapter-5/subdomain/#related-files","text":"box_init.f90","title":"Related files"},{"location":"chapter-5/subdomain/#default","text":"subdomain 1 1","title":"Default"},{"location":"chapter-5/temperature/","text":"Syntax temperature boolean temp boolean = t or f t is true f is false temp = non-negative real number Examples temperature t 10. temperature t 300. Description This command sets whether the temperature is kept a constant in the system ( boolean ) for the dynamic and hybrid CAC simulations; and if yes, what is the desired temperature in K ( temp ). A constant zero temperature is maintained in the system only when dyn_style = ld or qd , i.e., Langevin dynamics or quenched dynamics. Note that in this case, the equation of motion for the Langevin dynamics reduces to that for the damped dynamics . A constant finite temperature is maintained in the system only when dyn_style = ld , i.e., Langevin dynamics. The user will get a warning message if temp is finite and if dyn_style = qd . In quasi-static simulations, boolean must be f and the temperature, which is effectively 0 K, is irrelevant. Related commands If boolean = t and dyn_style = vv , the user will get a warning message and the temperature temp becomes irrelevant, because the Velocity Verlet option cannot maintain a constant temperature. Related files thermostat.f90 , langevin_dynamics.f90 , and langevin_vel.f90 Default temperature t 10.","title":"temperature"},{"location":"chapter-5/temperature/#syntax","text":"temperature boolean temp boolean = t or f t is true f is false temp = non-negative real number","title":"Syntax"},{"location":"chapter-5/temperature/#examples","text":"temperature t 10. temperature t 300.","title":"Examples"},{"location":"chapter-5/temperature/#description","text":"This command sets whether the temperature is kept a constant in the system ( boolean ) for the dynamic and hybrid CAC simulations; and if yes, what is the desired temperature in K ( temp ). A constant zero temperature is maintained in the system only when dyn_style = ld or qd , i.e., Langevin dynamics or quenched dynamics. Note that in this case, the equation of motion for the Langevin dynamics reduces to that for the damped dynamics . A constant finite temperature is maintained in the system only when dyn_style = ld , i.e., Langevin dynamics. The user will get a warning message if temp is finite and if dyn_style = qd . In quasi-static simulations, boolean must be f and the temperature, which is effectively 0 K, is irrelevant.","title":"Description"},{"location":"chapter-5/temperature/#related-commands","text":"If boolean = t and dyn_style = vv , the user will get a warning message and the temperature temp becomes irrelevant, because the Velocity Verlet option cannot maintain a constant temperature.","title":"Related commands"},{"location":"chapter-5/temperature/#related-files","text":"thermostat.f90 , langevin_dynamics.f90 , and langevin_vel.f90","title":"Related files"},{"location":"chapter-5/temperature/#default","text":"temperature t 10.","title":"Default"},{"location":"chapter-5/unit_num/","text":"Syntax unit_num {grain_id [subdomain_id x unit_num_x y unit_num_y z unit_num_z]} grain_id , subdomoain_id = positive integer unit_num_x , unit_num_y , unit_num_z = positive integer Examples unit_num {1 [1 x 2 y 3 z 4]} unit_num {1 [1 x 8 y 20 z 12] [2 x 40 y 2 z 60]} {2 [1 x 40 y 1 z 60] [2 x 8 y 25 z 12] [3 x 6 y 7 z 10]} unit_num {1 [1 x 2 y 3 z 4]} {2 [1 x 6 y 1 z 2]} {3 [1 x 10 y 2 z 3]} Description This command sets the size of each subdomain along three directions in each grain. The unit_num_x , unit_num_y , and unit_num_z are in units of the x , y , and z length of the projection of the unit (primitive unit cell in the atomistic domain or the finite element in the coarse-grained domain) on the yz , xz , and xy planes, respectively. Similar to the unit_type command, this command consists of two loops. The outer loop, illustrated by {} , is based on grain; the inner loop, illustrated by [] , is based on subdomain. Note that the curly brackets { and } as well as the square brackets [ and ] in the syntax/examples are to separate different grains and subdomains, the number of which are grain_number and subdomain_number , respectively; all brackets should not be included in preparing cac.in . When grain_number > 1 and/or subdomain_number > 1, the size of each subdomain set directly by this command is most likely not the same, which may be problematic in some cases, e.g., in a bicrystal, as shown in Fig. (a) below, in which the subdomain i/grain I has a larger z length than the other subdomains. Since the grain stack direction is y , the size of all other subdomains along the x and z directions will be increased to match that of the subdomain i/grain I, respectively, as shown in Fig. (b) below. The three examples above correspond to the three examples in the subdomain command. The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded. Within each grain, the maximum subdomain_id must equal the corresponding subdomain_number . Related commands This command becomes irrelevant when boolean_restart = t , in which case there is no need for the subdomain information. Related files box_init.f90 and model_init.f90 Default None.","title":"unit_num"},{"location":"chapter-5/unit_num/#syntax","text":"unit_num {grain_id [subdomain_id x unit_num_x y unit_num_y z unit_num_z]} grain_id , subdomoain_id = positive integer unit_num_x , unit_num_y , unit_num_z = positive integer","title":"Syntax"},{"location":"chapter-5/unit_num/#examples","text":"unit_num {1 [1 x 2 y 3 z 4]} unit_num {1 [1 x 8 y 20 z 12] [2 x 40 y 2 z 60]} {2 [1 x 40 y 1 z 60] [2 x 8 y 25 z 12] [3 x 6 y 7 z 10]} unit_num {1 [1 x 2 y 3 z 4]} {2 [1 x 6 y 1 z 2]} {3 [1 x 10 y 2 z 3]}","title":"Examples"},{"location":"chapter-5/unit_num/#description","text":"This command sets the size of each subdomain along three directions in each grain. The unit_num_x , unit_num_y , and unit_num_z are in units of the x , y , and z length of the projection of the unit (primitive unit cell in the atomistic domain or the finite element in the coarse-grained domain) on the yz , xz , and xy planes, respectively. Similar to the unit_type command, this command consists of two loops. The outer loop, illustrated by {} , is based on grain; the inner loop, illustrated by [] , is based on subdomain. Note that the curly brackets { and } as well as the square brackets [ and ] in the syntax/examples are to separate different grains and subdomains, the number of which are grain_number and subdomain_number , respectively; all brackets should not be included in preparing cac.in . When grain_number > 1 and/or subdomain_number > 1, the size of each subdomain set directly by this command is most likely not the same, which may be problematic in some cases, e.g., in a bicrystal, as shown in Fig. (a) below, in which the subdomain i/grain I has a larger z length than the other subdomains. Since the grain stack direction is y , the size of all other subdomains along the x and z directions will be increased to match that of the subdomain i/grain I, respectively, as shown in Fig. (b) below. The three examples above correspond to the three examples in the subdomain command. The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded. Within each grain, the maximum subdomain_id must equal the corresponding subdomain_number .","title":"Description"},{"location":"chapter-5/unit_num/#related-commands","text":"This command becomes irrelevant when boolean_restart = t , in which case there is no need for the subdomain information.","title":"Related commands"},{"location":"chapter-5/unit_num/#related-files","text":"box_init.f90 and model_init.f90","title":"Related files"},{"location":"chapter-5/unit_num/#default","text":"None.","title":"Default"},{"location":"chapter-5/unit_type/","text":"Syntax unit_type {grain_id [subdomain_id unitype]} grain_id , subdomain_id = positive integer unitype = 1 or positive even integer (>= 2 if intpo_depth = 1 , >= 4 if intpo_depth = 2 ) Examples unit_type {1 [1 12]} unit_type {1 [1 1] [2 8]} {2 [1 6] [2 16] [3 10]} unit_type {1 [1 14]} {2 [1 1]} {3 [1 6]} Description The command sets the unit type in each subdomain in each grain. Similar to the unit_num command, this command consists of two loops. The outer loop, illustrated by {} , is based on grain; the inner loop, illustrated by [] , is based on subdomain. Note that the curly brackets { and } as well as the square brackets [ and ] in the syntax/examples are to separate different grains and subdomains, the number of which are grain_number and subdomain_number , respectively; all brackets should not be included in preparing cac.in . The number of atoms per unit is (\\mathrm{unitype}+1)^3 (\\mathrm{unitype}+1)^3 , where unitype must be either 1 (atomistic domain) or an even integer that is no less than 2 if intpo_depth = 1 and no less than 4 if intpo_depth = 2 (coarse-grained domain): in the latter case, (i) it must be even because of the first order Gaussian quadrature employed to solve the governing equations , (ii) it must be >= 2 or >=4 because of the first nearest neighbor (1NN) element and second nearest neighbor (2NN) element have 27 and 125 integration points, respectively (so there cannot be fewer than 27 and 125 atoms in one element, respectively). For more information of the 1NN/2NN element and the Gaussian quadrature implementation, read Appendices A and B of Xu et al., 2015 . The three examples above correspond to the three examples in the subdomain command: In the first example, there is only one grain, designated by the first 1 , having only one subdomain, designated by the second 1 , with the unitype = 12 . In the second example, there are two grains, designated by the first 1 and the second 2 , respectively. The first grain has two subdomains: the first is atomistics because unitype = 1 ; the second contains elements each of which has (8+1)^3 = 729 (8+1)^3 = 729 atoms. The second grain has three subdomains: the first contains elements each of which has (6+1)^3 = 343 (6+1)^3 = 343 atoms; the second contains elements each of which has (16+1)^3 = 4913 (16+1)^3 = 4913 atoms; the third contains elements each of which has (10+1)^3 = 1331 (10+1)^3 = 1331 atoms. In the third example, there are three grains, each of which contains one unit type. Note that the second grain is atomistics because unitype = 1 . The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded. Within each grain, the maximum subdomain_id must equal the corresponding subdomain_number . Related commands This command becomes irrelevant when boolean_restart = t , in which case there is no need for the subdomain information. Related files model_init.f90 Default None.","title":"unit_type"},{"location":"chapter-5/unit_type/#syntax","text":"unit_type {grain_id [subdomain_id unitype]} grain_id , subdomain_id = positive integer unitype = 1 or positive even integer (>= 2 if intpo_depth = 1 , >= 4 if intpo_depth = 2 )","title":"Syntax"},{"location":"chapter-5/unit_type/#examples","text":"unit_type {1 [1 12]} unit_type {1 [1 1] [2 8]} {2 [1 6] [2 16] [3 10]} unit_type {1 [1 14]} {2 [1 1]} {3 [1 6]}","title":"Examples"},{"location":"chapter-5/unit_type/#description","text":"The command sets the unit type in each subdomain in each grain. Similar to the unit_num command, this command consists of two loops. The outer loop, illustrated by {} , is based on grain; the inner loop, illustrated by [] , is based on subdomain. Note that the curly brackets { and } as well as the square brackets [ and ] in the syntax/examples are to separate different grains and subdomains, the number of which are grain_number and subdomain_number , respectively; all brackets should not be included in preparing cac.in . The number of atoms per unit is (\\mathrm{unitype}+1)^3 (\\mathrm{unitype}+1)^3 , where unitype must be either 1 (atomistic domain) or an even integer that is no less than 2 if intpo_depth = 1 and no less than 4 if intpo_depth = 2 (coarse-grained domain): in the latter case, (i) it must be even because of the first order Gaussian quadrature employed to solve the governing equations , (ii) it must be >= 2 or >=4 because of the first nearest neighbor (1NN) element and second nearest neighbor (2NN) element have 27 and 125 integration points, respectively (so there cannot be fewer than 27 and 125 atoms in one element, respectively). For more information of the 1NN/2NN element and the Gaussian quadrature implementation, read Appendices A and B of Xu et al., 2015 . The three examples above correspond to the three examples in the subdomain command: In the first example, there is only one grain, designated by the first 1 , having only one subdomain, designated by the second 1 , with the unitype = 12 . In the second example, there are two grains, designated by the first 1 and the second 2 , respectively. The first grain has two subdomains: the first is atomistics because unitype = 1 ; the second contains elements each of which has (8+1)^3 = 729 (8+1)^3 = 729 atoms. The second grain has three subdomains: the first contains elements each of which has (6+1)^3 = 343 (6+1)^3 = 343 atoms; the second contains elements each of which has (16+1)^3 = 4913 (16+1)^3 = 4913 atoms; the third contains elements each of which has (10+1)^3 = 1331 (10+1)^3 = 1331 atoms. In the third example, there are three grains, each of which contains one unit type. Note that the second grain is atomistics because unitype = 1 . The maximum grain_id must be larger than or equal to grain_number . All information related to grain_id that is larger than grain_number is discarded. Within each grain, the maximum subdomain_id must equal the corresponding subdomain_number .","title":"Description"},{"location":"chapter-5/unit_type/#related-commands","text":"This command becomes irrelevant when boolean_restart = t , in which case there is no need for the subdomain information.","title":"Related commands"},{"location":"chapter-5/unit_type/#related-files","text":"model_init.f90","title":"Related files"},{"location":"chapter-5/unit_type/#default","text":"None.","title":"Default"},{"location":"chapter-5/zigzag/","text":"Syntax zigzag boolean_x boolean_y boolean_z boolean_x , boolean_y , boolean_z = t or f t is true f is false Examples zigzag t f f zigzag t t t Description This command decides whether the simulation cell boundaries are left zigzagged along the x , y , and z directions, respectively. Due to the rhombohedral shape of the finite elements in the coarse-grained domain, the simulation cell mostly likely has zigzagged boundaries, as shown in Fig. C27(a) of Xu et al., 2015 . On the other hand, flat boundaries are sometimes desirable to enforce the periodic boundary conditions or to lower the aphysical stress concentrations at the boundaries. If one of the three booleans in this command is f , atoms will be filled in the corresponding jagged interstices, resulting in flat boundaries normal to the corresponding direction, unless the boundaries were already flat with rhomboheral elements, e.g., parallel to a {111} plane in an FCC lattice or to a {110} plane in a BCC lattice. Examples of the filled atoms include Fig. C27(b) of Xu et al., 2015 and the figure for the subdomain command in which the atoms are filled in at the leftmost and rightmost simulation cell boundaries. If a certain boolean is t , no atoms will be filled in at the boundaries. Related commands When a boundary is periodic , the corresponding zigzag boolean becomes f , regardless of what is set in this command, because the periodic boundaries must be flat in CAC simulations. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the boundary shape information. Related files model_init.f90 Default zigzag t t t","title":"zigzag"},{"location":"chapter-5/zigzag/#syntax","text":"zigzag boolean_x boolean_y boolean_z boolean_x , boolean_y , boolean_z = t or f t is true f is false","title":"Syntax"},{"location":"chapter-5/zigzag/#examples","text":"zigzag t f f zigzag t t t","title":"Examples"},{"location":"chapter-5/zigzag/#description","text":"This command decides whether the simulation cell boundaries are left zigzagged along the x , y , and z directions, respectively. Due to the rhombohedral shape of the finite elements in the coarse-grained domain, the simulation cell mostly likely has zigzagged boundaries, as shown in Fig. C27(a) of Xu et al., 2015 . On the other hand, flat boundaries are sometimes desirable to enforce the periodic boundary conditions or to lower the aphysical stress concentrations at the boundaries. If one of the three booleans in this command is f , atoms will be filled in the corresponding jagged interstices, resulting in flat boundaries normal to the corresponding direction, unless the boundaries were already flat with rhomboheral elements, e.g., parallel to a {111} plane in an FCC lattice or to a {110} plane in a BCC lattice. Examples of the filled atoms include Fig. C27(b) of Xu et al., 2015 and the figure for the subdomain command in which the atoms are filled in at the leftmost and rightmost simulation cell boundaries. If a certain boolean is t , no atoms will be filled in at the boundaries.","title":"Description"},{"location":"chapter-5/zigzag/#related-commands","text":"When a boundary is periodic , the corresponding zigzag boolean becomes f , regardless of what is set in this command, because the periodic boundaries must be flat in CAC simulations. This command becomes irrelevant when boolean_restart = t , in which case there is no need for the boundary shape information.","title":"Related commands"},{"location":"chapter-5/zigzag/#related-files","text":"model_init.f90","title":"Related files"},{"location":"chapter-5/zigzag/#default","text":"zigzag t t t","title":"Default"},{"location":"chapter-6/","text":"Post-processing A CAC simulation outputs a lot of files, most of which are dump.* and *.vtk files that can be visualized and analyzed using OVITO , ParaView , and a data analyzer , respectively. As of June 2017, the latest versions of the first two software, OVITO 2.8.2 and ParaView 5.4 , are compatiable with the CAC results. The stress-strain curve and the simulation step-temperature curve can be plotted by processing the stress_strain and temperature files, respectively, using common graphing software such as MATLAB , Octave , Origin , SigmaPlot , and gnuplot .","title":"Introduction"},{"location":"chapter-6/#post-processing","text":"A CAC simulation outputs a lot of files, most of which are dump.* and *.vtk files that can be visualized and analyzed using OVITO , ParaView , and a data analyzer , respectively. As of June 2017, the latest versions of the first two software, OVITO 2.8.2 and ParaView 5.4 , are compatiable with the CAC results. The stress-strain curve and the simulation step-temperature curve can be plotted by processing the stress_strain and temperature files, respectively, using common graphing software such as MATLAB , Octave , Origin , SigmaPlot , and gnuplot .","title":"Post-processing"},{"location":"chapter-6/analyzer/","text":"A data analyzer is provided in the analyzer directory. vtk2dump A file vtk2dump.f90 is provided in the directory analyzer/vtk2dump to convert at most two *.vtk files to a dump.* file. To compile it, simply ifort vtk2dump.f90 -o vtk2dump or gfortran vtk2dump.f90 -o vtk2dump To run the code, simply ./vtk2dump The executable then reads at most three files, namely, cac_cg_#.vtk , cac_atom_#.vtk , and vtk2dump.in . From cac_cg_#.vtk , the atomic positions inside the elements are linearly interpolated from the nodes; from cac_atom_#.vtk , the atomic positions are read as is. Then both interpolated atoms and real atoms are written into a dump.# file. Here, # , a positive integer, is provided by the step in the vtk2dump.in file, whose syntax is boolean_cg boolean_at step x boolean_user lower_b upper_b y boolean_user lower_b upper_b z boolean_user lower_b upper_b boolean_cg , boolean_at , boolean_user = t or f x , y , z = p or s lower_b , upper_b = real number For example, t t 34 p t 0. 100. s f p f -50. 150. boolean_cg and boolean_at decide whether the files cac_cg_#.vtk and cac_atom_#.vtk are involved in the conversion, respectively. For example, if boolean_cg = t and boolean_at = f , only cac_cg_#.vtk is converted. In the example, step = 34, meaning that files cac_cg_34.vtk and/or cac_atom_34.vtk should be prepared, and the output file is dump.34 . x , y , and z set the boundary conditions along the x , y , and z directions, respectively. If boolean_user = t , it should be followed by lower_b and upper_b , in units of Angstrom, which provide user-defined lower and upper bounds of the simulation cell along the corresponding direction. If boolean_user = f , lower_b and upper_b , e.g., -50. and 150. in the last line of the example, become irrelevant; in this case, the two bounds along a certain direction are calculated using the nodal and atomic positions in the two *.vtk files.","title":"Data analyzer"},{"location":"chapter-6/analyzer/#vtk2dump","text":"A file vtk2dump.f90 is provided in the directory analyzer/vtk2dump to convert at most two *.vtk files to a dump.* file. To compile it, simply ifort vtk2dump.f90 -o vtk2dump or gfortran vtk2dump.f90 -o vtk2dump To run the code, simply ./vtk2dump The executable then reads at most three files, namely, cac_cg_#.vtk , cac_atom_#.vtk , and vtk2dump.in . From cac_cg_#.vtk , the atomic positions inside the elements are linearly interpolated from the nodes; from cac_atom_#.vtk , the atomic positions are read as is. Then both interpolated atoms and real atoms are written into a dump.# file. Here, # , a positive integer, is provided by the step in the vtk2dump.in file, whose syntax is boolean_cg boolean_at step x boolean_user lower_b upper_b y boolean_user lower_b upper_b z boolean_user lower_b upper_b boolean_cg , boolean_at , boolean_user = t or f x , y , z = p or s lower_b , upper_b = real number For example, t t 34 p t 0. 100. s f p f -50. 150. boolean_cg and boolean_at decide whether the files cac_cg_#.vtk and cac_atom_#.vtk are involved in the conversion, respectively. For example, if boolean_cg = t and boolean_at = f , only cac_cg_#.vtk is converted. In the example, step = 34, meaning that files cac_cg_34.vtk and/or cac_atom_34.vtk should be prepared, and the output file is dump.34 . x , y , and z set the boundary conditions along the x , y , and z directions, respectively. If boolean_user = t , it should be followed by lower_b and upper_b , in units of Angstrom, which provide user-defined lower and upper bounds of the simulation cell along the corresponding direction. If boolean_user = f , lower_b and upper_b , e.g., -50. and 150. in the last line of the example, become irrelevant; in this case, the two bounds along a certain direction are calculated using the nodal and atomic positions in the two *.vtk files.","title":"vtk2dump"},{"location":"chapter-6/ovito/","text":"A series of dump.# files, containing the positions of the atoms (both the real atoms in the atomistic domain and the interpolated atoms in the coarse-grained domain), are created by the output component of the Python interface , with a frequency of output_freq . A dump.lammps file which, in addition to the nodal/atomic positions, may also contain the nodal/atomic velocities information if simulation_style = dynamics or hybrid , is also created in the beginning of the simulation. All these dump.* files can be read and analyzed by OVITO --- The Open Visualization Tool , which provides a variety of analyses. A common usage of OVITO to process the dump.* files is to visualize the dislocations. First, import any dump.# file into OVITO. Then load the Dislocation analysis (DXA) modifier and deselect the Particles in Display . This approach applies to both the FCC and BCC metals. To visualize lattice defects other than dislocations, e.g., stacking faults, twin boundaries, other modifiers . For FCC metals, the Common neighbor analysis modifier can be loaded, followed by that selected FCC particles are deleted to visualize the defects. For BCC metals, the Centrosymmetry parameter modifier can be loaded, then atoms with a large Centrosymmetry parameter are selected and deleted to visualize the defects.","title":"OVITO"},{"location":"chapter-6/paraview/","text":"In a CAC simulation, a series of cac_cg_#.vtk and cac_atom_#.vtk files, containing the nodal/atomic position/energy/force/stress information, are created on-the-fly , with a frequency of output_freq . A model_cg.vtk file, a model_atom.vtk , and possibly some group_cg_#.vtk and group_atom_#.vtk files (when the total number of new group, restart group > 0) are also created in the beginning of the simulation. All these *.vtk files, with the legacy formats as opposed to the XML formats , can be read and analyzed by ParaView , which provides a variety of analyses. In most cases, a CAC simulation cell contains both the atomistic and coarse-grained domain, and so a pair of cac_cg_#.vtk and cac_atom_#.vtk files (with the same integer # ) should be loaded into ParaView at the same time.","title":"ParaView"},{"location":"chapter-7/","text":"Example problems The PyCAC distribution includes an examples sub-directory with some sample problems: Stationary dislocations Dislocation migration Screw dislocation cross-slip Dislocation multiplication Dislocation/obstacle interactions Dislocation/stacking fault interactions Dislocation/coherent twin boundary interactions","title":"Contents"},{"location":"chapter-7/#example-problems","text":"The PyCAC distribution includes an examples sub-directory with some sample problems: Stationary dislocations Dislocation migration Screw dislocation cross-slip Dislocation multiplication Dislocation/obstacle interactions Dislocation/stacking fault interactions Dislocation/coherent twin boundary interactions","title":"Example problems"},{"location":"chapter-7/example1/dislocation/","text":"FCC Al, Mishin EAM potential , 2197 atoms per element in the coarse-grained domain. Results using larger models and/or in other metals are published in Xu et al., 2015 and Xu et al., 2016 . In the figures below, the atoms that fill in the jagged interstices are not shown for a better visualization of the elements; the nodes are colorred by the in-plane shear stress. Langevin dynamic simulation at 10 K is carried out, with periodic energy minimization using the conjugate gradient method. Edge dislocation The figure below and the logfile are produced using the input file and rendered by ParaView . Screw dislocation The figure below and the log file are produced using the input file and rendered by ParaView . 30^\\circ 30^\\circ mixed type dislocation The figure below and the log file are produced using the input file and rendered by ParaView . 60^\\circ 60^\\circ mixed type dislocation The figure below and the log file are produced using the input file and rendered by ParaView , similar to Fig. 8(c) of Xu et al., 2015 .","title":"Stationary dislocations"},{"location":"chapter-7/example1/dislocation/#edge-dislocation","text":"The figure below and the logfile are produced using the input file and rendered by ParaView .","title":"Edge dislocation"},{"location":"chapter-7/example1/dislocation/#screw-dislocation","text":"The figure below and the log file are produced using the input file and rendered by ParaView .","title":"Screw dislocation"},{"location":"chapter-7/example1/dislocation/#30circ30circ-mixed-type-dislocation","text":"The figure below and the log file are produced using the input file and rendered by ParaView .","title":"30^\\circ30^\\circ mixed type dislocation"},{"location":"chapter-7/example1/dislocation/#60circ60circ-mixed-type-dislocation","text":"The figure below and the log file are produced using the input file and rendered by ParaView , similar to Fig. 8(c) of Xu et al., 2015 .","title":"60^\\circ60^\\circ mixed type dislocation"},{"location":"chapter-7/example2/dislocation-migration/","text":"FCC Cu, Mishin EAM potential , 2197 atoms per element in the coarse-grained domain. Results using larger models are published in Sec. 5.4 of Xu et al., 2015 . 60^\\circ 60^\\circ mixed type dislocation migration from the atomistic domain to the coarse-grained domain In the figure below, an indenter (red box) is displaced continously along the [0\\bar{1}\\bar{1}] [0\\bar{1}\\bar{1}] direction to nucleate dislocations from the free surface in the atomistic domain. Note that the atoms that fill in the jagged interstices are not shown for a better visualization of the elements, similar to Fig. 14(b) of Xu et al., 2015 . The dislocations then migrate into the coarse-grained domain. Energy minimization using the conjugate gradient method is conducted at every simulation step. The movie below and the log file are produced using the input file](at2cg.in) and rendered by OVITO : Your browser does not support the video tag. 60^\\circ 60^\\circ mixed type dislocation migration from the coarse-grained domain to the atomistic domain In the figure below, an indenter (red box) is displaced continously along the [0\\bar{1}\\bar{1}] [0\\bar{1}\\bar{1}] direction to nucleate dislocations from the free surface in the coarse-grained domain. Note that the atoms that fill in the jagged interstices are not shown for better visualization of the elements, similar to Fig. 14(c) of Xu et al., 2015 . The dislocations then migrate into the atomistic domain. Energy minimization using the conjugate gradient method is conducted at every simulation step. The movie below and the log file are produced using the input file and rendered by OVITO . Your browser does not support the video tag.","title":"Dislocation migration across the atomistic/coarse-grained domain interface"},{"location":"chapter-7/example2/dislocation-migration/#60circ60circ-mixed-type-dislocation-migration-from-the-atomistic-domain-to-the-coarse-grained-domain","text":"In the figure below, an indenter (red box) is displaced continously along the [0\\bar{1}\\bar{1}] [0\\bar{1}\\bar{1}] direction to nucleate dislocations from the free surface in the atomistic domain. Note that the atoms that fill in the jagged interstices are not shown for a better visualization of the elements, similar to Fig. 14(b) of Xu et al., 2015 . The dislocations then migrate into the coarse-grained domain. Energy minimization using the conjugate gradient method is conducted at every simulation step. The movie below and the log file are produced using the input file](at2cg.in) and rendered by OVITO : Your browser does not support the video tag.","title":"60^\\circ60^\\circ mixed type dislocation migration from the atomistic domain to the coarse-grained domain"},{"location":"chapter-7/example2/dislocation-migration/#60circ60circ-mixed-type-dislocation-migration-from-the-coarse-grained-domain-to-the-atomistic-domain","text":"In the figure below, an indenter (red box) is displaced continously along the [0\\bar{1}\\bar{1}] [0\\bar{1}\\bar{1}] direction to nucleate dislocations from the free surface in the coarse-grained domain. Note that the atoms that fill in the jagged interstices are not shown for better visualization of the elements, similar to Fig. 14(c) of Xu et al., 2015 . The dislocations then migrate into the atomistic domain. Energy minimization using the conjugate gradient method is conducted at every simulation step. The movie below and the log file are produced using the input file and rendered by OVITO . Your browser does not support the video tag.","title":"60^\\circ60^\\circ mixed type dislocation migration from the coarse-grained domain to the atomistic domain"},{"location":"chapter-7/example3/cross-slip/","text":"FCC Cu, Mishin EAM potential , 1331 atoms per element in the coarse-grained domain. Results using larger models are published in Xu et al., 2017 . In the figure below, the atoms that fill in the jagged interstices are not shown for a better visualization of the elements. In the Langevin dynamic simulation, a screw dislocation on the (\\bar{1}1\\bar{1}) (\\bar{1}1\\bar{1}) plane is first created; then subject to a \\gamma_{zy} \\gamma_{zy} simple shear strain, it crosses slip onto the (1\\bar{1}\\bar{1}) (1\\bar{1}\\bar{1}) . The movie below and the log file are produced using the input file and rendered by OVITO :","title":"Screw dislocation cross-slip"},{"location":"chapter-7/example4/frank-read/","text":"FCC Al, Mishin EAM potential , 2197 atoms per element in the coarse-grained domain. Results using larger models are published in Xu et al., 2016 and Xu et al., 2016 . In the figure below, two cylindrical holes are carved out to serve as the Frank-Read source. The atoms and elements in figure (b) are colored by the atomic and nodal energy, respectively, and are sliced on the xz xz plane to highlight the holes. In the hybrid simulation, an edge dislocation is first created between the two holes; then subject to a \\gamma_{zy} \\gamma_{zy} simple shear strain, it bows out and form a dislocation loop, leaving behind another edge dislocation segment between the two holes. The movie below and the log file are produced using the input file and rendered by OVITO :","title":"Dislocation multiplication from a Frank-Read source"},{"location":"chapter-7/example5/dislocation-obstacle/","text":"FCC Ni, Mishin EAM potential , 2197 atoms per element in the coarse-grained domain. The spherical obstacle, with a radius of about 1 nm, is either a void or a precipitate. Results using larger models were presented at the 2017 MRS Spring Meeting . Dislocation/void interactions In the figure below, the atomistic domain is sliced on the xz xz plane for a better visualization of the void (atoms are colored by the atomic energy in the initial configuration). In the Langevin dynamic simulation, an edge dislocation on the (\\bar{1}1\\bar{1}) (\\bar{1}1\\bar{1}) plane is first created; then subject to a \\gamma_{zy} \\gamma_{zy} simple shear strain, it migrates toward the void and bypasses it following the shearing mechanism. The movie below and the log file are produced using the input file and rendered by OVITO : Dislocation/precipitate interactions In the figure below, the atomistic domain is sliced on the xz xz plane for a better visualization of the precipitate (atoms colored in white). In the Langevin dynamic simulation, an edge dislocation on the (\\bar{1}1\\bar{1}) (\\bar{1}1\\bar{1}) plane is first created; then subject to a \\gamma_{zy} \\gamma_{zy} simple shear strain, it migrates toward the precipitate and bypasses it following the Orowan looping mechanism. The movie below and the log file are produced using the input file and rendered by OVITO : Note that the screw components of the Orowan loop begin to cross slip at about 24 s. The precipitate is not shown here.","title":"Dislocation/obstacle interactions"},{"location":"chapter-7/example5/dislocation-obstacle/#dislocationvoid-interactions","text":"In the figure below, the atomistic domain is sliced on the xz xz plane for a better visualization of the void (atoms are colored by the atomic energy in the initial configuration). In the Langevin dynamic simulation, an edge dislocation on the (\\bar{1}1\\bar{1}) (\\bar{1}1\\bar{1}) plane is first created; then subject to a \\gamma_{zy} \\gamma_{zy} simple shear strain, it migrates toward the void and bypasses it following the shearing mechanism. The movie below and the log file are produced using the input file and rendered by OVITO :","title":"Dislocation/void interactions"},{"location":"chapter-7/example5/dislocation-obstacle/#dislocationprecipitate-interactions","text":"In the figure below, the atomistic domain is sliced on the xz xz plane for a better visualization of the precipitate (atoms colored in white). In the Langevin dynamic simulation, an edge dislocation on the (\\bar{1}1\\bar{1}) (\\bar{1}1\\bar{1}) plane is first created; then subject to a \\gamma_{zy} \\gamma_{zy} simple shear strain, it migrates toward the precipitate and bypasses it following the Orowan looping mechanism. The movie below and the log file are produced using the input file and rendered by OVITO : Note that the screw components of the Orowan loop begin to cross slip at about 24 s. The precipitate is not shown here.","title":"Dislocation/precipitate interactions"},{"location":"chapter-7/example6/dislocation-sf/","text":"FCC Ag, Williams EAM potential , 343 atoms per element in the coarse-grained domain. Results using larger models are published in Xu et al., 2017 . In the figure below, the atoms that fill in the jagged interstices are not shown for a better visualization of the elements. In the Langevin dynamic simulation, a screw dislocation on the (1\\bar{1}1) (1\\bar{1}1) plane and an intrinsic stacking fault on the (\\bar{1}11) (\\bar{1}11) plane are first created; then subject to a \\gamma_{zx} \\gamma_{zx} simple shear strain, the dislocation moves toward and is then transmitted across the stacking fault directly. The movie below and the log file are produced using the input file and rendered by OVITO :","title":"Dislocation/stacking fault interactions"},{"location":"chapter-7/example7/dislocation-ctb/","text":"FCC Ni, Mishin EAM potential , 2197 atoms per element in the coarse-grained domain. Results using larger models and/or in other metals are published in Xu et al., 2016 and Xu et al., 2017 . In the figure below, the atoms that fill in the jagged interstices are not shown for a better visualization of the elements. In the Langevin dynamic simulation, a screw dislocation on the (1\\bar{1}1) (1\\bar{1}1) plane is first created; then subject to a \\gamma_{zx} \\gamma_{zx} simple shear strain, the dislocation moves toward and is then transmitted across the \\Sigma 3 \\Sigma 3 {111} coherent twin boundary. The movie below and the log file are produced using the input file and rendered by OVITO :","title":"Dislocaton/coherent twin boundary interaction"},{"location":"chapter-8/","text":"This chapter provides miscellaneous information that is important but does not fit into other chapters.","title":"Introduction"},{"location":"chapter-8/eam/","text":"As mentioned earlier , the EAM formulation for the potential energy is E = \\frac{1}{2}\\sum_i\\sum_{j \\atop j\\neq i} V_{ij}(r_{ij}) + \\sum_i F(\\bar{\\rho}_i) E = \\frac{1}{2}\\sum_i\\sum_{j \\atop j\\neq i} V_{ij}(r_{ij}) + \\sum_i F(\\bar{\\rho}_i) where V V <span><span class=\"MathJax_Preview\">V</span><script type=\"math/tex\">V is the pair potential, F F <span><span class=\"MathJax_Preview\">F</span><script type=\"math/tex\">F is the embedding potential, and \\bar{\\rho} \\bar{\\rho} <span><span class=\"MathJax_Preview\">\\bar{\\rho}</span><script type=\"math/tex\">\\bar{\\rho} is the host electron density, i.e., \\bar{\\rho}_i = \\sum_{j \\atop j \\neq i} \\rho_{ij}(r_{ij}) \\bar{\\rho}_i = \\sum_{j \\atop j \\neq i} \\rho_{ij}(r_{ij}) where \\rho_{ij} \\rho_{ij} <span><span class=\"MathJax_Preview\">\\rho_{ij}</span><script type=\"math/tex\">\\rho_{ij} is the local electron density contributed by atom j j <span><span class=\"MathJax_Preview\">j</span><script type=\"math/tex\">j at site i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i . Let \\mathbf{r}_{ji} \\mathbf{r}_{ji} <span><span class=\"MathJax_Preview\">\\mathbf{r}_{ji}</span><script type=\"math/tex\">\\mathbf{r}_{ji} be the vector from atom j j <span><span class=\"MathJax_Preview\">j</span><script type=\"math/tex\">j to atom i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i with norm r_{ji} (= r_{ij}) r_{ji} (= r_{ij}) <span><span class=\"MathJax_Preview\">r_{ji} (= r_{ij})</span><script type=\"math/tex\">r_{ji} (= r_{ij}) , i.e., \\mathbf{r}_{ji} = \\mathbf{r}_i - \\mathbf{r}_j \\mathbf{r}_{ji} = \\mathbf{r}_i - \\mathbf{r}_j r_{ji} = \\sqrt{(r_i^x - r_j^x)^2 + (r_i^y - r_j^y)^2 + (r_i^z - r_j^z)^2} r_{ji} = \\sqrt{(r_i^x - r_j^x)^2 + (r_i^y - r_j^y)^2 + (r_i^z - r_j^z)^2} where \\mathbf{r}_j = r_j^x\\mathbf{e}^x + r_j^y\\mathbf{e}^y + r_j^z\\mathbf{e}^z \\mathbf{r}_j = r_j^x\\mathbf{e}^x + r_j^y\\mathbf{e}^y + r_j^z\\mathbf{e}^z Now, let's prove an important identity, \\frac{\\partial r_{ji}}{\\partial \\mathbf{r}_j} = \\frac{\\partial r_{ji}}{\\partial r_j^x} \\mathbf{e}^x + \\frac{\\partial r_{ji}}{\\partial r_j^y} \\mathbf{e}^y + \\frac{\\partial r_{ji}}{\\partial r_j^z} \\mathbf{e}^z = - \\frac{r_{ji}^x}{r_{ji}} \\mathbf{e}^x - \\frac{r_{ji}^y}{r_{ji}} \\mathbf{e}^y - \\frac{r_{ji}^z}{r_{ji}} \\mathbf{e}^z = -\\frac{\\mathbf{r}_{ji}}{r_{ji}} \\frac{\\partial r_{ji}}{\\partial \\mathbf{r}_j} = \\frac{\\partial r_{ji}}{\\partial r_j^x} \\mathbf{e}^x + \\frac{\\partial r_{ji}}{\\partial r_j^y} \\mathbf{e}^y + \\frac{\\partial r_{ji}}{\\partial r_j^z} \\mathbf{e}^z = - \\frac{r_{ji}^x}{r_{ji}} \\mathbf{e}^x - \\frac{r_{ji}^y}{r_{ji}} \\mathbf{e}^y - \\frac{r_{ji}^z}{r_{ji}} \\mathbf{e}^z = -\\frac{\\mathbf{r}_{ji}}{r_{ji}} which will be used in the force formulation derivation later. The force on atom k k <span><span class=\"MathJax_Preview\">k</span><script type=\"math/tex\">k is \\mathbf{f}_k = -\\frac{\\partial E}{\\partial \\mathbf{r}_k} = -\\frac{1}{2} \\frac{\\partial \\sum_i \\sum_{j \\atop j \\neq i}V_{ij}(r_{ij})}{\\partial \\mathbf{r}_k}-\\frac{\\partial \\sum_i F(\\bar{\\rho}_i)}{\\partial \\mathbf{r}_k} \\mathbf{f}_k = -\\frac{\\partial E}{\\partial \\mathbf{r}_k} = -\\frac{1}{2} \\frac{\\partial \\sum_i \\sum_{j \\atop j \\neq i}V_{ij}(r_{ij})}{\\partial \\mathbf{r}_k}-\\frac{\\partial \\sum_i F(\\bar{\\rho}_i)}{\\partial \\mathbf{r}_k} The first term in the force formulation is non-zero only when k k <span><span class=\"MathJax_Preview\">k</span><script type=\"math/tex\">k is either i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i or j j <span><span class=\"MathJax_Preview\">j</span><script type=\"math/tex\">j , thus it becomes -\\frac{1}{2} \\left[\\frac{\\partial \\sum_{j \\atop j \\neq k} V_{kj}(r_{kj})}{\\partial \\mathbf{r}_k}+\\frac{\\partial \\sum_{i \\atop k \\neq i}V_{ik}(r_{ik})}{\\partial \\mathbf{r}_k}\\right] = -\\frac{1}{2} \\left[\\frac{\\partial \\sum_{j \\atop j \\neq k} V_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\partial r_{kj}}{\\partial \\mathbf{r}_k} - \\frac{\\partial \\sum_{i \\atop k \\neq i}V_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\partial r_{ik}}{\\partial \\mathbf{r}_k}\\right] -\\frac{1}{2} \\left[\\frac{\\partial \\sum_{j \\atop j \\neq k} V_{kj}(r_{kj})}{\\partial \\mathbf{r}_k}+\\frac{\\partial \\sum_{i \\atop k \\neq i}V_{ik}(r_{ik})}{\\partial \\mathbf{r}_k}\\right] = -\\frac{1}{2} \\left[\\frac{\\partial \\sum_{j \\atop j \\neq k} V_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\partial r_{kj}}{\\partial \\mathbf{r}_k} - \\frac{\\partial \\sum_{i \\atop k \\neq i}V_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\partial r_{ik}}{\\partial \\mathbf{r}_k}\\right] With the help of the identity, the term becomes \\frac{1}{2} \\left[\\frac{\\partial \\sum_{j \\atop j \\neq k} V_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\mathbf{r}_{kj}}{r_{kj}} - \\frac{\\partial \\sum_{i \\atop k \\neq i}V_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\mathbf{r}_{ik}}{r_{ik}}\\right] \\frac{1}{2} \\left[\\frac{\\partial \\sum_{j \\atop j \\neq k} V_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\mathbf{r}_{kj}}{r_{kj}} - \\frac{\\partial \\sum_{i \\atop k \\neq i}V_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\mathbf{r}_{ik}}{r_{ik}}\\right] where V_{kj} V_{kj} <span><span class=\"MathJax_Preview\">V_{kj}</span><script type=\"math/tex\">V_{kj} and V_{ik} V_{ik} <span><span class=\"MathJax_Preview\">V_{ik}</span><script type=\"math/tex\">V_{ik} are the pair potentials for the atomic pairs kj kj <span><span class=\"MathJax_Preview\">kj</span><script type=\"math/tex\">kj and ik ik <span><span class=\"MathJax_Preview\">ik</span><script type=\"math/tex\">ik , respectively, while V_{kj} = V_{jk} V_{kj} = V_{jk} <span><span class=\"MathJax_Preview\">V_{kj} = V_{jk}</span><script type=\"math/tex\">V_{kj} = V_{jk} and V_{ik} = V_{ki} V_{ik} = V_{ki} <span><span class=\"MathJax_Preview\">V_{ik} = V_{ki}</span><script type=\"math/tex\">V_{ik} = V_{ki} . Since V V <span><span class=\"MathJax_Preview\">V</span><script type=\"math/tex\">V is atom type-specific, V_{kj} V_{kj} <span><span class=\"MathJax_Preview\">V_{kj}</span><script type=\"math/tex\">V_{kj} and V_{ik} V_{ik} <span><span class=\"MathJax_Preview\">V_{ik}</span><script type=\"math/tex\">V_{ik} are likely not the same unless atom i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i and j j <span><span class=\"MathJax_Preview\">j</span><script type=\"math/tex\">j are of the same type. Thus, if there are two types of atoms in the system, there will be three V V <span><span class=\"MathJax_Preview\">V</span><script type=\"math/tex\">V , between type 1 and type 1, between type 2 and type 2, and between type 1 and type 2. The second term in the force formulation can be written as -\\sum_i\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\mathbf{r}_k} = -\\sum_i\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\frac{\\partial \\bar{\\rho}_i}{\\partial \\mathbf{r}_k} = -\\sum_i\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\sum_{j \\atop j \\neq i}\\frac{\\partial \\rho_{ij}(r_{ij})}{\\partial \\mathbf{r}_k} = -\\sum_i\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\sum_{j \\atop j \\neq i}\\frac{\\partial \\rho_{ij}(r_{ij})}{\\partial r_{ij}}\\frac{\\partial r_{ij}}{\\partial \\mathbf{r}_k} -\\sum_i\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\mathbf{r}_k} = -\\sum_i\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\frac{\\partial \\bar{\\rho}_i}{\\partial \\mathbf{r}_k} = -\\sum_i\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\sum_{j \\atop j \\neq i}\\frac{\\partial \\rho_{ij}(r_{ij})}{\\partial \\mathbf{r}_k} = -\\sum_i\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\sum_{j \\atop j \\neq i}\\frac{\\partial \\rho_{ij}(r_{ij})}{\\partial r_{ij}}\\frac{\\partial r_{ij}}{\\partial \\mathbf{r}_k} which is non-zero when k k <span><span class=\"MathJax_Preview\">k</span><script type=\"math/tex\">k is either i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i or j j <span><span class=\"MathJax_Preview\">j</span><script type=\"math/tex\">j , i.e., the term becomes -\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}\\sum_{j \\atop j \\neq k}\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\partial r_{kj}}{\\partial \\mathbf{r}_k}-\\sum_{i \\atop i \\neq k}\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\frac{\\partial \\rho_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\partial r_{ik}}{\\partial \\mathbf{r}_k} -\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}\\sum_{j \\atop j \\neq k}\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\partial r_{kj}}{\\partial \\mathbf{r}_k}-\\sum_{i \\atop i \\neq k}\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\frac{\\partial \\rho_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\partial r_{ik}}{\\partial \\mathbf{r}_k} Again, with the help of the identify, the term becomes \\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}\\sum_{j \\atop j \\neq k}\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\mathbf{r}_{kj}}{r_{kj}}-\\sum_{i \\atop i \\neq k}\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\frac{\\partial \\rho_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\mathbf{r}_{ik}}{r_{ik}} \\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}\\sum_{j \\atop j \\neq k}\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\mathbf{r}_{kj}}{r_{kj}}-\\sum_{i \\atop i \\neq k}\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\frac{\\partial \\rho_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\mathbf{r}_{ik}}{r_{ik}} Note that \\rho_{kj} \\rho_{kj} <span><span class=\"MathJax_Preview\">\\rho_{kj}</span><script type=\"math/tex\">\\rho_{kj} is the local electron density contributed by atom j j <span><span class=\"MathJax_Preview\">j</span><script type=\"math/tex\">j at site k k <span><span class=\"MathJax_Preview\">k</span><script type=\"math/tex\">k . In general, \\rho_{kj} \\neq \\rho_{jk} \\rho_{kj} \\neq \\rho_{jk} <span><span class=\"MathJax_Preview\">\\rho_{kj} \\neq \\rho_{jk}</span><script type=\"math/tex\">\\rho_{kj} \\neq \\rho_{jk} . This is different from the pair potential V V <span><span class=\"MathJax_Preview\">V</span><script type=\"math/tex\">V , for which generally V_{kj} = V_{jk} V_{kj} = V_{jk} <span><span class=\"MathJax_Preview\">V_{kj} = V_{jk}</span><script type=\"math/tex\">V_{kj} = V_{jk} . Also, generally \\rho_{kj} \\neq \\rho_{ij} \\rho_{kj} \\neq \\rho_{ij} <span><span class=\"MathJax_Preview\">\\rho_{kj} \\neq \\rho_{ij}</span><script type=\"math/tex\">\\rho_{kj} \\neq \\rho_{ij} unless atom k k <span><span class=\"MathJax_Preview\">k</span><script type=\"math/tex\">k and atom i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i are of the same type. In classical EAM , \\rho_{kj} = \\rho_{ij} \\rho_{kj} = \\rho_{ij} <span><span class=\"MathJax_Preview\">\\rho_{kj} = \\rho_{ij}</span><script type=\"math/tex\">\\rho_{kj} = \\rho_{ij} even when atom k k <span><span class=\"MathJax_Preview\">k</span><script type=\"math/tex\">k and atom i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i are of different type. If there are two types of atoms in the system, there are only two \\rho \\rho <span><span class=\"MathJax_Preview\">\\rho</span><script type=\"math/tex\">\\rho , for the contribution from type 1 atom and for that from type 2 atom, regardless of which type of atomic site it contributes to. This is different from the pair potential V V <span><span class=\"MathJax_Preview\">V</span><script type=\"math/tex\">V , which would have three expressions in this case. Extensions of \\rho \\rho <span><span class=\"MathJax_Preview\">\\rho</span><script type=\"math/tex\">\\rho to distinguish contributions at different types of atomic sites have been proposed, e.g., in the Finnis-Sinclair potential . Adding the two terms in the force formulation together yields \\mathbf{f}_k = \\frac{1}{2} \\left[\\frac{\\partial \\sum_{j \\atop j \\neq k} V_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\mathbf{r}_{kj}}{r_{kj}}-\\frac{\\partial \\sum_{i \\atop k \\neq i}V_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\mathbf{r}_{ik}}{r_{ik}}\\right] + \\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}\\sum_{j \\atop j \\neq k}\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\mathbf{r}_{kj}}{r_{kj}}-\\sum_{i \\atop i \\neq k}\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\frac{\\partial \\rho_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\mathbf{r}_{ik}}{r_{ik}} \\mathbf{f}_k = \\frac{1}{2} \\left[\\frac{\\partial \\sum_{j \\atop j \\neq k} V_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\mathbf{r}_{kj}}{r_{kj}}-\\frac{\\partial \\sum_{i \\atop k \\neq i}V_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\mathbf{r}_{ik}}{r_{ik}}\\right] + \\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}\\sum_{j \\atop j \\neq k}\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\frac{\\mathbf{r}_{kj}}{r_{kj}}-\\sum_{i \\atop i \\neq k}\\frac{\\partial F(\\bar{\\rho}_i)}{\\partial \\bar{\\rho}_i}\\frac{\\partial \\rho_{ik}(r_{ik})}{\\partial r_{ik}}\\frac{\\mathbf{r}_{ik}}{r_{ik}} Since i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i and j j <span><span class=\"MathJax_Preview\">j</span><script type=\"math/tex\">j are just dummy indices, it is safe to replace all i i <span><span class=\"MathJax_Preview\">i</span><script type=\"math/tex\">i with j j <span><span class=\"MathJax_Preview\">j</span><script type=\"math/tex\">j . After that, with \\mathbf{r}_{jk} = -\\mathbf{r}_{kj} \\mathbf{r}_{jk} = -\\mathbf{r}_{kj} <span><span class=\"MathJax_Preview\">\\mathbf{r}_{jk} = -\\mathbf{r}_{kj}</span><script type=\"math/tex\">\\mathbf{r}_{jk} = -\\mathbf{r}_{kj} , r_{jk} = r_{kj} r_{jk} = r_{kj} <span><span class=\"MathJax_Preview\">r_{jk} = r_{kj}</span><script type=\"math/tex\">r_{jk} = r_{kj} , V_{jk} = V_{kj} V_{jk} = V_{kj} <span><span class=\"MathJax_Preview\">V_{jk} = V_{kj}</span><script type=\"math/tex\">V_{jk} = V_{kj} , and \\rho_{jk} \\neq \\rho_{kj} \\rho_{jk} \\neq \\rho_{kj} <span><span class=\"MathJax_Preview\">\\rho_{jk} \\neq \\rho_{kj}</span><script type=\"math/tex\">\\rho_{jk} \\neq \\rho_{kj} , the force on atom k k <span><span class=\"MathJax_Preview\">k</span><script type=\"math/tex\">k becomes \\mathbf{f}_k = \\sum_{j \\atop j \\neq k}\\left[\\frac{\\partial V_{kj}(r_{kj})}{\\partial r_{kj}}+\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}+\\frac{\\partial F(\\bar{\\rho}_j)}{\\partial \\bar{\\rho}_j}\\frac{\\partial \\rho_{jk}(r_{kj})}{\\partial r_{kj}}\\right]\\frac{\\mathbf{r}_{kj}}{r_{kj}} \\mathbf{f}_k = \\sum_{j \\atop j \\neq k}\\left[\\frac{\\partial V_{kj}(r_{kj})}{\\partial r_{kj}}+\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}+\\frac{\\partial F(\\bar{\\rho}_j)}{\\partial \\bar{\\rho}_j}\\frac{\\partial \\rho_{jk}(r_{kj})}{\\partial r_{kj}}\\right]\\frac{\\mathbf{r}_{kj}}{r_{kj}} If there is only type of atoms in the system, \\rho_{jk} = \\rho_{kj} \\rho_{jk} = \\rho_{kj} <span><span class=\"MathJax_Preview\">\\rho_{jk} = \\rho_{kj}</span><script type=\"math/tex\">\\rho_{jk} = \\rho_{kj} , and the force formulation is simplified to \\mathbf{f}_k = \\sum_{j \\atop j \\neq k}\\left[\\frac{\\partial V_{kj}(r_{kj})}{\\partial r_{kj}}+\\left(\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}+\\frac{\\partial F(\\bar{\\rho}_j)}{\\partial \\bar{\\rho}_j}\\right)\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\right]\\frac{\\mathbf{r}_{kj}}{r_{kj}} \\mathbf{f}_k = \\sum_{j \\atop j \\neq k}\\left[\\frac{\\partial V_{kj}(r_{kj})}{\\partial r_{kj}}+\\left(\\frac{\\partial F(\\bar{\\rho}_k)}{\\partial \\bar{\\rho}_k}+\\frac{\\partial F(\\bar{\\rho}_j)}{\\partial \\bar{\\rho}_j}\\right)\\frac{\\partial \\rho_{kj}(r_{kj})}{\\partial r_{kj}}\\right]\\frac{\\mathbf{r}_{kj}}{r_{kj}} which is Equation 15 of Xu et al. Note that the last two equations hold for both classical EAM and Finnis-Sinclair potentials, because the relation between \\rho_{kj} \\rho_{kj} <span><span class=\"MathJax_Preview\">\\rho_{kj}</span><script type=\"math/tex\">\\rho_{kj} and \\rho_{ij} \\rho_{ij} <span><span class=\"MathJax_Preview\">\\rho_{ij}</span><script type=\"math/tex\">\\rho_{ij} is not used during the derivation.","title":"EAM potential"},{"location":"chapter-8/element-node-diff/","text":"In the group command, style_cg can be either element , node , or null . For element , if the centroid of an element is inside or outside (depending on boolean_in ) group_shape , this element and all its nodes belong to the group. For node , if some nodes of an element is inside or outside (depending on boolean_in ) group_shape , this element and these nodes belong to the group. The difference between element and node is explained in the figure below, where red elements (solid lines) and nodes (small spheres) belong to the group (large sphere) with group_shape = sphere .","title":"Element vs. node"},{"location":"chapter-8/lattice-space/","text":"The length of periodicity of the lattice is the minimum distance at which the lattice repeats itself. For example, the lattice constant a_0 a_0 in cubic crystal systems is the lattice periodicity length along the \\left<100\\right> \\left<100\\right> directions. Once the crystallographic orientations are set, e.g., the x x axis in the first grain has an orientation of [abc] [abc] , the lattice will repeat itself at every \\sqrt{a^2 + b^2 + c^2}a_0 \\sqrt{a^2 + b^2 + c^2}a_0 distance along the x x direction. In the simple cubic system, this distance is likely the smallest lattice periodicity length. But in the face-centered cubic (FCC) and body-centered cubic (BCC) systems, this may not be the case. For example, in FCC, when [abc] = [112] [abc] = [112] , \\sqrt{a^2 + b^2 + c^2}a_0 = \\sqrt{6}a_0 \\sqrt{a^2 + b^2 + c^2}a_0 = \\sqrt{6}a_0 , yet the smallest lattice periodicity length l_0 = (\\sqrt{6}/2)a_0 l_0 = (\\sqrt{6}/2)a_0 . Another example is in BCC, when [abc] = [111] [abc] = [111] , \\sqrt{a^2 + b^2 + c^2}a_0 = \\sqrt{3}a_0 \\sqrt{a^2 + b^2 + c^2}a_0 = \\sqrt{3}a_0 , yet l_0 = (\\sqrt{3}/2)a_0 l_0 = (\\sqrt{3}/2)a_0 . Since each grain has its own crystallographic orientations, each grain has its own \\vec{l}_0 \\vec{l}_0 . The length vector along each direction that is the largest in magnitude among all grains is the lattice periodicity length for the simulation cell, \\vec{l'}_0 \\vec{l'}_0 . The largest component in the \\vec{l'}_0 \\vec{l'}_0 vector is the maximum lattice periodicity length for the simulation cell, l'_\\mathrm{max} l'_\\mathrm{max} . \\vec{l'}_0 \\vec{l'}_0 and l'_\\mathrm{max} l'_\\mathrm{max} are the length units in four commands : fix , grain_dir , group , and modify . A question arises regarding how the lengths in these four commands are usually determined. For example, to build a stationary edge dislocation , one needs to determine the position of the dislocation, i.e., using the modify_centroid_x , modify_centroid_y , and modify_centroid_z variables in the modify command. In the input file , there is one line modify modify_1 dislocation 1 3 13. 39. 17.333 90. 0.33 in which plane_axis = 3 means that the slip plane is normal to the z direction. As a result, the modify_centroid_z decides the z -coordinate of the intersection between the slip plane and the z axis. Since there is only one dislocation, one usually wants to let the slip plane be within the mid- z plane, but how is the value of modify_centroid_z , which equals 17.333 here, determined? In the log file , there are four lines: The boundaries of grain 1 prior to modification are (Angstrom) x from -0.413351394094665 to 128.552283563439630 length is 128.965634957534292 y from -0.715945615951370 to 222.659086560878961 length is 223.375032176830331 z from -29.228357377724798 to 213.951576004945480 length is 243.179933382670271 where the last number 243.179933382670271 is the edge length of the simulation cell along the z direction, prior to modification. Note that it is important to use the edge lengths of the grain prior to modification instead of those under The box boundaries/lengths are (Angstrom) because the former are used to build dislocations in the code. Another two lines in the log file are The lattice_space_max are x 4.960216729135929 y 2.863782463805506 z 7.014805770653949 where the last number 7.014805770653949 is the maximum lattice periodicity length for the simulation cell along the z direction, l'_\\mathrm{max} l'_\\mathrm{max} , which is indeed the length unit of modify_centroid_z . Thus, if one wants to let the slip plane be within the mid- z plane, the value of modify_centroid_z is 243.179933382670271 / 7.014805770653949 / 2 = 17.333","title":"Lattice periodicity length"},{"location":"chapter-8/rank/","text":"In MPI, rank is a logical way of numbering processors. The processor 1 has rank 0, the processor 2 has rank 1, and so on. In the PyCAC code, the integer root is set to 0 in processor_para_module.f90 . The processor 1, i.e., root , does heavy lifting in reading, writing, and collecting data from other processors.","title":"Processor rank"},{"location":"chapter-8/shared-element/","text":"One issue that does not exist in parallel atomistic simulations but requires special attention in parallel finite element implementations is that in the latter some elements may be shared between neighboring processors. In CAC, this issue originates from the difference in shape between the parallelepipedonal processor domain and the rhombohedral finite elements with arbitrary crystallographic orientations, the latter of which also results in the jagged simulation cell boundaries . Instead of having all relevant processors calculate the same quantities (e.g., force, energy, and virial) within a shared element, in the PyCAC code, each relevant processor only calculates quantities of the integration points its domain contains. Then these quantities are summed in the processor_equiv.f90 subroutine, after which all relevant processors have the same nodal quantities. This simple summation is feasible because of the trilinear shape function employed in the finite elements. To facilitate the shared element-related calculations, a public array tag_shared_ele and a public variable ele_shared_num are introduced. For example, processor 3 has 6 local elements, with the 2 nd , 4 th , and 5 th elements shared with other processors, then tag_ele_shared(1) = 0 tag_ele_shared(2) = 1 tag_ele_shared(3) = 0 tag_ele_shared(4) = 2 tag_ele_shared(5) = 3 tag_ele_shared(6) = 0 and ele_shared_num = 3 The array and the variable, defined in processor_scatter_cg.f90 and updated in update_neighbor_cg.f90 , are used in these three subroutines: processor_edenshost_intpo.f90 , processor_equiv.f90 , and processor_langevin_cg.f90 . Note that in current PyCAC code, the \"shared element communication\" process mentioned above does NOT involve a host processor as described in page 123 of Xu et al. , which was for a previous version. The host processor, which has the highest rank among all processors that share the same element, is indeed used in the code, but only for the purposes of (i) sending the element/node information to the root processor for output, e.g., in all_to_one_cg.f90 and all_to_one_group_cg.f90 , and (ii) calculating certain variables based on the global arrays, e.g., the global force norm force_norm calculated in conjugate_gradient.f90 , fire.f90 , langevin_vel.f90 , quenched_vel.f90 , quick_mini.f90 , steepest_descent.f90 , and update_vel.f90 . For example, when processor 2 and processor 3 share the same element (and thus have the same relevant nodal information), only one of them needs to send the information to root. The host processor is set in the processor_scatter_cg.f90 subroutine, in which the array who_has_ele(ie) = .true. for the host processor and .false. for non-host processors, where ie is the local element id.","title":"Shared elements"},{"location":"chapter-9/","text":"Code developer guide This chapter describes some algorithms and data structures of the PyCAC code. More information may be added in response to requests from developers and users.","title":"Introduction"},{"location":"chapter-9/#code-developer-guide","text":"This chapter describes some algorithms and data structures of the PyCAC code. More information may be added in response to requests from developers and users.","title":"Code developer guide"},{"location":"chapter-9/atom-atomap/","text":"atom There are some arrays with atom in their names, e.g., r_atom , vel_atom , force_atom , which respectively are the positions, velocities, and forces of real atoms in the atomistic domain. On the other hand, defined in atom_para_module.f90 , there are atom_num_l , which is the number of local atoms in each processor domain, atom_num_lg , which is the number of local AND ghost atoms in each processor domain, and atom_num_lr , which is the actual size of the second dimension of some atom -related arrays. The differences between atom_num_l , atom_num_lg , and atom_num_lr , as well as their relation with some atom -related arrays are explained below. Say that the system contains 100 atoms using three processors, then either read_restart.f90 (if one restarts a previous simulation) or model_assemble.f90 (if one builds the model from scratch), set by boolean_restart , will first calculate atom_num_l as atom_num_l = nint((real(atom_num, wp) / pro_num) * 1.2_wp) In our case, atom_num_l = 40, following which most atom -related arrays are allocated. Next, in processor_scatter_atomistic.f90 , one first lets atom_num_lr equal atom_num_l , then the root processor distributes all atoms to all processors (including root itself); if the actual number of local atoms one processor should have is larger than atom_num_lr , atom_num_lr is increased by seg_num which is 1024 as set in module/cac_para_module.f90 . In the meantime, many atom -related arrays also increase their size. Assume that the root processor should contain 50 local atoms while the other two processors 25 each, atom_num_lr becomes 40 + 1024 = 1064 for root but still 40 for the other two processors. At the end of this subroutine, some atom -related arrays, e.g., r_atom , have a size of 3 by 1064 for root while 3 by 40 for the other two processors; atom_num_l , which is expected to be the number of local atoms for each processor, is re-calculated to be 50 for root and 25 for the other two processors. Next, in processor_ghost_atomistic.f90 , the ghost atoms are added to the end of some atom -related arrays. Again, if the number of local+ghost atoms is larger than atom_num_lr , atom_num_lr is further increased by seg_num , along with the expansion in size of some atom -related arrays. Assume that the numbers of ghost atoms are 30, 10, and 20 for the three processors, respectively, atom_num_lr would be 1064 for root (because 50 + 30 < 1064), 40 for processor 1 (because 25 + 10 < 40), and 1064 for processor 2 (because 25 + 20 > 40). In other words, atom_num_lr increases for the last processor while remaining the same for the other two processors. At the end of this subroutine, atom_num_lg is assigned as the actual number of local + ghost atoms, i.e., 80, 35, and 45 for the three processors, respectively. In sum, atom_num_l <= atom_num_lg <= atom_num_lr . Note that (i) atom_num is the total number of real atoms in the system, i.e., 100, regardless of how many processors are involved and how many ghost atoms are needed; (ii) in the case of single processor, there may still be ghost atoms if periodic boundary conditions are used. atomap There are also some arrays with atomap in their names, e.g., r_atomap , which is the positions of interpolated atoms in the coarse-grained domain. On the other hand, defined in interpo_para_module.f90 , there are atomap_num_l , which is the number of interpolated atoms in each processor domain, atomap_num_lg , which is the number of local AND ghost interpolated atoms in each processor domain, and atomap_num_lr , which is the actual size of the second dimension of some atomap -related arrays. The differences between atomap_num_l , atomap_num_lg , and atomap_num_lr , as well as their relation with some atomap -related arrays are similar to those of atom -related variables and arrays, except that two other subroutines, processor_scatter_cg.f90 and processor_ghost_cg.f90 , are involved. Remark In PyCAC, arrays for the atomistic domain, e.g., atom -related arrays, and those for the coarse-grained domain, e.g., atomap -related, node -related, and ele -related arrays, are completely separated. Take the position vector as an example, a processor may simultaneously have a r_atom array and a r_atomap array, yet it only has a r_atom or a r_atomap array if the system only contains real or interpolated atoms, i.e., fully atomistic or fully coarse-grained models. If one wants to add an additional array to the atomistic domain, e.g., to distinguish between different types of real atoms, one almost always has to also add a similar array to the coarse-grained domain to distinguish different types of interpolated atoms, nodes, and elements.","title":"atom and atomap"},{"location":"chapter-9/atom-atomap/#atom","text":"There are some arrays with atom in their names, e.g., r_atom , vel_atom , force_atom , which respectively are the positions, velocities, and forces of real atoms in the atomistic domain. On the other hand, defined in atom_para_module.f90 , there are atom_num_l , which is the number of local atoms in each processor domain, atom_num_lg , which is the number of local AND ghost atoms in each processor domain, and atom_num_lr , which is the actual size of the second dimension of some atom -related arrays. The differences between atom_num_l , atom_num_lg , and atom_num_lr , as well as their relation with some atom -related arrays are explained below. Say that the system contains 100 atoms using three processors, then either read_restart.f90 (if one restarts a previous simulation) or model_assemble.f90 (if one builds the model from scratch), set by boolean_restart , will first calculate atom_num_l as atom_num_l = nint((real(atom_num, wp) / pro_num) * 1.2_wp) In our case, atom_num_l = 40, following which most atom -related arrays are allocated. Next, in processor_scatter_atomistic.f90 , one first lets atom_num_lr equal atom_num_l , then the root processor distributes all atoms to all processors (including root itself); if the actual number of local atoms one processor should have is larger than atom_num_lr , atom_num_lr is increased by seg_num which is 1024 as set in module/cac_para_module.f90 . In the meantime, many atom -related arrays also increase their size. Assume that the root processor should contain 50 local atoms while the other two processors 25 each, atom_num_lr becomes 40 + 1024 = 1064 for root but still 40 for the other two processors. At the end of this subroutine, some atom -related arrays, e.g., r_atom , have a size of 3 by 1064 for root while 3 by 40 for the other two processors; atom_num_l , which is expected to be the number of local atoms for each processor, is re-calculated to be 50 for root and 25 for the other two processors. Next, in processor_ghost_atomistic.f90 , the ghost atoms are added to the end of some atom -related arrays. Again, if the number of local+ghost atoms is larger than atom_num_lr , atom_num_lr is further increased by seg_num , along with the expansion in size of some atom -related arrays. Assume that the numbers of ghost atoms are 30, 10, and 20 for the three processors, respectively, atom_num_lr would be 1064 for root (because 50 + 30 < 1064), 40 for processor 1 (because 25 + 10 < 40), and 1064 for processor 2 (because 25 + 20 > 40). In other words, atom_num_lr increases for the last processor while remaining the same for the other two processors. At the end of this subroutine, atom_num_lg is assigned as the actual number of local + ghost atoms, i.e., 80, 35, and 45 for the three processors, respectively. In sum, atom_num_l <= atom_num_lg <= atom_num_lr . Note that (i) atom_num is the total number of real atoms in the system, i.e., 100, regardless of how many processors are involved and how many ghost atoms are needed; (ii) in the case of single processor, there may still be ghost atoms if periodic boundary conditions are used.","title":"atom"},{"location":"chapter-9/atom-atomap/#atomap","text":"There are also some arrays with atomap in their names, e.g., r_atomap , which is the positions of interpolated atoms in the coarse-grained domain. On the other hand, defined in interpo_para_module.f90 , there are atomap_num_l , which is the number of interpolated atoms in each processor domain, atomap_num_lg , which is the number of local AND ghost interpolated atoms in each processor domain, and atomap_num_lr , which is the actual size of the second dimension of some atomap -related arrays. The differences between atomap_num_l , atomap_num_lg , and atomap_num_lr , as well as their relation with some atomap -related arrays are similar to those of atom -related variables and arrays, except that two other subroutines, processor_scatter_cg.f90 and processor_ghost_cg.f90 , are involved.","title":"atomap"},{"location":"chapter-9/atom-atomap/#remark","text":"In PyCAC, arrays for the atomistic domain, e.g., atom -related arrays, and those for the coarse-grained domain, e.g., atomap -related, node -related, and ele -related arrays, are completely separated. Take the position vector as an example, a processor may simultaneously have a r_atom array and a r_atomap array, yet it only has a r_atom or a r_atomap array if the system only contains real or interpolated atoms, i.e., fully atomistic or fully coarse-grained models. If one wants to add an additional array to the atomistic domain, e.g., to distinguish between different types of real atoms, one almost always has to also add a similar array to the coarse-grained domain to distinguish different types of interpolated atoms, nodes, and elements.","title":"Remark"}]}